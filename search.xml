<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jetpack之Navigation]]></title>
    <url>%2F2020%2F06%2F16%2Fjetpack%E4%B9%8BNavigation%2F</url>
    <content type="text"><![CDATA[概述 AndroidJetpack架构组件套件之一 简化了Android应用程序中导航的实现 官网地址 https://developer.android.google.cn/topic/libraries/architecture/navigation/ 这里只是简单的学习一下，实际项目中并未用到，用到再去官网详细学吧 组成导航组件由以下三个关键部分组成： 导航图：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为目标）以及用户可以通过应用获取的可能路径。 NavHost：显示导航图中目标的空白容器。导航组件包含一个默认 NavHost 实现 (NavHostFragment)，可显示 Fragment 目标。 NavController：在 NavHost 中管理应用导航的对象。当用户在整个应用中移动时，NavController 会安排 NavHost 中目标内容的交换。 使用1.要求 目前仅在Android Studio 3.2（目前是preview）版本以上才支持 2.添加项目依赖 123// navigationimplementation &apos;androidx.navigation:navigation-fragment:2.2.2&apos;implementation &apos;androidx.navigation:navigation-ui:2.2.2&apos; 3.创建Navigation res文件夹，选中点击右键选择New &gt; Android resource file. 如下图： 在弹出的对话框中，File name一栏，填写例如”nav_main”，Resource type一栏选择 Navigation，然后点击OK，如下图： 创建好之后，会发现在res文件夹目录下面，会自动生成一个navigation文件夹，然后刚才我们创建的xml文件nav_main也放在里面，如下图： 打开nav_main.xml，选中design模式 进入design模式后，点击下面这个New Destination 按钮 选择Create blank destination 命名Fragment名称为FragmentA，如下图 那个 include fragment factory methods？ 选中的话会帮你自动重写一些fragment的方法，像onCreate(),onCreateView()和构造方法等，看起来会有点乱，自己实现也行 同上，再创建一个FragmentB 在design模式下，创建导航链接，鼠标点击FragmentA右边中间圆圈不放拖动到FragmentB上释放鼠标即可，如下图： 点击切换到Text模式，对应nav_main.xml对应生成的代码如下： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/nav_main" app:startDestination="@id/fragmentA"&gt; &lt;fragment android:id="@+id/fragmentA" android:name="com.ccc.navigationdemo.FragmentA" android:label="fragment_a" tools:layout="@layout/fragment_a" &gt; &lt;action android:id="@+id/action_fragmentA_to_fragmentB" app:destination="@id/fragmentB" /&gt; &lt;/fragment&gt; &lt;fragment android:id="@+id/fragmentB" android:name="com.ccc.navigationdemo.FragmentB" android:label="fragment_b" tools:layout="@layout/fragment_b" /&gt;&lt;/navigation&gt; 说明： 里面有两个fragment标签，就是我们刚才创建的页面A和B。 其中fragmentA中的action是一个节点，destination就是要导航到fragmentB。这个就是我们刚才上一步创建导航连接自动实现的代码。 MainActivity里面对应不需要任何操作，设置好布局即可 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 接下来，在activity_main里面创建一个fragment 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;fragment android:id="@+id/nav_host_fragment" android:layout_width="match_parent" android:layout_height="match_parent" android:name="androidx.navigation.fragment.NavHostFragment" app:navGraph = "@navigation/nav_main" app:defaultNavHost = "true" /&gt;&lt;/LinearLayout&gt; 来说明一下后面三个属性 name属性，指定在布局中要实例化NavHostFragment navGraph属性，是将NavHostFragment与我们刚才创建的navigation进行关联 defaultNavHost属性，app:defaultNavHost=&quot;true&quot;，意思是NavHostFragment来拦截系统返回按钮 下面来实现页面跳转和数据传递 fragment_a.xml如下设置 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="vertical" android:layout_margin="20dp" tools:context=".FragmentA"&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="Fragment A" /&gt; &lt;Button android:id="@+id/btn_to_b" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击跳转到 Fragment B"/&gt;&lt;/LinearLayout&gt; fragment_b.xml 如下设置： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="vertical" tools:context=".FragmentB"&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="Fragment B" /&gt; &lt;TextView android:layout_margin="20dp" android:id="@+id/show" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="show"/&gt;&lt;/LinearLayout&gt; 在FragmentA中添加Button点击跳转事件，跳到FragmentB 12345678910111213141516171819202122232425262728293031323334public class FragmentA extends Fragment &#123; private Button button; private View view; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; view = inflater.inflate(R.layout.fragment_a, container, false); return view; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); button = view.findViewById(R.id.btn_to_b); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 传递参数 Bundle bundle = new Bundle(); bundle.putString("name","chrome"); //不带参数 //Navigation.findNavController(v).navigate(R.id.action_fragmentA_to_fragmentB); //带参数 Navigation.findNavController(v).navigate(R.id.action_fragmentA_to_fragmentB,bundle); &#125; &#125;); &#125;&#125; 说明 这里的 id = action_fragmentA_to_fragmentB，就是上面设置的导航action的id 传递参数 方式1：通过Bundle方式 1234// 传递参数Bundle bundle = new Bundle();bundle.putString("name","chrome"); Navigation.findNavController(v).navigate(R.id.action_fragmentA_to_fragmentB,bundle); b页面接收： 123456//通过 getArguments 来获取传递的参数Bundle bundle = getArguments();String text = bundle.getString("name");tv = view.findViewById(R.id.show);tv.setText(text); 方式2：使用Safe Args 传递安全的数据 这玩意比较麻烦感觉，用到时候去官网再学吧 https://developer.android.google.cn/guide/navigation/navigation-pass-data#Safe-args 运行一下，看一下效果。 两篇学习博客https://www.jianshu.com/p/cd925c2398cb https://www.jianshu.com/p/729375b932fe]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android属性动画使用技巧]]></title>
    <url>%2F2020%2F06%2F14%2FAndroid%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[组合动画实现 组合动画 的功能： AnimatorSet 类 12345AnimatorSet.play(Animator anim) ：播放当前动画AnimatorSet.after(long delay) ：将现有动画延迟x毫秒后执行AnimatorSet.with(Animator anim) ：将现有动画和传入的动画同时执行AnimatorSet.after(Animator anim) ：将现有动画插入到传入的动画之后执行AnimatorSet.before(Animator anim) ： 将现有动画插入到传入的动画之前执行 s###### 实例练习实现效果：主要动画是平移，平移过程中伴随旋转动画，平移完后进行透明度变化&gt; 实现方式有 XML设置 / Java代码设置方式1：Java代码设置1234567891011121314151617// 步骤1：设置需要组合的动画效果ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX); // 平移动画ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f); // 旋转动画ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f); // 透明度动画// 步骤2：创建组合动画的对象AnimatorSet animSet = new AnimatorSet(); // 步骤3：根据需求组合动画animSet.play(translation).with(rotate).before(alpha); animSet.setDuration(5000); // 步骤4：启动动画animSet.start(); 效果： 方式2： XML 设置 set_animation.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="sequentially" &gt; // 表示Set集合内的动画按顺序进行 // ordering的属性值:sequentially &amp; together // sequentially:表示set中的动画，按照先后顺序逐步进行（a 完成之后进行 b ） // together:表示set中的动画，在同一时间同时进行,为默认值 &lt;set android:ordering="together" &gt; // 下面的动画同时进行 &lt;objectAnimator android:duration="2000" android:propertyName="translationX" android:valueFrom="0" android:valueTo="300" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration="3000" android:propertyName="rotation" android:valueFrom="0" android:valueTo="360" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; &lt;/set&gt; &lt;set android:ordering="sequentially" &gt; // 下面的动画按序进行 &lt;objectAnimator android:duration="1500" android:propertyName="alpha" android:valueFrom="1" android:valueTo="0" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration="1500" android:propertyName="alpha" android:valueFrom="0" android:valueTo="1" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; &lt;/set&gt;&lt;/set&gt; 在java代码中启用动画 123456789mButton = (Button) findViewById(R.id.Button); // 创建动画作用对象：此处以Button为例 AnimatorSet animator = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.animator.set_animation);// 创建组合动画对象 &amp; 加载XML动画 animator.setTarget(mButton); // 设置动画作用对象 animator.start(); // 启动动画 基本上和前面学的差不多。 快捷使用简介 从属性动画的原理可知，属性动画的本质是：对值进行操作 但Java是面向对象的，所以 Google 团队添加面向对象操作的属性动画使用 - ViewPropertyAnimator类 可认为是属性动画的一种简写、快捷使用方式 使用123456View.animate().xxx().xxx();// ViewPropertyAnimator的功能建立在animate()上// 调用animate()方法返回值是一个ViewPropertyAnimator对象,之后的调用的所有方法都是通过该实例完成// 调用该实例的各种方法来实现动画效果// ViewPropertyAnimator所有接口方法都使用连缀语法来设计，每个方法的返回值都是它自身的实例// 因此调用完一个方法后可直接连缀调用另一方法,即可通过一行代码就完成所有动画效果 实例： 1234567891011121314mButton = (Button) findViewById(R.id.Button);// 创建动画作用对象：此处以Button为例mButton.animate().alpha(0f);// 单个动画设置:将按钮变成透明状态 mButton.animate().alpha(0f).setDuration(5000).setInterpolator(new BounceInterpolator());// 单个动画效果设置 &amp; 参数设置 mButton.animate().alpha(0f).x(500).y(500);// 组合动画:将按钮变成透明状态再移动到(500,500)处// 特别注意:// 动画自动启动,无需调用start()方法.因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成后，动画就会自动启动// 该机制对于组合动画也同样有效，只要不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动// 如果不想使用这一默认机制，也可以显式地调用start()方法来启动动画 有很多可以连缀的语法，用到时候再去查。 监听动画 Animation类通过监听动画开始 / 结束 / 重复 / 取消时刻来进行一系列操作，如跳转页面等等 使用 通过在Java代码里addListener()设置 1234567891011121314151617181920212223 Animation.addListener(new AnimatorListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; //动画开始时执行 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; //动画重复时执行 &#125; @Override public void onAnimationCancel()(Animation animation) &#123; //动画取消时执行 &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时执行 &#125; &#125;);// 特别注意：每次监听必须4个方法都重写。 注意 因Animator类、AnimatorSet类、ValueAnimator、ObjectAnimator类存在以下继承关系 所以AnimatorSet类、ValueAnimator、ObjectAnimator都可以使用addListener()监听器进行动画监听 动画适配器有些时候我们并不需要监听动画的所有时刻，但addListener(new AnimatorListener())监听器是必须重写4个时刻方法，这使得接口方法重写太累赘，因此采用动画适配器（AnimatorListenerAdapter），解决实现接口繁琐 的问题 123456789anim.addListener(new AnimatorListenerAdapter() &#123; // 向addListener()方法中传入适配器对象AnimatorListenerAdapter()// 由于AnimatorListenerAdapter中已经实现好每个接口// 所以这里不实现全部方法也不会报错 @Override public void onAnimationStart(Animator animation) &#123; // 如想只想监听动画开始时刻，就只需要单独重写该方法就可以 &#125; &#125;); Demo 地址https://github.com/Commandercc/DemoEX/blob/master/AnimationDmeo3.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕分辨率及UI尺寸学习]]></title>
    <url>%2F2020%2F06%2F14%2FAndroid%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%8AUI%E5%B0%BA%E5%AF%B8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[几个概念分辨率分辨率。分辨率就是手机屏幕的像素点数，一般描述成屏幕的“宽×高”，安卓手机屏幕常见的分辨率有480×800、720×1280、1080×1920等。720×1280表示此屏幕在宽度方向有720个像素，在高度方向有1280个像素。 S 屏幕大小屏幕大小是手机 对角线 的物理尺寸，以英寸（inch）为单位（1英寸 = 2.54厘米）。比如某某手机为“5寸大屏手机”，就是指对角线的尺寸，5寸×2.54厘米/寸=12.7厘米。 密度密度（dpi，dots per inch）。从英文顾名思义，就是每英寸的像素点数，数值越高当然显示越细腻。假如我们知道一部手机的分辨率是1080×1920，屏幕大小是5英寸，你能否算出此屏幕的密度呢？哈哈，中学的勾股定理派上用场啦！通过宽1080和高1920，根据勾股定理，我们得出对角线的像素数大约是2203，那么用2203除以5就是此屏幕的密度了，计算结果是440。440dpi的屏幕已经相当细腻了。 实际密度和系统密度 “实际密度”就是我们自己算出来的密度，这个密度代表了屏幕真实的细腻程度，如上述例子中的440dpi就是实际密度，说明这块屏幕每寸有440个像素。5英寸1080×1920的屏幕密度是440，而相同分辨率的4.5英寸屏幕密度是490。如此看来，屏幕密度将会出现很多数值，呈现严重的碎片化。而密度又是安卓屏幕将界面进行缩放显示的依据，那么安卓是如何适配这么多屏幕的呢？ 每部安卓手机屏幕都有一个初始的固定密度，这些数值是120、160、240、320、480，我们权且称为“系统密度”。大家发现规律没有？相隔数值之间是2倍的关系。一般情况下，240×320的屏幕是低密度120dpi，即ldpi；320×480的屏幕是中密度160dpi，即mdpi；480×800的屏幕是高密度240dpi，即hdpi；720×1280的屏幕是超高密度320dpi，即xhdpi；1080×1920的屏幕是超超高密度480dpi，即xxhdpi。 安卓对界面元素进行缩放的比例依据正是系统密度，而不是实际密度。 pxpx：(pixels)（像素）：屏幕上的点，与密度相关。密度大了，单位面积上的px会比较多。表示屏幕实际的象素。例如，320*480的屏幕在横向有320个像素，在纵向有480个像素。 dpdp也可写为dip，即density-independent pixel。你可以想象dp更类似一个物理尺寸，比如一张宽和高均为100dp的图片在320×480和480×800的手机上“看起来”一样大。而实际上，它们的像素值并不一样。dp正是这样一个尺寸，不管这个屏幕的密度是多少，屏幕上相同dp大小的元素看起来始终差不多大。 另外，文字尺寸使用sp，即scale-independentpixel的缩写，这样，当你在系统设置里调节字号大小时，应用中的文字也会随之变大变小。 spsp（与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。 pt表示一个点，是屏幕的一个物理长度，大小为1英寸的1/72。 密度值 = 每英寸的像素点数 pt = 密度值 / 72 说明屏幕密度为160，这时dp和sp和px是一 样的。1dp=1sp=1px。 但如果使用px作单位，如果屏幕大小不变（假设还是3.2寸），而屏幕密度变成了320。那么原来TextView的宽度 设成160px，在密度为320的3.2寸屏幕里看要比在密度为160的3.2寸屏幕上看短了一半。但如果设置成160dp或160sp的话。系统会自动 将width属性值设置成320px的。也就是160 * 320 / 160。其中320 / 160可称为密度比例因子。也就是说，如果使用dp和sp，系统会根据屏幕密度的变化自动进行转换。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interpolator插值器学习]]></title>
    <url>%2F2020%2F06%2F14%2FInterpolator%E6%8F%92%E5%80%BC%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述简介 定义：Android实现动画效果中的一个辅助接口 作用：设置 属性值 从初始值过渡到结束值 的变化规律 如匀速、加速 &amp; 减速 等等 即确定了 动画效果变化的模式，如匀速变化、加速变化 等等 应用场景实现非线性运动的动画效果 非线性运动：动画改变的速率不是一成不变的，如加速 &amp; 减速运动都属于非线性运动 具体使用插值器在动画的使用有两种方式：在XML / Java代码中设置： XML设置前面多少都接触过了。 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:anim/overshoot_interpolator" // 通过资源ID设置插值器 android:duration="3000" android:fromXScale="0.0" android:fromYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:toXScale="2" android:toYScale="2" /&gt;&gt; Java设置123456789101112131415Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation alphaAnimation = new AlphaAnimation(1,0);// 步骤2：创建透明度动画的对象 &amp; 设置动画效果alphaAnimation.setDuration(3000);Interpolator overshootInterpolator = new OvershootInterpolator();// 步骤3：创建对应的插值器类对象alphaAnimation.setInterpolator(overshootInterpolator);// 步骤4：给动画设置插值器mButton.startAnimation(alphaAnimation);// 步骤5：播放动画 系统内置插值器类型Android系统内置了9种插值器 使用 当在XML文件设置插值器时，只需传入对应的插值器资源ID即可 当在Java代码设置插值器时，只需创建对应的插值器对象即可 使用Android内置的插值器能满足大多数的动画需求 系统默认的插值器是AccelerateDecelerateInterpolator，即先加速后减速 如果上述9个插值器无法满足需求，还可以自定义插值器 自定义插值器本质根据动画的进度（0%-100%）计算出当前属性值改变的百分比 实现方式自定义插值器需要实现 Interpolator / TimeInterpolator接口 &amp; 复写getInterpolation（） 补间动画 实现 Interpolator接口；属性动画实现TimeInterpolator接口 TimeInterpolator接口是属性动画中新增的，用于兼容Interpolator接口，这使得所有过去的Interpolator实现类都可以直接在属性动画使用 1234567891011121314151617181920212223// Interpolator接口public interface Interpolator &#123; // 内部只有一个方法 float getInterpolation(float input) &#123; // 参数说明 // input值值变化范围是0-1，且随着动画进度（0% - 100% ）均匀变化 // 即动画开始时，input值 = 0；动画结束时input = 1 // 而中间的值则是随着动画的进度（0% - 100%）在0到1之间均匀增加 ...// 插值器的计算逻辑 return xxx； // 返回的值就是用于估值器继续计算的fraction值，下面会详细说明 &#125; // TimeInterpolator接口// 同上public interface TimeInterpolator &#123; float getInterpolation(float input); &#125; 在学习自定义插值器前，我们先来看两个已经实现好的系统内置差值器： 匀速插值器：LinearInterpolator 先加速再减速 插值器：AccelerateDecelerateInterpolator 12345678910111213141516171819202122232425262728// 匀速差值器：LinearInterpolator@HasNativeInterpolator public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return input; // 没有对input值进行任何逻辑处理，直接返回 // 即input值 = fraction值 // 因为input值是匀速增加的，因此fraction值也是匀速增加的，所以动画的运动情况也是匀速的，所以是匀速插值器 &#125; // 先加速再减速 差值器：AccelerateDecelerateInterpolator@HasNativeInterpolator public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory &#123; // 仅贴出关键代码 ... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; // input的运算逻辑如下： // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。 // 而cos(π)的结果是-1，cos(2π)的结果是1 // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程 // 所以最终，fraction值 = 运算后的值 = 先加速后减速 // 所以该差值器是先加速再减速的 &#125; &#125; 实例说明实现一个 自定义 Interpolator : 先减速后加速 步骤1：根据需求实现 Interpolator 接口 123456789101112131415161718public class DecelerateAccelerateInterpolator implements TimeInterpolator &#123; @Override public float getInterpolation(float input) &#123; float result; if (input &lt;= 0.5) &#123; result = (float) (Math.sin(Math.PI * input)) / 2; // 使用正弦函数来实现先减速后加速的功能，逻辑如下： // 因为正弦函数初始弧度变化值非常大，刚好和余弦函数是相反的 // 随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。 // 当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果 &#125; else &#123; result = (float) (2 - Math.sin(Math.PI * input)) / 2; &#125; return result; // 返回的result值 = 随着动画进度呈先减速后加速的变化趋势 &#125;&#125; 步骤2： 设置使用 12345678910111213141516171819202122232425public class Demo_Interpolator extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo__interpolator); button = findViewById(R.id.dec_accel); //获得按钮的当前位置 float curTranslationX = button.getTranslationX(); ObjectAnimator animator = ObjectAnimator.ofFloat(button,"translationX",curTranslationX,500,curTranslationX); // 创建动画对象 &amp; 设置动画 // 表示的是: // 动画作用对象是mButton // 动画作用的对象的属性是X轴平移 // 动画效果是:从当前位置平移到 x=1500 再平移到初始位置 animator.setDuration(5000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.start(); &#125;&#125; 效果 与估值器区别 正余弦图像md,差点连图像怎么画都忘了 sin(x): cos(x): Demo 地址https://github.com/Commandercc/DemoEX/blob/master/AnimationDmeo3.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectAnimator学习]]></title>
    <url>%2F2020%2F06%2F13%2FObjectAnimator%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述简介 实现属性动画中的一个核心方法类 继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类 原理直接对对象的属性值进行改变操作，从而实现动画效果。如直接改变 View的 alpha 属性 从而实现透明度的动画效果。 通过不断控制 值 的变化，再不断 自动 赋给对象的属性，从而实现动画效果。如下图： 基础使用因为是继承了ValueAnimator类，所以使用的方法和前面学的十分类似：XML 设置 / Java设置 Java代码设置123456789101112131415161718192021222324252627282930ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); // ofFloat()作用有两个// 1. 创建动画实例// 2. 参数设置：参数说明如下// Object object：需要操作的对象// String property：需要操作的对象的属性// float ....values：动画初始值 &amp; 结束值（不固定长度）// 若是两个参数a,b，则动画效果则是从属性的a值到b值// 若是三个参数a,b,c，则则动画效果则是从属性的a值到b值再到c值// 以此类推// 至于如何从初始值 过渡到 结束值，同样是由估值器决定，此处ObjectAnimator.ofFloat（）是有系统内置的浮点型估值器FloatEvaluator，同ValueAnimator讲解 animator.setDuration(500); // 设置动画运行的时长 animator.setStartDelay(500); // 设置动画延迟播放时间 animator.setRepeatCount(0); // 设置动画重复播放次数 = 重放次数+1 // 动画播放次数 = infinite时,动画无限重复 animator.setRepeatMode(ValueAnimator.RESTART); // 设置重复播放动画模式 // ValueAnimator.RESTART(默认):正序重放 // ValueAnimator.REVERSE:倒序回放animator.start(); // 启动动画 上述代码中，如果输入了不存在的 property 属性，Androidstudio会提示的 基本属性123456789101112131415//1、透明度：alpha public void setAlpha(float alpha) //2、旋转度数：rotation、rotationX、rotationY public void setRotation(float rotation) public void setRotationX(float rotationX) public void setRotationY(float rotationY) //3、平移：translationX、translationY public void setTranslationX(float translationX) public void setTranslationY(float translationY) //缩放：scaleX、scaleY public void setScaleX(float scaleX) public void setScaleY(float scaleY) 各种属性的详细解释和演示: https://wiki.jikexueyuan.com/project/android-animation/7.html XML 代码中设置res/animator/set_animation.xml 12345678// ObjectAnimator 采用&lt;animator&gt; 标签&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="1" // 初始值 android:valueTo="0" // 结束值 android:valueType="floatType" // 变化值类型 ：floatType &amp; intType android:propertyName="alpha" // 对象变化的属性名称/&gt; 在Java代码中启动动画 12345678Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation); // 载入XML动画animator.setTarget(view); // 设置动画对象animator.start(); // 启动动画 使用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Demo_ObjectAnimator extends AppCompatActivity &#123; private Button btn_alpha, btn_translate, btn_rotate, btn_scale; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo__object_animator); btn_alpha = findViewById(R.id.btn_alpha); btn_translate = findViewById(R.id.btn_translate); btn_rotate = findViewById(R.id.btn_rotate); btn_scale = findViewById(R.id.btn_scale); //1. 透明度动画 ObjectAnimator animator = ObjectAnimator.ofFloat(btn_alpha, "alpha", 1f, 0f, 1f); // 表示的是: // 动画作用对象是btn_alpha // 动画作用的对象的属性是 透明度alpha 如果输入了不存在的属性 会出现提示 // 动画效果是:常规 - 全透明 - 常规 animator.setDuration(5000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.start(); //2.旋转动画 ObjectAnimator animator1 = ObjectAnimator.ofFloat(btn_rotate, "rotation", 0f, 360f); // 表示的是: // 动画作用对象是btn_rotate // 动画作用的对象的属性是 旋转rotation // 动画效果是:0 - 360 animator1.setDuration(5000); animator1.setRepeatCount(ValueAnimator.INFINITE); animator1.start(); //3.平移 float curTranslationX = btn_translate.getTranslationX(); //获取按钮当前位置 ObjectAnimator animator2 = ObjectAnimator.ofFloat(btn_translate, "translationX", curTranslationX, 300, curTranslationX); // 表示的是: // 动画作用对象是btn_translate // 动画作用的对象的属性是X轴平移（在Y轴上平移同理，采用属性"translationY") // 动画效果是:从当前位置 向右平移300 再平移到初始位置 // 再例如 ObjectAnimator animator = ObjectAnimator.ofFloat(tv, "translationY", 0, 200, -100,0); // 则表示指定的移动距离是（0, 200, -200,0），所以控件会从自身所有位置向右移动 200 像素，然后再移动到距离原点-200 的位置，最后回到原点 animator2.setDuration(5000); animator2.setRepeatCount(ValueAnimator.INFINITE); animator2.start(); //4.缩放 ObjectAnimator animator3 = ObjectAnimator.ofFloat(btn_scale, "scaleX", 1f, 3f, 1f); // 表示的是: // 动画作用对象是btn_scale // 动画作用的对象的属性是X轴缩放 // 动画效果是:放大到3倍,再缩小到初始大小 animator3.setDuration(5000); animator3.setRepeatCount(ValueAnimator.INFINITE); animator3.start(); &#125;&#125; 效果： 通过自定义对象属性实现动画效果说明 在上面的学习中，我们使用了属性动画最基本的四种动画效果：透明度、平移、旋转 &amp; 缩放 即在ObjectAnimator.ofFloat()的第二个参数String property传入alpha、rotation、translationX 和 scaleY 等 其实，ofFloat() 的第二个参数可以传入 任意属性值。 ObjectAnimator 类 对 对象属性值 进行改变从而实现动画效果的本质是：通过不断控制 值 的变化，再不断 自动 赋给对象的属性，从而实现动画效果。 而 自动赋给对象的属性 的本质是调用该对象属性的 set() &amp; get() 方法进行赋值 所以，ObjectAnimator.ofFloat(Object object, String property, float ....values)的第二个参数传入值的作用是：让ObjectAnimator类根据传入的属性名 去寻找 该对象对应属性名的 set() &amp; get()方法，从而进行对象属性值的赋值，如上面的例子： 12345678910111213ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f); // 其实Button对象中并没有rotation这个属性值 // ObjectAnimator并不是直接对我们传入的属性名进行操作 // 而是根据传入的属性值"rotation" 去寻找对象对应属性名对应的get和set方法，从而通过set() &amp; get()对属性进行赋值 // 因为Button对象中有rotation属性所对应的get &amp; set方法 // 所以传入的rotation属性是有效的 // 所以才能对rotation这个属性进行操作赋值 public void setRotation(float value); public float getRotation(); // 实际上，这两个方法是由View对象提供的，所以任何继承自View的对象都具备这个属性 原理解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 使用方法ObjectAnimator animator = ObjectAnimator.ofFloat(Object object, String property, float ....values); anim.setDuration(500);animator.start(); // 启动动画，源码分析就直接从start()开始&lt;-- start() --&gt;@Override public void start() &#123; AnimationHandler handler = sAnimationHandler.get(); if (handler != null) &#123; // 判断等待动画（Pending）中是否有和当前动画相同的动画，如果有就把相同的动画给取消掉 numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; // 判断延迟动画（Delay）中是否有和当前动画相同的动画，如果有就把相同的动画给取消掉 numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; &#125; super.start(); // 调用父类的start() // 因为ObjectAnimator类继承ValueAnimator类，所以调用的是ValueAnimator的star（） // 经过层层调用，最终会调用到 自动赋值给对象属性值的方法 (重点理解) // 下面就直接看该部分的方法&#125; &lt;-- 自动赋值给对象属性值的逻辑方法 -&gt;&gt;// 步骤1：初始化动画值 (伪代码)private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; kf.setValue(mProperty.get(target)); // 初始化时，如果属性的初始值没有提供，则调用属性的get（）进行取值 &#125;else&#123; kf.setValue(mGetter.invoke(target)); &#125; &#125; // 步骤2：更新动画值// 当动画下一帧来时（即动画更新的时候），setAnimatedValue()都会被调用void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); // 内部调用对象该属性的set()方法，从而从而将新的属性值设置给对象属性 &#125; &#125; 自动赋值的逻辑： 初始化时，如果属性的初始值没有提供，则调用属性的 get()进行取值； 当 值 变化时，用对象该属性的 set()方法，从而从而将新的属性值设置给对象属性。 所以： ObjectAnimator 类针对的是任意对象 &amp; 任意属性值，并不是单单针对于View对象 如果需要采用ObjectAnimator 类实现动画效果，那么需要操作的对象就必须有该属性的set() &amp; get() 具体使用对于属性动画，其拓展性在于：不局限于系统限定的动画，可以自定义动画，即自定义对象的属性，并通过操作自定义的属性从而实现动画。 那么，该如何自定义属性呢？本质上，就是： 为对象设置需要操作属性的set() &amp; get()方法 通过实现TypeEvaluator类从而定义属性变化的逻辑 类似于ValueAnimator的过程 实例练习实现的动画效果：一个圆的颜色渐变 逻辑如下： 步骤1：设置对象类属性的 set() &amp; get() 方法 通过继承原始类，直接给类加上该属性的 get()&amp; set()，从而实现给对象加上该属性的 get()&amp; set() 通过包装原始动画对象，间接给对象加上该属性的 get()&amp; set()。即 用一个类来包装原始对象 下面用第一种来实现一下： MyView2.java 1234567891011121314151617181920212223242526272829303132333435363738public class MyView2 extends View &#123; // 设置需要用到的变量 public static final float RADIUS = 100f;// 圆的半径 = 100 private Paint mPaint;// 绘图画笔 private String color; // 设置背景颜色属性 // 设置背景颜色的get() &amp; set()方法 public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; mPaint.setColor(Color.parseColor(color)); // 将画笔的颜色设置成方法参数传入的颜色 invalidate(); // 调用了invalidate()方法,即画笔颜色每次改变都会刷新视图，然后调用onDraw()方法重新绘制圆 // 而因为每次调用onDraw()方法时画笔的颜色都会改变,所以圆的颜色也会改变 &#125; // 构造方法(初始化画笔) public MyView2(Context context, AttributeSet attrs) &#123; super(context, attrs); // 初始化画笔 mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); &#125; // 复写onDraw()从而实现绘制逻辑 // 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果 @Override protected void onDraw(Canvas canvas) &#123; canvas.drawCircle(500, 500, RADIUS, mPaint); &#125;&#125; 步骤2：在布局中引入myview2 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" tools:context=".Demo_ObjectAnimator2"&gt; &lt;com.ccc.animationdmeo3.objectDemo2.MyView2 android:id="@+id/myView2" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; 步骤3：根据需求实现TypeEvaluator接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class ColorEvaluator implements TypeEvaluator &#123; // 实现TypeEvaluator接口 private int mCurrentRed; private int mCurrentGreen ; private int mCurrentBlue ; // 复写evaluate（） // 在evaluate（）里写入对象动画过渡的逻辑:此处是写颜色过渡的逻辑 @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; // 获取到颜色的初始值和结束值 String startColor = (String) startValue; String endColor = (String) endValue; // 通过字符串截取的方式将初始化颜色分为RGB三个部分，并将RGB的值转换成十进制数字 // 那么每个颜色的取值范围就是0-255 int startRed = Integer.parseInt(startColor.substring(1, 3), 16); int startGreen = Integer.parseInt(startColor.substring(3, 5), 16); int startBlue = Integer.parseInt(startColor.substring(5, 7), 16); int endRed = Integer.parseInt(endColor.substring(1, 3), 16); int endGreen = Integer.parseInt(endColor.substring(3, 5), 16); int endBlue = Integer.parseInt(endColor.substring(5, 7), 16); // 将初始化颜色的值定义为当前需要操作的颜色值 mCurrentRed = startRed; mCurrentGreen = startGreen; mCurrentBlue = startBlue; // 计算初始颜色和结束颜色之间的差值 // 该差值决定着颜色变化的快慢:初始颜色值和结束颜色值很相近，那么颜色变化就会比较缓慢;否则,变化则很快 // 具体如何根据差值来决定颜色变化快慢的逻辑写在getCurrentColor()里. int redDiff = Math.abs(startRed - endRed); int greenDiff = Math.abs(startGreen - endGreen); int blueDiff = Math.abs(startBlue - endBlue); int colorDiff = redDiff + greenDiff + blueDiff; if (mCurrentRed != endRed) &#123; mCurrentRed = getCurrentColor(startRed, endRed, colorDiff, 0, fraction); // getCurrentColor()决定如何根据差值来决定颜色变化的快慢 -&gt;&gt;关注1 &#125; else if (mCurrentGreen != endGreen) &#123; mCurrentGreen = getCurrentColor(startGreen, endGreen, colorDiff, redDiff, fraction); &#125; else if (mCurrentBlue != endBlue) &#123; mCurrentBlue = getCurrentColor(startBlue, endBlue, colorDiff, redDiff + greenDiff, fraction); &#125; // 将计算出的当前颜色的值组装返回 String currentColor = "#" + getHexString(mCurrentRed) + getHexString(mCurrentGreen) + getHexString(mCurrentBlue); // 由于我们计算出的颜色是十进制数字，所以需要转换成十六进制字符串:调用getHexString()-&gt;&gt;关注2 // 最终将RGB颜色拼装起来,并作为最终的结果返回 return currentColor; &#125; // 关注1:getCurrentColor() // 具体是根据fraction值来计算当前的颜色。 private int getCurrentColor(int startColor, int endColor, int colorDiff, int offset, float fraction) &#123; int currentColor; if (startColor &gt; endColor) &#123; currentColor = (int) (startColor - (fraction * colorDiff - offset)); if (currentColor &lt; endColor) &#123; currentColor = endColor; &#125; &#125; else &#123; currentColor = (int) (startColor + (fraction * colorDiff - offset)); if (currentColor &gt; endColor) &#123; currentColor = endColor; &#125; &#125; return currentColor; &#125; // 关注2:将10进制颜色值转换成16进制。 private String getHexString(int value) &#123; String hexString = Integer.toHexString(value); if (hexString.length() == 1) &#123; hexString = "0" + hexString; &#125; return hexString; &#125;&#125; 步骤4： 调用ObjectAnimator.ofObject() 方法 自定义对象属性，我们用的是 ObjectAnimator.ofObject() 方法，该方法不同于前面的ofFloat()，需要额外传入一个自定义的属性估值器 源码： 1234567public static ObjectAnimator ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object... values) &#123; ObjectAnimator anim = new ObjectAnimator(target, propertyName); anim.setObjectValues(values); anim.setEvaluator(evaluator); return anim;&#125; 方法调用： 123456789101112131415161718192021public class Demo_ObjectAnimator2 extends AppCompatActivity &#123; private MyView2 myView2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo__object_animator2); myView2 = findViewById(R.id.myView2); ObjectAnimator animator = ObjectAnimator.ofObject(myView2,"color",new ColorEvaluator(),"#0000FF","#FF0000"); // 设置自定义View对象、背景颜色属性值 &amp; 颜色估值器 // 本质逻辑： // 步骤1：根据颜色估值器不断 改变 值 // 步骤2：调用set()设置背景颜色的属性值（实际上是通过画笔进行颜色设置） // 步骤3：调用invalidate()刷新视图，即调用onDraw()重新绘制，从而实现动画效果 animator.setDuration(8000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.start(); &#125;&#125; 效果 说明 ObjectAnimator 类 自动赋给对象的属性 的本质是调用该对象属性的set() &amp; get()方法进行赋值 所以，ObjectAnimator.ofFloat(Object object, String property, float ....values)的第二个参数传入值的作用是：让ObjectAnimator类根据传入的属性名 去寻找 该对象对应属性名的 set() &amp; get()方法，从而进行对象属性值的赋值 从上面的原理可知，如果想让对象的属性a的动画生效，属性a需要同时满足下面两个条件： 1.对象必须要提供属性a的set()方法 a. 如果没传递初始值，那么需要提供 get() 方法，因为系统要去拿属性a的初始值b. 若该条件不满足，程序直接Crash 对象提供的 属性a 的 set() 方法 对 属性a的改变 必须通过某种方法反映出来 a. 如带来ui上的变化b. 若这条不满足，动画无效，但不会Crash 上述条件，一般第二条都会满足，主要是在第一条 比如说：由于View的setWidth()并不是设置View的宽度，而是设置View的最大宽度和最小宽度的；所以通过setWidth()无法改变控件的宽度；所以对View视图的width做属性动画没有效果 具体请看下面Button按钮的例子 123456Button mButton = (Button) findViewById(R.id.Button); // 创建动画作用对象：此处以Button为例 // 此Button的宽高设置具体为具体宽度200px ObjectAnimator.ofInt(mButton, "width", 500).setDuration(5000).start(); // 设置动画的对象 运行后，会看到其宽度并不会变化 为什么没有动画效果呢？我们来看View 的 setWidth方法 1234567891011121314151617public void setWidth(int pixels) &#123; mMaxWidth = mMinWidth = pixels; mMaxWidthMode = mMinWidthMode = PIXELS; // 因为setWidth（）并不是设置View的宽度，而是设置Button的最大宽度和最小宽度的 // 所以通过setWidth（）无法改变控件的宽度 // 所以对width属性做属性动画没有效果 requestLayout(); invalidate(); &#125; @ViewDebug.ExportedProperty(category = "layout") public final int getWidth() &#123; return mRight - mLeft; // getWidth的确是获取View的宽度&#125; 上述问题解决方案针对上述对象属性的set()不是设置属性 或 根本没有set() / get()的情况应该如何处理？ 手动设置对象类属性的set() &amp; get()。共有两种方法： 通过继承原始类，直接给类加上该属性的 get()&amp; set()，从而实现给对象加上该属性的 get()&amp; set() 通过包装原始动画对象，间接给对象加上该属性的 get()&amp; set()。即 用一个类来包装原始对象 对于第一种方法，在上面的例子已经说明；下面主要学第二种方法：通过包装原始动画对象，间接给对象加上该属性的get()&amp; set() 还是采用上述 Button 按钮的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends AppCompatActivity &#123; Button mButton; ViewWrapper wrapper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.Button); // 创建动画作用对象：此处以Button为例 wrapper = new ViewWrapper(mButton); // 创建包装类,并传入动画作用的对象 mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ObjectAnimator.ofInt(wrapper, "width", 500).setDuration(3000).start(); // 设置动画的对象是包装类的对象 &#125; &#125;); &#125; // 提供ViewWrapper类,用于包装View对象 // 本例:包装Button对象 private static class ViewWrapper &#123; private View mTarget; // 构造方法:传入需要包装的对象 public ViewWrapper(View target) &#123; mTarget = target; &#125; // 为宽度设置get（） &amp; set（） public int getWidth() &#123; return mTarget.getLayoutParams().width; &#125; public void setWidth(int width) &#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125; &#125;&#125; 发现这次就得到了我们想要的效果 Demo 地址https://github.com/Commandercc/DemoEX/blob/master/AnimationDmeo3.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ValueAnimator学习]]></title>
    <url>%2F2020%2F06%2F12%2FValueAnimator%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述简介ValueAnimator 是动画机制中最核心的一个类。 原理 通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果。 具体如图下： 整型：ValueAnimator.ofInt()作用将初始值 以整数形式 过渡到结束值 （即估值器是整型估值器 - IntEvaluator） 原理 具体使用因为ValueAnimator本质只是一种值的操作机制,因此先学习一下改变一个值的过程。 操作值的方式 分为 XML 设置 / Java 代码设置 1.Java代码设置 实际开发中，建议使用Java代码实现属性动画：因为很多时候属性的起始值是无法提前确定的（无法使用XML设置），这就需要在Java代码里动态获取。 下面的代码主要看看注释就行了，后面再实战。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 步骤1：设置动画属性的初始值 &amp; 结束值 ValueAnimator anim = ValueAnimator.ofInt(0, 3); // ofInt（）作用有两个 // 1. 创建动画实例 // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和3,表示将值从0平滑过渡到3 // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推 // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值 // 关于自定义插值器后面学 // 下面看看ofInt()的源码分析 -&gt;&gt;关注1 // 步骤2：设置动画的播放各种属性 anim.setDuration(500); // 设置动画运行的时长 anim.setStartDelay(500); // 设置动画延迟播放时间 anim.setRepeatCount(0); // 设置动画重复播放次数 = 重放次数+1 // 动画播放次数 = infinite时,动画无限重复 anim.setRepeatMode(ValueAnimator.RESTART); // 设置重复播放动画模式 // ValueAnimator.RESTART(默认):正序重放 // ValueAnimator.REVERSE:倒序回放 // 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器 // 设置 值的更新监听器 // 即：值每次改变、变化一次,该方法就会被调用一次 anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int currentValue = (Integer) animation.getAnimatedValue(); // 获得改变后的值 System.out.println(currentValue); // 输出改变后的值// 步骤4：将改变后的值赋给对象的属性值，下面会详细说明 View.setproperty（currentValue）；// 步骤5：刷新视图，即重新绘制，从而实现动画效果 View.requestLayout(); &#125; &#125;); anim.start(); // 启动动画 &#125;// 关注1：ofInt（）源码分析 public static ValueAnimator ofInt(int... values) &#123; // 允许传入一个或多个Int参数 // 1. 输入一个的情况（如a）：从0过渡到a； // 2. 输入多个的情况（如a，b，c）：先从a平滑过渡到b，再从b平滑过渡到C ValueAnimator anim = new ValueAnimator(); // 创建动画对象 anim.setIntValues(values); // 将传入的值赋值给动画对象 return anim; &#125; 效果 值 从初始值 过度到 结束值 的过程如下： 2.在XML代码中设置 具备重用性，即将通用的动画写到XML里，可在各个界面中去重用它 步骤1：在路径 res/animator的文件夹里创建相应的动画 .xml文件 此处设置为 res/animator/set_animation.xml 步骤2：设置动画参数 ​ set_animation.xml 12345678910111213141516// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="0" // 初始值 android:valueTo="100" // 结束值 android:valueType="intType" // 变化值类型 ：floatType &amp; intType android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = "true" // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = "false" // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= "true" // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= "restart" // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = "0" // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面学/&gt; 步骤3：在Java代码中启用动画 12345678Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation); // 载入XML动画animator.setTarget(view); // 设置动画对象animator.start(); // 启动动画 实例 实现的动画效果：按钮的宽度从 250px 放大到 500px 1234567891011121314151617181920212223242526272829303132333435363738public class Demo_ofInt extends AppCompatActivity &#123; private Button mbutton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo_of_int); mbutton = findViewById(R.id.anim1); mbutton.getLayoutParams().width = 250; //1. 设置属性数值的初始值 和 结束值 // 结束值 = 500 ValueAnimator valueAnimator = ValueAnimator.ofInt(mbutton.getLayoutParams().width,500); //2.设置动画的各种属性 valueAnimator.setDuration(3000); //动画时长 valueAnimator.setRepeatCount(ValueAnimator.INFINITE); //重复播放 //3.将属性值手动赋值给对象的属性：此处是将 值 付给按钮的宽度 //设置更新监听器，即数值每次变化更新都会调用该方法 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int currentValue = (Integer) animation.getAnimatedValue(); System.out.println(currentValue); //每次值变化，将值手动赋值给对象的属性 mbutton.getLayoutParams().width = currentValue; //4.刷新视图，即重新绘制，从而实现动画效果 mbutton.requestLayout(); &#125; &#125;); //启动动画 valueAnimator.start(); &#125;&#125; 效果： 浮点型：ValueAnimator.ofFloat()原理 具体使用操作值的方式 分为 XML 设置 / Java 代码设置 1.java代码中设置 12ValueAnimator anim = ValueAnimator.ofFloat(0, 3); // 其他使用类似ValueAnimator.ofInt（int values），不废话 2.在xml代码中设置 123456// ValueAnimator采用&lt;animator&gt; 标签&lt;animator xmlns:android="http://schemas.android.com/apk/res/android" // 设置属性同 ofInt android:valueFrom="0" android:valueTo="100" android:valueType="intType"/&gt; 在Java代码中启动动画,也是和上面一样。直接看效果： 说明从上面可以看出，ValueAnimator.ofInt()与ValueAnimator.oFloat()仅仅只是在估值器上的区别：（即如何从初始值 过渡 到结束值） ValueAnimator.oFloat()采用默认的浮点型估值器 (FloatEvaluator) ValueAnimator.ofInt()采用默认的整型估值器（IntEvaluator） 在使用上完全没有区别，此处对ValueAnimator.oFloat()的使用就不废话了。 对象：ValueAnimator.ofObject()作用将初始值 以对象的形式 过渡到结束值。 工作原理 具体使用123456789101112// 创建初始动画时的对象 &amp; 结束动画时的对象myObject object1 = new myObject(); myObject object2 = new myObject(); ValueAnimator anim = ValueAnimator.ofObject(new myObjectEvaluator(), object1, object2); // 创建动画对象 &amp; 设置参数// 参数说明// 参数1：自定义的估值器对象（TypeEvaluator 类型参数） - 下面会学// 参数2：初始动画的对象// 参数3：结束动画的对象anim.setDuration(5000); anim.start(); 大概了解一下估值器 作用：设置动画 如何从初始值 过渡到 结束值 的逻辑 插值器（Interpolator）决定 值 的变化模式（匀速、加速blabla） 估值器（TypeEvaluator）决定 值 的具体变化数值 从上面可知： ValueAnimator.ofFloat()实现了 将初始值 以浮点型的形式 过渡到结束值 的逻辑，那么这个过渡逻辑具体是怎么样的呢？ 其实是系统内置了一个 FloatEvaluator估值器，内部实现了初始值与结束值 以浮点型的过渡逻辑 来看一下 FloatEvaluator的代码实现： 1234567891011121314151617public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; &#123; // FloatEvaluator实现了TypeEvaluator接口// 重写evaluate() public Object evaluate(float fraction, Object startValue, Object endValue) &#123; // 参数说明// fraction：表示动画完成度（根据它来计算当前动画的值）// startValue、endValue：动画的初始值和结束值 float startFloat = ((Number) startValue).floatValue(); return startFloat + fraction * (((Number) endValue).floatValue() - startFloat); // 初始值 过渡 到结束值 的算法是： // 1. 用结束值减去初始值，算出它们之间的差值 // 2. 用上述差值乘以fraction系数 // 3. 再加上初始值，就得到当前动画的值 &#125; &#125; ValueAnimator.ofInt() &amp; ValueAnimator.ofFloat()都具备系统内置的估值器，即FloatEvaluator &amp; IntEvaluator ，即系统已经默认实现了 如何从初始值 过渡到 结束值 的逻辑 但对于ValueAnimator.ofObject()，从上面的工作原理可以看出并没有系统默认实现，因为对象的动画操作复杂 &amp; 多样，系统无法知道如何从初始对象过度到结束对象 因此，对于ValueAnimator.ofObject()，我们需自定义估值器（TypeEvaluator）来告知系统如何进行从 初始对象 过渡到 结束对象的逻辑 自定义实现的逻辑如下 12345678910111213141516// 实现TypeEvaluator接口public class ObjectEvaluator implements TypeEvaluator&#123; // 复写evaluate（）// 在evaluate（）里写入对象动画过渡的逻辑 @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; // 参数说明 // fraction：表示动画完成度（根据它来计算当前动画的值） // startValue、endValue：动画的初始值和结束值 ... // 写入对象动画过渡的逻辑 return value; // 返回对象动画过渡的逻辑计算后的值 &#125; 实例实现的动画效果：一个圆从一个点 移动到 另外一个点。 1.定义一个Point类 1234567891011121314151617181920212223242526public class Point &#123; //设置两个变量 用于记录坐标的位置 private float x; private float y; public Point(float x, float y) &#123; this.x = x; this.y = y; &#125; public float getX() &#123; return x; &#125; public void setX(float x) &#123; this.x = x; &#125; public float getY() &#123; return y; &#125; public void setY(float y) &#123; this.y = y; &#125;&#125; 2.根据需求实现TypeEvaluator接口 实现TypeEvaluator接口的目的是自定义如何 从初始点坐标 过渡 到结束点坐标； 本例实现的是一个从左上角到右下角的坐标过渡逻辑。 123456789101112131415161718//实现 TypeEvaluator 接口public class PointEvaluator implements TypeEvaluator &#123; @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; //将动画初始值 和 结束值 强制类型转换成 Point 类对象 Point startPoint = (Point) startValue; Point endPoint = (Point) endValue; //根据 fraction 来计算当前动画的 x 和 y 的值 fraction表示动画完成度 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX()); float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY()); //将计算后的坐标封装到一个新的 Point 对象中并返回 Point point = new Point(x,y); return point; &#125;&#125; 3.将属性动画作用到自定义View当中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MyView extends View &#123; //设置需要用到的变量 public static final float RADIUS = 100f; //半径 private Point currentPoint; //当前坐标 private Paint mPaint; //绘图画笔 public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); //初始化画笔 mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //如果当前坐标为空（即第一次） if (currentPoint == null) &#123; //创建一个点对象(100,100) currentPoint = new Point(RADIUS, RADIUS); //在该点画一个圆 float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, RADIUS, mPaint); //将属性动画作用到View中 //1. 创建初始动画的对象点 和 动画结束时的对象点 Point startPoint = new Point(RADIUS, RADIUS); //初始（100,100） Point endPoint = new Point(700, 1000); //结束点（700,1000) //2.创建动画对象 设置初始值 和结束值 ValueAnimator animator = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint); // 参数说明 // 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口) // 参数2：初始动画的对象点 // 参数3：结束动画的对象点 //3. 设置动画参数 animator.setDuration(5000); animator.setRepeatCount(ValueAnimator.INFINITE); //4.通过 值 的更新监听器，将改变的对象手动赋值给当前对象 // 此处是将 改变后的坐标值对象 赋给 当前的坐标值对象 // 设置值的更新监听器，即每当坐标值更新一次，该方法就会被调用一次 animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获取当前坐标值 currentPoint = (Point) animation.getAnimatedValue(); // 重新绘制 // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次 // 所以坐标值每改变一次,就会调用onDraw()一次 invalidate(); &#125; &#125;); animator.start(); &#125; else &#123; //如果坐标值不为空 则画圆 //所以坐标值每改变一次 就会调用onDraw() 一次，就会画一次圆，从而实现动画效果 //在该点画一个圆 float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x,y,RADIUS,mPaint); &#125; &#125;&#125; 4.布局中引入MyView activity_demo_of_object.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="20dp" tools:context=".Demo_ofObject"&gt; &lt;com.ccc.animationdmeo3.objectDemo.MyView android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; 5.在页面中加载 12345678public class Demo_ofObject extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo_of_object); &#125;&#125; 6.效果 说明从上面可以看出，其实ValueAnimator.ofObject()的本质还是操作 值，只是是采用将 多个值 封装到一个对象里的方式 同时对多个值一起操作而已。 就像上面的例子，本质还是操作坐标中的x，y两个值，只是将其封装到Point对象里，方便同时操作x，y两个值而已 Demo 地址https://github.com/Commandercc/DemoEX/blob/master/AnimationDmeo3.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性动画学习]]></title>
    <url>%2F2020%2F06%2F12%2F%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[为什么要引入属性动画作用对象局限：View即补间动画 只能够作用在视图View上，即只可以对一个Button、TextView、甚至是LinearLayout、或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作 有些情况下的动画效果只是视图的某个属性 &amp; 对象而不是整个视图； 如，现需要实现视图的颜色动态变化，那么就需要操作视图的颜色属性从而实现动画效果，而不是针对整个视图进行动画操作 没有改变View的属性，只是改变视觉效果 补间动画只是改变了View的视觉效果，而不会真正去改变View的属性。 如，将屏幕左上角的按钮 通过补间动画 移动到屏幕的右下角 点击当前按钮位置（屏幕右下角）是没有效果的，因为实际上按钮还是停留在屏幕左上角，补间动画只是将这个按钮绘制到屏幕右下角，改变了视觉效果而已。 动画效果单一 补间动画只能实现平移、旋转、缩放 &amp; 透明度这些简单的动画需求 一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现。 即在功能和可扩展性有较大的的局限性 简述简介 作用对象：任意 Java 对象 实现效果：可自定义各种动画效果 特点 作用对象进行了扩展：不只是View对象，甚至没对象也可以 动画效果：不只是4种基本变换，还有其他动画效果 作用领域：API11后引入的 原理 从上述工作原理可以看出属性动画有两个非常重要的类：ValueAnimator 类 &amp; ObjectAnimator 类 属性动画的使用基本都是依靠这两个类。 使用对于属性动画的使用，主要是： 两个使用方法类：ValueAnimator 类 &amp; ObjectAnimator 类 两个辅助使用类：插值器 &amp; 估值器 ValueAnimator 类 定义：属性动画机制中 最核心的一个类 实现动画的原理：通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果。如图下： 从上面原理可以看出：ValueAnimator类中有3个重要方法： ValueAnimator.ofInt（int values） ValueAnimator.ofFloat（float values） ValueAnimator.ofObject（int values） 后面再详细学习。 ObjectAnimator 类直接对对象的属性值进行改变操作，从而实现动画效果 如直接改变 View的 alpha 属性 从而实现透明度的动画效果 继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类 本质原理： 通过不断控制 值 的变化，再不断 自动 赋给对象的属性，从而实现动画效果。如下图： ObjectAnimator 的详细内容后面学。 两个类的区别从上面的工作原理可以看出：ObjectAnimator与 ValueAnimator类的区别： ValueAnimator 类是先改变值，然后 手动赋值 给对象的属性从而实现动画；是 间接 对对象属性进行操作； ObjectAnimator 类是先改变值，然后 自动赋值 给对象的属性从而实现动画；是 直接 对对象属性进行操作； 可以理解为：ObjectAnimator更加智能、自动化程度更高。 插值器 具体后面学。 估值器具体后面学。 插值器与估值器区别]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逐帧动画学习]]></title>
    <url>%2F2020%2F06%2F12%2F%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[作用对象作用于视图控件（View） 如Android的TextView、Button等 不可作用于View组件的属性，如颜色、背景、长度等 原理 将动画拆分为 帧 的形式，且定义 每一帧 = 一张图片 本质：按序播放一组预先定义好的图片 具体使用步骤1：将动画资源（即每张图片资源）放到 drawable文件夹里 这里可以将自己需要的GIF动画，利用GIF分解软件（如GifSplitter）将 GIF分解成一张张图片即可 步骤2：设置 和 启动动画设置 &amp; 启动 逐帧动画有两种方式：XML / Java代码。 方式一：XML实现 1.在 res/drawable的文件夹里创建动画效果.xml文件 此处路径为res/drawable/frame_anim.xml 2.设置动画资源（也就是准备的图片资源） 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true" // 设置是否只播放一次，默认为false &gt;// item = 动画图片资源；duration = 设置一帧持续时间(ms) &lt;item android:drawable="@drawable/test_001" android:duration="1000"/&gt; &lt;item android:drawable="@drawable/test_002" android:duration="1000"/&gt; &lt;item android:drawable="@drawable/test_003" android:duration="1000"/&gt; &lt;item android:drawable="@drawable/test_004" android:duration="1000"/&gt; &lt;item android:drawable="@drawable/test_005" android:duration="1000"/&gt; &lt;item android:drawable="@drawable/test_006" android:duration="1000"/&gt;&lt;/animation-list&gt; 3.在java代码中载入和启动动画 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private Button startFrame,stopFrame; private ImageView iv; private AnimationDrawable animationDrawable; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startFrame = findViewById(R.id.startFrame); stopFrame = findViewById(R.id.stopFrame); iv = findViewById(R.id.iv); //设置动画 iv.setImageResource(R.drawable.frame_anim); //获取动画对象 animationDrawable = (AnimationDrawable) iv.getDrawable(); //开始动画 startFrame.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //启动动画 animationDrawable.start(); &#125; &#125;); //停止动画 stopFrame.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; animationDrawable.stop(); &#125; &#125;); &#125;&#125; 方式二：在java代码中实现1234567891011121314151617181920212223242526//获取动画对象 animationDrawable = (AnimationDrawable) iv.getDrawable(); for (int i = 1; i &lt;= 6; i++) &#123; int id = getResources().getIdentifier("test_00"+i,"drawable",getPackageName()); Drawable drawable = getResources().getDrawable(id); animationDrawable.addFrame(drawable,1000); &#125; //开始动画 startFrame.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //启动动画 animationDrawable.start(); &#125; &#125;); //停止动画 stopFrame.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; animationDrawable.stop(); &#125; &#125;); &#125; 说明使用时一定要避免使用尺寸较大的图片，否则会引起OOM。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补间动画学习]]></title>
    <url>%2F2020%2F06%2F11%2F%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述动画的基本内容在前面学过了，现在主要学一下具体用法。 使用方法核心类不同类型的动画对应于不同的子类，具体如下： 设置方法补间动画的使用方式分为两种：在XML 代码 / Java 代码里设置 前者优点：动画描述的可读性更好 后者优点：动画效果可动态创建 平移平移对应的核心类是： TranslateAnimation 类 XML的设置方式步骤1：在 res/anim的文件夹里创建动画效果.xml文件 步骤2：根据 不同动画效果的语法 设置 不同动画参数，从而实现动画效果。平移动画效果设置具体如下： view_animation.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用&lt;translate /&gt; 标签表示平移动画&lt;translate xmlns:android="http://schemas.android.com/apk/res/android" // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = "true" // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = "false" // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= "true" // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= "restart" // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = "0" // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = "@android:anim/linear_interpolator" // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是平移动画特有的属性 android:fromXDelta="0" // 视图在水平方向x 移动的起始值 android:toXDelta="500" // 视图在水平方向x 移动的结束值 android:fromYDelta="0" // 视图在竖直方向y 移动的起始值 android:toYDelta="500" // 视图在竖直方向y 移动的结束值 /&gt; 步骤3： 在java代码中创建Animation对象并播放动画 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; private Button anim; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //1.创建需要设置动画的视图 View anim = findViewById(R.id.btn); //2.创建动画对象 并传入设置的动画效果xml文件 Animation translateAnimation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.view_animation); //3.播放动画 anim.startAnimation(translateAnimation); &#125;&#125; 效果： Java设置方式12345678910111213141516Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation translateAnimation = new TranslateAnimation(0，500，0，500);// 步骤2：创建平移动画的对象：平移动画对应的Animation子类为TranslateAnimation// 参数分别是：// 1. fromXDelta ：视图在水平方向x 移动的起始值// 2. toXDelta ：视图在水平方向x 移动的结束值// 3. fromYDelta ：视图在竖直方向y 移动的起始值// 4. toYDelta：视图在竖直方向y 移动的结束值translateAnimation.setDuration(3000);// 固定属性的设置都是在其属性前加“set”，如setDuration（）mButton.startAnimation(translateAnimation);// 步骤3:播放动画 缩放缩放对应的核心类是：ScaleAnimation 类。 XML设置方式步骤1： 在res/anim的文件夹里创建动画效果 .xml 文件 步骤2：根据 不同动画效果的语法 设置 不同动画参数，从而实现动画效果。缩放动画效果设置具体如下： anim_scale.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用&lt;scale/&gt; 标签表示是缩放动画&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration = "3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = "true" // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = "false" // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= "true" // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= "restart" // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = "0" // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = "@android:anim/linear_interpolator" // 插值器，即影响动画的播放速度,后面学 // 以下参数是缩放动画特有的属性 android:fromXScale = "0.0" // 动画在水平方向X的起始缩放倍数 // 0.0表示收缩到没有；1.0表示正常无伸缩 // 值小于1.0表示收缩；值大于1.0表示放大 android:toXScale = "2" //动画在水平方向X的结束缩放倍数 android:fromYScale = "0.0" //动画开始前在竖直方向Y的起始缩放倍数 android:toYScale = "2" //动画在竖直方向Y的结束缩放倍数 android:pivotX = "50%" // 缩放轴点的x坐标 android:pivotY = "50%" // 缩放轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应 模式参数 是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应 模式参数 是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应 模式参数 是Animation.RELATIVE_TO_PARENT // 两个50%表示动画从自身中间开始，具体如下图 /&gt; 步骤3：在Java代码中创建Animation对象并播放动画 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private Button anim; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //1.创建需要设置动画的视图 View anim = findViewById(R.id.btn); //2.创建动画对象 并传入设置的动画效果xml文件 Animation translateAnimation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.anim_scale); //3.播放动画 anim.startAnimation(translateAnimation); &#125;&#125; 效果 下面展示轴点为（50%,50%） &amp; 轴点为（20%,30%）的情况 轴点为（50%,50%） 轴点为（20%,30%） java设置方式123456789101112131415161718192021222324Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation rotateAnimation = new ScaleAnimation(0,2,0,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);// 步骤2：创建缩放动画的对象 &amp; 设置动画效果：缩放动画对应的Animation子类为RotateAnimation// 参数说明:// 1. fromX ：动画在水平方向X的结束缩放倍数// 2. toX ：动画在水平方向X的结束缩放倍数// 3. fromY ：动画开始前在竖直方向Y的起始缩放倍数// 4. toY：动画在竖直方向Y的结束缩放倍数// 5. pivotXType:缩放轴点的x坐标的模式// 6. pivotXValue:缩放轴点x坐标的相对值// 7. pivotYType:缩放轴点的y坐标的模式// 8. pivotYValue:缩放轴点y坐标的相对值// pivotXType = Animation.ABSOLUTE:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)// pivotXType = Animation.RELATIVE_TO_SELF:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)// pivotXType = Animation.RELATIVE_TO_PARENT:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)scaleAnimation.setDuration(3000);// 固定属性的设置都是在其属性前加“set”，如setDuration（）mButton.startAnimation(scaleAnimation);// 步骤3：播放动画 旋转对应的核心类是：RotateAnimation类。 XML 设置方式步骤1：在路径 res/anim 的文件夹里创建动画效果 .xml 文件 步骤2：根据 不同动画效果的语法 设置 不同动画参数，从而实现动画效果。旋转动画效果设置具体如下： anim_rotate.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用&lt;rotate/&gt; 标签表示是旋转动画&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = "true" // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = "false" // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= "true" // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= "restart" // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = "0" // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = "@android:anim/linear_interpolator" // 插值器，即影响动画的播放速度,后面学 // 以下参数是旋转动画特有的属性 android:fromDegrees="0" // 动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:toDegrees="270" // 动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针) android:pivotX="50%" // 旋转轴点的x坐标 android:pivotY="0" // 旋转轴点的y坐标 // 轴点 = 视图缩放的中心点 // pivotX pivotY,可取值为数字，百分比，或者百分比p // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。 // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT // 示意图和上面一样 /&gt; 步骤3：在Java代码中创建Animation对象并播放动画 123456//1.创建需要设置动画的视图 Viewanim = findViewById(R.id.btn);//2.创建动画对象 并传入设置的动画效果xml文件Animation translateAnimation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.view_rotate);//3.播放动画anim.startAnimation(translateAnimation); 效果 java设置方式12345678910111213141516171819202122Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation rotateAnimation = new RotateAnimation(0,270,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);// 步骤2：创建旋转动画的对象 &amp; 设置动画效果：旋转动画对应的Animation子类为RotateAnimation// 参数说明:// 1. fromDegrees ：动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)// 2. toDegrees ：动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)// 3. pivotXType：旋转轴点的x坐标的模式// 4. pivotXValue：旋转轴点x坐标的相对值// 5. pivotYType：旋转轴点的y坐标的模式// 6. pivotYValue：旋转轴点y坐标的相对值// pivotXType = Animation.ABSOLUTE:旋转轴点的x坐标 = View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)// pivotXType = Animation.RELATIVE_TO_SELF:旋转轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)// pivotXType = Animation.RELATIVE_TO_PARENT:旋转轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)rotateAnimation.setDuration(3000);// 固定属性的设置都是在其属性前加“set”，如setDuration（）mButton.startAnimation(rotateAnimation);// 步骤3：播放动画 透明度动画对应的核心类是：AlphaAnimation类。 XML设置方式步骤1：在路径 res/anim的文件夹里创建动画效果 .xml 文件 步骤2：根据 不同动画效果的语法 设置 不同动画参数，从而实现动画效果。旋转动画效果设置具体如下： anim_alpha.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用&lt;alpha/&gt; 标签表示是透明度动画&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" // 以下参数是4种动画效果的公共属性,即都有的属性 android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = "true" // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = "false" // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= "true" // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= "restart" // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = "0" // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = "@android:anim/linear_interpolator" // 插值器，即影响动画的播放速度,下面会详细讲 // 以下参数是透明度动画特有的属性 android:fromAlpha="1.0" // 动画开始时视图的透明度(取值范围: -1 ~ 1) android:toAlpha="0.0"// 动画结束时视图的透明度(取值范围: -1 ~ 1) /&gt; 步骤3：在Java代码中创建Animation对象并播放动画 123456//1.创建需要设置动画的视图 Viewanim = findViewById(R.id.btn);//2.创建动画对象 并传入设置的动画效果xml文件Animation translateAnimation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.view_alpha);//3.播放动画anim.startAnimation(translateAnimation); 效果 Java设置方式1234567891011121314Button mButton = (Button) findViewById(R.id.Button);// 步骤1:创建 需要设置动画的 视图ViewAnimation alphaAnimation = new AlphaAnimation(1,0);// 步骤2：创建透明度动画的对象 &amp; 设置动画效果：透明度动画对应的Animation子类为AlphaAnimation// 参数说明:// 1. fromAlpha:动画开始时视图的透明度(取值范围: -1 ~ 1)// 2. toAlpha:动画结束时视图的透明度(取值范围: -1 ~ 1)alphaAnimation.setDuration(3000);// 固定属性的设置都是在其属性前加“set”，如setDuration（）mButton.startAnimation(alphaAnimation);// 步骤3：播放动画 Activity 的切换效果即 Activity 启动 / 退出时的动画效果，主要包括淡入淡出、左滑右滑等。 系统预设的效果本身系统已经封装好了淡入淡出、左滑右滑的效果，来简单学习一下： 步骤1: 启动动画 123456789101112Intent intent = new Intent (this,Acvtivity.class);startActivity(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);// 采用overridePendingTransition（int enterAnim, int exitAnim）进行设置// enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源ID// exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id// 特别注意// overridePendingTransition（）必须要在startActivity(intent)后被调用才能生效 步骤2：退出动画 123456789101112131415@Overridepublic void finish()&#123; super.finish(); overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim); // 采用overridePendingTransition（int enterAnim, int exitAnim）进行设置 // enterAnim：从Activity a跳转到Activity b，进入b时的动画效果资源ID // exitAnim：从Activity a跳转到Activity b，离开a时的动画效果资源Id// 特别注意// overridePendingTransition（）必须要在finish()后被调用才能生效&#125; 系统预置参数 对于参数 enterAnim &amp; exitAnim 的资源ID，系统有自带的效果android.R.anim.xxx，如下设置： 123456Intent intent = new Intent(MainActivity.this, SecActivity.class);startActivity(intent); // 淡入淡出的动画效果 overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);// 从左向右滑动的效果overridePendingTransition(android.R.anim.slide_in_left, android.R.anim.slide_out_right); 看一下效果： 淡入淡出 左右滑动 自定义Activity切换效果 利用补间动画来实现自定义Activity的切换效果 淡入淡出淡入淡出 效果是采用透明度动画（Alpha）。 fade_in.xml（淡入） 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;alpha android:duration="1500" android:fromAlpha="0.0" android:toAlpha="1.0"/&gt;&lt;/set&gt; fade_out.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;alpha android:duration="1500" android:fromAlpha="1.0" android:toAlpha="0.0"/&gt;&lt;/set&gt; 结构如下 在java代码中设置 12345678btn_jump.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this,SecondActivity.class); startActivity(intent); overridePendingTransition(R.anim.fade_in,R.anim.fade_out); //引用自己刚才创建的xml文件 &#125;&#125;); 左右滑动 左右滑动 效果是采用平移动画（Translate） 先看一下Activity的位置信息： 上图中很明显 第一张图中 Activity A 在屏幕左侧（相当于向左将A滑走），此时A的x轴位置即为负数； 中间这张图中 Activity A 正是当前屏幕显示的页面，此时A的x轴位置为0； 第三张图中 Activity A 在屏幕右侧（相当于向右将A滑走），此时A的x轴位置是一个正数** 下面自定义一个动画效果：从右滑到左 out_to_left.xml 先从中间滑到左边，即从上图的 位置2 —-&gt; 位置1 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="500" android:fromXDelta="0%p" android:toXDelta="-100%p" /&gt;&lt;/set&gt; in_from_right.xml 从右边滑到中间，即从位置3 - 位置2 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="500" android:fromXDelta="100%p" android:toXDelta="0%p" /&gt;&lt;/set&gt; 在java代码中设置效果 123Intent intent = new Intent(MainActivity.this,SecondActivity.class);startActivity(intent);overridePendingTransition(R.anim.in_from_right,R.anim.out_to_left); 效果 简单说明一下百分比p和百分比，上面已经提到过了，这里再看一下 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT 说明上面只是学习了一下简单的切换效果，一些炫酷的切换动画后面用到再学。 Fragment的切换效果类似于Activity，Fragment本身系统存在自带的动画切换效果 系统预设1234567891011FragmentTransaction fragmentTransaction = mFragmentManager .beginTransaction();fragmentTransaction.setTransition(int transit)；// 通过setTransition(int transit)进行设置// transit参数说明// 1. FragmentTransaction.TRANSIT_NONE：无动画// 2. FragmentTransaction.TRANSIT_FRAGMENT_OPEN：标准的打开动画效果// 3. FragmentTransaction.TRANSIT_FRAGMENT_CLOSE：标准的关闭动画效果// 标准动画设置好后，在Fragment添加和移除的时候都会有。 自定义Fragment切换效果12345678910// 采用`FragmentTransavtion`的 setCustomAnimations（）进行设置FragmentTransaction fragmentTransaction = mFragmentManager .beginTransaction();fragmentTransaction.setCustomAnimations( R.anim.in_from_right, R.anim.out_to_left);// 此处的自定义动画效果同Activity，此处不再过多描述 视图组（ViewGroup）中子元素的出场效果 视图组（ViewGroup）中子元素可以具备出场时的补间动画效果 常用需求场景：为ListView的 item 设置出场动画 使用步骤如下： 步骤1：设置子元素的出场动画 view_animation.xml &lt;set&gt;标签是组合动画，下面再学。 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="3000"&gt; &lt;alpha android:duration="1500" android:fromAlpha="1.0" android:toAlpha="0.0"/&gt; &lt;translate android:fromXDelta="500" android:toXDelta="0"/&gt;&lt;/set&gt; 步骤2：设置 视图组（ViewGroup）的动画文件 使用 layoutAnimation，并用 android:animation=”@anim/view_animation” 来指定要引用的动画 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用LayoutAnimation标签&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="0.5" // 子元素开始动画的时间延迟 // 如子元素入场动画的时间总长设置为300ms // 那么 delay = "0.5" 表示每个子元素都会延迟150ms才会播放动画效果 // 第一个子元素延迟150ms播放入场效果；第二个延迟300ms，以此类推 android:animationOrder="normal" // 表示子元素动画的顺序 // 可设置属性为： // 1. normal ：顺序显示，即排在前面的子元素先播放入场动画 // 2. reverse：倒序显示，即排在后面的子元素先播放入场动画 // 3. random：随机播放入场动画 android:animation="@anim/view_animation" // 设置入场的具体动画效果 // 将步骤1的子元素出场动画设置到这里 /&gt; 步骤3：为视图组（ViewGroup）指定andorid:layoutAnimation属性 指定的方式有两种： XML / Java代码设置 方式1：在XML中指定 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#FFFFFF" android:orientation="vertical" &gt; &lt;ListView android:id="@+id/listView1" android:layoutAnimation="@anim/anim_layout" // 指定layoutAnimation属性用以指定子元素的入场动画 android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 方式2：在Java代码中指定 这样就不用额外设置res/ anim /anim_layout.xml该xml文件了 123456789101112ListView lv = (ListView) findViewById(R.id.listView1);Animation animation = AnimationUtils.loadAnimation(this,R.anim.view_animation);// 加载子元素的出场动画 直接引用我们的 view_animation.xml文件 不需要在额外设置一个layoutAnimation文件LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_NORMAL);// 设置LayoutAnimation的属性lv.setLayoutAnimation(controller);// 为ListView设置LayoutAnimation的属性 效果： 高级用法除了上述使用，还有一些额外的高级用法： 组合动画 监听动画 插值器 估值器 组合动画 上面讲的都是单个动画效果；而实际中很多需求都需要同时使用平移、缩放、旋转 &amp; 透明度4种动画，即组合动画 使用组合动画需要用到标签 &lt; set/&gt; set对于Animation，就类似 View对于ViewGroup 组合动画同样有XML 代码 / Java 代码两种设置方法 方式1：XML设置步骤1：在路径 res/anim 的文件夹里创建动画效果 .xml 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="utf-8"?&gt;// 采用&lt; Set/&gt;标签&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;// 组合动画同样具备公共属性 android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果 android:startOffset ="1000" // 动画延迟开始时间（ms） android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart| android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复 android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲 // 组合动画独特的属性 android:shareinterpolator = “true” // 表示组合动画中的动画是否和集合共享同一个差值器 // 如果集合不指定插值器，那么子动画需要单独设置// 组合动画播放时是全部动画同时开始// 如果想不同动画不同时间开始就要使用android:startOffset属性来延迟单个动画播放时间// 设置旋转动画，语法同单个动画 &lt;rotate android:duration="1000" android:fromDegrees="0" android:toDegrees="360" android:pivotX="50%" android:pivotY="50%" android:repeatMode="restart" android:repeatCount="infinite" /&gt;// 设置平移动画，语法同单个动画 &lt;translate android:duration="10000" android:startOffset = “1000”// 延迟该动画播放时间 android:fromXDelta="0%p" android:fromYDelta="0" android:toXDelta="50%p" android:toYDelta="0" /&gt;// 设置透明度动画，语法同单个动画 &lt;alpha android:startOffset="7000" android:duration="3000" android:fromAlpha="1.0" android:toAlpha="0.0" /&gt;// 设置缩放动画，语法同单个动画 &lt;scale android:startOffset="4000" android:duration="1000" android:fromXScale="1.0" android:fromYScale="1.0" android:pivotX="50%" android:pivotY="50%" android:toXScale="0.5" android:toYScale="0.5" /&gt;// 特别注意：// 1. 在组合动画里scale缩放动画设置的repeatCount（重复播放）和fillBefore（播放完后，视图是否会停留在动画开始的状态）是无效的。// 2. 所以如果需要重复播放或者回到原位的话需要在set标签里设置// 3. 但是由于此处rotate旋转动画里已设置repeatCount为infinite，所以动画不会结束，也就看不到重播和回复原位&lt;/set&gt; 上面的是注释讲解 ，下面看一个我自己的实例 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration = "3000" android:startOffset = "1000" android:fillBefore = "true" android:fillAfter = "false" android:fillEnabled = "true" android:repeatMode = "restart" android:repeatCount = "infinite" android:interpolator = "@android:anim/linear_interpolator" android:shareInterpolator="true"&gt; &lt;rotate android:duration="1000" android:fromDegrees="0" android:toDegrees="360" android:pivotX="50%" android:pivotY="50%" android:repeatMode="restart" android:repeatCount="infinite" /&gt; &lt;translate android:duration="1000" android:startOffset = "0" android:fromXDelta="0%p" android:fromYDelta="0" android:toXDelta="100%p" android:toYDelta="0" android:repeatCount="infinite"/&gt;&lt;/set&gt; 根据上面的注释可以理解这个实例，该组合动画有两部分，一个旋转动画，一个平移动画。因为设置了平移动画的android:startOffset = &quot;0&quot; ,即不延时，所以旋转和平移动画会一起进行，两个都设置了android:repeatCount=&quot;infinite&quot;,所以会重复播放。 步骤2：在java代码中创建 Animation 对象并播放动画 123456//1.创建需要设置动画的视图 Viewanim = findViewById(R.id.btn);//2.创建动画对象 并传入设置的动画效果xml文件Animation translateAnimation = AnimationUtils.loadAnimation(MainActivity.this,R.anim.anim_set);//3.播放动画anim.startAnimation(translateAnimation); 效果如下： 方式2：java设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Button mButton = (Button) findViewById(R.id.Button);// 创建 需要设置动画的 视图View// 组合动画设置AnimationSet setAnimation = new AnimationSet(true);// 步骤1:创建组合动画对象(设置为true)// 步骤2:设置组合动画的属性// 特别说明以下情况// 因为在下面的旋转动画设置了无限循环(RepeatCount = INFINITE)// 所以动画不会结束，而是无限循环// 所以组合动画的下面两行设置是无效的setAnimation.setRepeatMode(Animation.RESTART);setAnimation.setRepeatCount(1);// 设置了循环一次,但无效// 步骤3:逐个创建子动画(方式同单个动画创建方式,此处不作过多描述)// 子动画1:旋转动画Animation rotate = new RotateAnimation(0,360,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);rotate.setDuration(1000);rotate.setRepeatMode(Animation.RESTART);rotate.setRepeatCount(Animation.INFINITE);// 子动画2:平移动画Animation translate = new TranslateAnimation(TranslateAnimation.RELATIVE_TO_PARENT,-0.5f,TranslateAnimation.RELATIVE_TO_PARENT,0.5f,TranslateAnimation.RELATIVE_TO_SELF,0,TranslateAnimation.RELATIVE_TO_SELF,0);translate.setDuration(10000);// 子动画3:透明度动画Animation alpha = new AlphaAnimation(1,0);alpha.setDuration(3000);alpha.setStartOffset(7000);// 子动画4:缩放动画Animation scale1 = new ScaleAnimation(1,0.5f,1,0.5f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);scale1.setDuration(1000);scale1.setStartOffset(4000);// 步骤4:将创建的子动画添加到组合动画里setAnimation.addAnimation(alpha);setAnimation.addAnimation(rotate);setAnimation.addAnimation(translate);setAnimation.addAnimation(scale1);mButton.startAnimation(setAnimation);// 步骤5:播放动画 监听动画 Animation类通过监听动画开始 / 结束 / 重复时刻来进行一系列操作，如跳转页面等等 通过在 Java 代码里setAnimationListener()方法设置 12345678910111213141516Animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; // 动画开始时回调 &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 动画结束时回调 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; //动画重复执行的时候回调 &#125; &#125;); 其他插值器 和 估值器 后面慢慢学。 Demo 地址https://github.com/Commandercc/DemoEX/blob/master/AnimationDemo1.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画基础学习]]></title>
    <url>%2F2020%2F06%2F10%2FAndroid%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述以前零零散散的学过一些，现在系统学习一下Android动画方面的知识。 参考大神博客： https://www.jianshu.com/p/35d25cc205e7 动画分类Android动画主要分为分为两大类（共三种）： 视图动画：补间动画、逐帧动画 属性动画 补间动画 (Tween Animation)简述 类型根据不同的动画效果，补间动画分为4种动画： 平移动画（Translate） 缩放动画（scale） 旋转动画（rotate） 透明度动画（alpha） 效果分别如下： 平移 缩放 旋转 透明度 应用场景a. 标准的动画效果 补间动画常用于视图View的一些标准动画效果：平移、旋转、缩放 &amp; 透明度； 除了常规的动画使用，补间动画还有一些特殊的应用场景。 b. 特殊的应用场景 Activity 的切换效果（淡入淡出、左右滑动等） Fragement 的切换效果（淡入淡出、左右滑动等） 视图组（ViewGroup）中子元素的出场效果（淡入淡出、左右滑动等） 效果如下： 淡入淡出 左右滑动 出场动画 逐帧动画 (Frame Animation)简述 应用场景较为复杂的个性化动画效果。使用时一定要避免使用尺寸较大的图片，否则会引起OOM。 合成的动画 将动画拆分成帧 属性动画 (Property Animation)简述 Android 3.0 （API 11）后才提供的一种全新动画模式 应用场景与属性相关、更加复杂的动画效果。 如下图展示了改变对象颜色属性动画效果：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的搜索框demo]]></title>
    <url>%2F2020%2F06%2F10%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A1%86demo%2F</url>
    <content type="text"><![CDATA[概述大致实现如下效果 Demo说明项目结构如下： 简单描述一下各个文件： bCallBack 和 ICallBack 是两个回调接口，用于自己拓展功能； EditTextClear是一个自定义的EditText; SearchListView是一个自定义的ListView; RecordSQLiteOpenHelper是数据库辅助类； SearchView即为我们自定义的搜索框View Demo 地址注释很详细，日后方便回来看看。 https://github.com/Commandercc/DemoEX/blob/master/SearchViewDemo.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义属性TypedArray学习]]></title>
    <url>%2F2020%2F06%2F09%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7TypedArray%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述​ 有时候android传统的页面布局不足以满足我们的需求，常常需要自己定义view，通常继承View，然后重写构造方法以及onDraw等函数，再具体实现自己定义的复杂view。我们知道在给控件赋属性时，通常使用的是android系统自带的属性，比如 android:layout_height=”wrap_content”，除此之外，我们亦可以自己定义属性，这样在使用的时候我们就可以使用形如 myapp:myTextSize=”20sp” 的方式了 使用在项目文件res/value下面创建一个attr.xml文件，该文件中包含若干个attr集合 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;declare-styleable name="MyView"&gt; &lt;attr name="myTextSize" format="dimension"/&gt; &lt;attr name="myColor" format="color"/&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 其中resource是根标签，可以在里面定义若干个declare-styleable。&lt;declare-styleable name=&quot;MyView&quot;&gt;中 name（最好与自定义view的名字相同） 定义了变量的名称，下面可以再自定义多个属性，针对&lt;attr name=&quot;myTextSize&quot; format=&quot;dimension&quot;/&gt;来说，其属性的名称为”myTextSize”，format指定了该属性类型为dimension，只能表示字体的大小。 format 可以指定的类型： reference 表示引用，参考某一资源ID string 表示字符串 color 表示颜色值 dimension 表示尺寸值 boolean 表示布尔值 integer 表示整型值 float 表示浮点值 fraction 表示百分数 enum 表示枚举值 flag 表示位运算 在XML中的使用12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;com.ccc.typedarraydemo.MyView android:layout_width="wrap_content" android:layout_height="wrap_content" app:myTextSize="50sp" app:myColor="@color/colorAccent"/&gt;&lt;/LinearLayout&gt; 注意看 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; , 添加了这句，相当于自定义了一个命名空间，这里为 app ,我们就可以直接使用 app:自定义属性 的格式来引用。 实际上也可以这么写： xmlns:app=”http://schemas.android.com/apk/res/完整的包名”, 在res/后面填写包名即可。但是，在Android Studio2.0后，是不推荐这么写的，所以还是用第一种的命名方法。 在在自定义view的代码中引入自定义属性 context 通过调用 obtainStyledAttributes 方法来获取一个 TypeArray ，然后由该TypeArray来对属性进行设置 obtainStyledAttributes 方法有三个，我们最常用的是有一个参数的 obtainStyledAttributes(int[] attrs)，其参数直接 styleable 中获得 TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.MyView);调用结束后务必调用 recycle() 方法，否则这次的设定会对下次的使用造成影响 1234567891011121314151617181920212223242526272829303132333435public class MyView extends View &#123; private Paint paint; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); paint = new Paint(); // R.styleable.MyView MyView 就是我们刚才在attrs文件中定义的 declare-styleable 属性的 name TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyView); // 属性的格式 MyView_myColor 即declare-styleable 属性的 name 和 自定义属性名之间用 -（横杠）连接 int textColor = typedArray.getColor(R.styleable.MyView_myColor, Color.BLUE); float textSize = typedArray.getDimension(R.styleable.MyView_myTextSize, 35); paint.setTextSize(textSize); paint.setColor(textColor); typedArray.recycle(); &#125; public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); paint.setStyle(Paint.Style.FILL); canvas.drawText("hello world!", 200, 200, paint); &#125;&#125; 效果 Demo 地址https://github.com/Commandercc/DemoEX/blob/master/TypedArrayDemo.zip?raw=true]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPool学习]]></title>
    <url>%2F2020%2F06%2F06%2FThreadPool%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述重新学习一下线程池 参考文章: https://www.jianshu.com/p/0e4a5e70bf0e 简介 工作原理核心参数线程池中有6个核心参数，如下： 上述6个参数的配置 决定了 线程池的功能，具体设置时机 —-&gt; 创建 线程池类对象时 传入 ThreadPoolExecutor类 = 线程池的真正实现类 开发者可根据不同需求 配置核心参数，从而实现自定义线程池 123456789101112131415161718// 创建线程池对象如下// 通过 构造方法 配置核心参数 Executor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory );// 构造函数源码分析 public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable workQueue&gt;, ThreadFactory threadFactory ) 同时，Java 里已内置4种常用的线程池（即 已经配置好核心参数），下面慢慢学。 工作逻辑 使用流程如下： 12345678910111213141516171819202122232425262728293031// 1. 创建线程池 // 创建时，通过配置线程池的参数，从而实现自己所需的线程池 Executor threadPool = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory ); // 注：在Java中，已内置4种常见线程池，下面会详细说明// 2. 向线程池提交任务：execute（） // 说明：传入 Runnable对象 threadPool.execute(new Runnable() &#123; @Override public void run() &#123; ... // 线程执行任务 &#125; &#125;);// 3. 关闭线程池shutdown() threadPool.shutdown(); // 关闭线程的原理 // a. 遍历线程池中的所有工作线程 // b. 逐个调用线程的interrupt（）中断线程（注：无法响应中断的任务可能永远无法终止） // 也可调用shutdownNow（）关闭线程：threadPool.shutdownNow（） // 二者区别：看下面 // 使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（） shutdown() 线程池的状态则立刻变成SHUTDOWN状态 不能接受新的submit（即不能再往线程池内添加任何任务，否则将抛出异常） 并没有任何的interrupt操作，会等待线程池中所有线程（执行中的以及排队的）执行完毕 可以理解为是个标识性质的方法，标识这程序有意愿在此刻终止线程池的后续操作。 shutdownNow() 线程池的状态立刻变成STOP状态 会尝试interrupt线程池中正在执行的线程 等待执行的线程也会被取消 但是并不能保证一定能成功的interrupt线程池中的线程。（因为它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。） 会返回并未终止的线程列表List shutdownNow()方法比shutdown()强硬了很多，不仅取消了排队的线程而且确实尝试终止当前正在执行的线程。 常见的4类功能线程池根据参数的不同配置，Java中最常见的线程池有4类： 定长线程池（FixedThreadPool） 定时线程池（ScheduledThreadPool ） 可缓存线程池（CachedThreadPool） 单线程化线程池（SingleThreadExecutor） 即 对于上述4类线程池，Java已根据 应用场景 配置好核心参数 定长线程池（FixedThreadPool）特点：只有核心线程 &amp; 不会被回收、线程数量固定、任务队列无大小限制（超出的线程任务会在队列中等待） 应用场景：控制线程最大并发数 具体使用：通过 Executors.newFixedThreadPool() 创建 示例： 123456789101112131415// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run()&#123; System.out.println("执行任务啦"); &#125;&#125;; // 3. 向线程池提交任务：execute（）fixedThreadPool.execute(task); // 4. 关闭线程池fixedThreadPool.shutdown(); 定时线程池（ScheduledThreadPool ） 特点：核心线程数量固定、非核心线程数量无限制（闲置时马上回收） 应用场景：执行定时 / 周期性 任务 使用：通过Executors.newScheduledThreadPool()创建 示例： 123456789101112131415// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run()&#123; System.out.println("执行任务啦"); &#125; &#125;;// 3. 向线程池提交任务：schedule（）scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务// 4. 关闭线程池scheduledThreadPool.shutdown(); 可缓存线程池（CachedThreadPool） 特点：只有非核心线程、线程数量不固定（可无限大）、灵活回收空闲线程（具备超时机制，全部回收时几乎不占系统资源）、新建线程（无线程可用时） 任何线程任务到来都会立刻执行，不需要等待 应用场景：执行大量、耗时少的线程任务 使用：通过Executors.newCachedThreadPool()创建 示例： 123456789101112131415161718// 1. 创建可缓存线程池对象ExecutorService cachedThreadPool = Executors.newCachedThreadPool();// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run()&#123; System.out.println("执行任务啦"); &#125;&#125;;// 3. 向线程池提交任务：execute（）cachedThreadPool.execute(task);// 4. 关闭线程池cachedThreadPool.shutdown();//当执行第二个任务时若第一个任务已经完成//那么会复用执行第一个任务的线程，而不用每次新建线程。 单线程化线程池（SingleThreadExecutor）特点：只有一个核心线程（保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题） 应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等 使用：通过Executors.newSingleThreadExecutor()创建 示例： 123456789101112131415// 1. 创建单线程化线程池ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run()&#123; System.out.println("执行任务啦"); &#125; &#125;;// 3. 向线程池提交任务：execute（）singleThreadExecutor.execute(task);// 4. 关闭线程池singleThreadExecutor.shutdown(); 总结&amp;对比 说明阿里的开发规范中有这么一条： 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，避免资源耗尽的风险。 因此，我们可以通过ThreadPoolExecutor的方式自己创建线程池，根据业务逻辑选择阻塞队列、拒绝策略等。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask学习]]></title>
    <url>%2F2020%2F06%2F06%2FAsyncTask%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述定义 一个Android 已封装好的轻量级异步类 属于抽象类，即使用时需 实现子类 123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ... &#125; 作用 实现多线程在工作线程中执行任务，如 耗时任务 异步通信、消息传递实现工作线程 &amp; 主线程（UI线程）之间的通信，即：将工作线程的执行结果传递给主线程，从而在主线程中执行相关的UI操作 进而保证线程安全 优点 方便实现异步通信不需使用 “任务线程（如继承Thread类） + Handler”的复杂组合 节省资源采用线程池的缓存线程 + 复用线程，避免了频繁创建 &amp; 销毁线程所带来的系统资源开销 类&amp;方法学习类AsyncTask 类属于抽象类，使用时需要实现子类 123456789101112131415public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ... &#125;// 类中参数为3种泛型类型// 整体作用：控制AsyncTask子类执行线程任务时各个阶段的返回类型// 具体说明： // a. Params：开始异步任务执行时传入的参数类型，对应excute（）中传递的参数 // b. Progress：异步任务执行过程中，返回下载进度值的类型 // c. Result：异步任务执行完成后，返回的结果类型，与doInBackground()的返回值类型保持一致// 注： // a. 使用时并不是所有类型都被使用 // b. 若无被使用，可用java.lang.Void类型代替 // c. 若有不同业务，需额外再写1个AsyncTask的子类&#125; 核心方法 方法执行顺序如下： 使用 AsyncTask的使用步骤有3个： 创建 AsyncTask 子类 &amp; 根据需求实现核心方法 创建 AsyncTask子类的实例对象（即 任务实例） 手动调用execute()从而执行异步线程任务 详细如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 步骤1：创建AsyncTask子类 * 注： * a. 继承AsyncTask类 * b. 为3个泛型参数指定类型；若不使用，可用java.lang.Void类型代替 * c. 根据需求，在AsyncTask子类内实现核心方法 */ private class MyTask extends AsyncTask&lt;Params, Progress, Result&gt; &#123; .... // 方法1：onPreExecute（） // 作用：执行 线程任务前的操作 // 注：根据需求复写 @Override protected void onPreExecute() &#123; ... &#125; // 方法2：doInBackground（） // 作用：接收输入参数、执行任务中的耗时操作、返回 线程任务执行的结果 // 注：必须复写，从而自定义线程任务 @Override protected String doInBackground(String... params) &#123; ...// 自定义的线程任务 // 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（） publishProgress(count); &#125; // 方法3：onProgressUpdate（） // 作用：在主线程 显示线程任务执行的进度 // 注：根据需求复写 @Override protected void onProgressUpdate(Integer... progresses) &#123; ... &#125; // 方法4：onPostExecute（） // 作用：接收线程任务执行结果、将执行结果显示到UI组件 // 注：必须复写，从而自定义UI操作 @Override protected void onPostExecute(String result) &#123; ...// UI操作 &#125; // 方法5：onCancelled() // 作用：将异步任务设置为：取消状态 @Override protected void onCancelled() &#123; ... &#125; &#125;/** * 步骤2：创建AsyncTask子类的实例对象（即 任务实例） * 注：AsyncTask子类的实例必须在UI线程中创建 */ MyTask mTask = new MyTask();/** * 步骤3：手动调用execute(Params... params) 从而执行异步线程任务 * 注： * a. 必须在UI线程中调用 * b. 同一个AsyncTask实例对象只能执行1次，若执行第2次将会抛出异常 * c. 执行任务中，系统会自动调用AsyncTask的一系列方法：onPreExecute() 、doInBackground()、onProgressUpdate() 、onPostExecute() * d. 不能手动调用上述方法 */ mTask.execute()； 实例Demoactivity_main.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" tools:context="com.example.carson_ho.handler_learning.MainActivity"&gt; &lt;Button android:layout_centerInParent="true" android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="点我加载"/&gt; &lt;TextView android:id="@+id/text" android:layout_below="@+id/button" android:layout_centerInParent="true" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="还没开始加载!" /&gt; &lt;ProgressBar android:layout_below="@+id/text" android:id="@+id/progress_bar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:progress="0" android:max="100" style="?android:attr/progressBarStyleHorizontal"/&gt; &lt;Button android:layout_below="@+id/progress_bar" android:layout_centerInParent="true" android:id="@+id/cancel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="cancel"/&gt;&lt;/RelativeLayout&gt; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class MainActivity extends AppCompatActivity &#123; private MyTask myTask; private Button button; private Button cancel; private TextView text; private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = findViewById(R.id.button); cancel = findViewById(R.id.cancel); text = findViewById(R.id.text); progressBar = findViewById(R.id.progress_bar); /** * 步骤2：创建AsyncTask子类的实例对象（即 任务实例） * 注：AsyncTask子类的实例必须在UI线程中创建 */ myTask = new MyTask(); // 加载按钮按按下时，则启动AsyncTask // 任务完成后更新TextView的文本 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /** * 步骤3：手动调用execute(Params... params) 从而执行异步线程任务 * 注： * a. 必须在UI线程中调用 * b. 同一个AsyncTask实例对象只能执行1次，若执行第2次将会抛出异常 * c. 执行任务中，系统会自动调用AsyncTask的一系列方法：onPreExecute() 、doInBackground()、onProgressUpdate() 、onPostExecute() * d. 不能手动调用上述方法 */ myTask.execute(); &#125; &#125;); cancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //取消一个正在执行的任务， onCancelled方法将会被调用 myTask.cancel(true); &#125; &#125;); &#125; private class MyTask extends AsyncTask&lt;String, Integer, String&gt; &#123; // 方法1： 执行线程任务前的操作 @Override protected void onPreExecute() &#123; text.setText("加载中..."); &#125; // 方法2： 接收输入参数、执行任务中的耗时操作、返回线程任务执行的结果 //这里通过计算模拟 加载进度 的情况 @Override protected String doInBackground(String... strings) &#123; try &#123; int count = 0; int length = 1; while (count &lt; 99) &#123; count += length; //可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（） publishProgress(count); //模拟耗时任务 Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; // 方法3： 在主线程 显示任务执行的进度 @Override protected void onProgressUpdate(Integer... values) &#123; progressBar.setProgress(values[0]); text.setText("loading... " + values[0] + "%"); &#125; // 方法4： 接收线程任务执行结果，将执行结果显示到UI组件 @Override protected void onPostExecute(String s) &#123; //执行完毕后 更新UI text.setText("加载完毕"); &#125; //方法5： 将异步任务设置为 取消状态 @Override protected void onCancelled() &#123; text.setText("已取消"); progressBar.setProgress(0); &#125; &#125;&#125; 效果 Demo地址https://github.com/Commandercc/DemoEX/blob/master/AsyncTaskDemo.zip?raw=true 问题说明关于生命周期 结论 AsyncTask不与任何组件绑定生命周期 使用建议 在Activity 或 Fragment中使用 AsyncTask时，最好在Activity 或 Fragment的onDestory（）调用 cancel(boolean)； 内存x泄露 结论 若AsyncTask被声明为Activity的非静态内部类，当Activity需销毁时，会因AsyncTask保留对Activity的引用 而导致Activity无法被回收，最终引起内存泄露 使用建议 AsyncTask应被声明为Activity的静态内部类 线程任务执行结果 丢失 结论 当Activity重新创建时（屏幕旋转 / Activity被意外销毁时后恢复），之前运行的AsyncTask（非静态的内部类）持有的之前Activity引用已无效，故复写的onPostExecute()将不生效，即无法更新UI操作 使用建议 在Activity恢复时的对应方法 重启任务线程]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler的使用学习]]></title>
    <url>%2F2020%2F06%2F06%2FHandler%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[使用方式 Handler使用方式 因发送消息到消息队列的方式不同而不同 共分为2种：使用Handler.sendMessage（）、使用Handler.post（） 方式一 使用 Handler.sendMessage（） 在该使用方式中，又分为2种：新建Handler子类（内部类）、匿名 Handler子类 但本质相同，即 继承了Handler类 &amp; 创建了子类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 方式1：新建Handler子类（内部类） */ // 步骤1：自定义Handler子类（继承Handler类） &amp; 复写handleMessage（）方法 class mHandler extends Handler &#123; // 通过复写handlerMessage() 从而确定更新UI的操作 @Override public void handleMessage(Message msg) &#123; ...// 需执行的UI操作 &#125; &#125; // 步骤2：在主线程中创建Handler实例 private Handler mhandler = new mHandler(); // 步骤3：创建所需的消息对象 Message msg = Message.obtain(); // 实例化消息对象 msg.what = 1; // 消息标识 msg.obj = "AA"; // 消息内容存放 // 步骤4：在工作线程中 通过Handler发送消息到消息队列中 // 可通过sendMessage（） / post（） // 多线程可采用AsyncTask、继承Thread类、实现Runnable mHandler.sendMessage(msg); // 步骤5：开启工作线程（同时启动了Handler） // 多线程可采用AsyncTask、继承Thread类、实现Runnable/** * 方式2：匿名内部类 */ // 步骤1：在主线程中 通过匿名内部类 创建Handler类对象 private Handler mhandler = new Handler()&#123; // 通过复写handlerMessage()从而确定更新UI的操作 @Override public void handleMessage(Message msg) &#123; ...// 需执行的UI操作 &#125; &#125;; // 步骤2：创建消息对象 Message msg = Message.obtain(); // 实例化消息对象 msg.what = 1; // 消息标识 msg.obj = "AA"; // 消息内容存放 // 步骤3：在工作线程中 通过Handler发送消息到消息队列中 // 多线程可采用AsyncTask、继承Thread类、实现Runnable mHandler.sendMessage(msg); // 步骤4：开启工作线程（同时启动了Handler） // 多线程可采用AsyncTask、继承Thread类、实现Runnable 方式二 使用Handler.post（） 123456789101112131415// 步骤1：在主线程中创建Handler实例 private Handler mhandler = new mHandler(); // 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容 // 需传入1个Runnable对象 mHandler.post(new Runnable() &#123; @Override public void run() &#123; ... // 需执行的UI操作 &#125; &#125;); // 步骤3：开启工作线程（同时启动了Handler） // 多线程可采用AsyncTask、继承Thread类、实现Runnable 实例Demo–使用 handleMessage()activity_main.xml123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/show" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" /&gt;&lt;/LinearLayout&gt; MainActivity.java方式一：新建Handler子类（内部类） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity &#123; public TextView mTextView; public Handler mHandler; // 步骤1：（自定义）新创建Handler子类(继承Handler类) &amp; 复写handleMessage（）方法 class Mhandler extends Handler &#123; // 通过复写handlerMessage() 从而确定更新UI的操作 @Override public void handleMessage(Message msg) &#123; // 根据不同线程发送过来的消息，执行不同的UI操作 // 根据 Message对象的what属性 标识不同的消息 switch (msg.what) &#123; case 1: mTextView.setText("执行了线程1的UI操作"); break; case 2: mTextView.setText("执行了线程2的UI操作"); break; &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.show); // 步骤2：在主线程中创建Handler实例 mHandler = new Mhandler(); // 采用继承Thread类实现多线程演示 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 步骤3：创建所需的消息对象 Message msg = Message.obtain(); msg.what = 1; // 消息标识 msg.obj = "A"; // 消息内存存放 // 步骤4：在工作线程中 通过Handler发送消息到消息队列中 mHandler.sendMessage(msg); &#125; &#125;.start(); // 步骤5：开启工作线程（同时启动了Handler） // 此处用2个工作线程展示 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通过sendMessage（）发送 // a. 定义要发送的消息 Message msg = Message.obtain(); msg.what = 2; //消息的标识 msg.obj = "B"; // 消息的存放 // b. 通过Handler发送消息到其绑定的消息队列 mHandler.sendMessage(msg); &#125; &#125;.start(); &#125;&#125; 方式二：匿名内部类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends AppCompatActivity &#123; public TextView mTextView; public Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.show); // 步骤1：在主线程中 通过匿名内部类 创建Handler类对象 mHandler = new Handler()&#123; // 通过复写handlerMessage()从而确定更新UI的操作 @Override public void handleMessage(Message msg) &#123; // 根据不同线程发送过来的消息，执行不同的UI操作 switch (msg.what) &#123; case 1: mTextView.setText("执行了线程1的UI操作"); break; case 2: mTextView.setText("执行了线程2的UI操作"); break; &#125; &#125; &#125;; // 采用继承Thread类实现多线程演示 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 步骤3：创建所需的消息对象 Message msg = Message.obtain(); msg.what = 1; // 消息标识 msg.obj = "A"; // 消息内存存放 // 步骤4：在工作线程中 通过Handler发送消息到消息队列中 mHandler.sendMessage(msg); &#125; &#125;.start(); // 步骤5：开启工作线程（同时启动了Handler） // 此处用2个工作线程展示 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通过sendMessage（）发送 // a. 定义要发送的消息 Message msg = Message.obtain(); msg.what = 2; //消息的标识 msg.obj = "B"; // 消息的存放 // b. 通过Handler发送消息到其绑定的消息队列 mHandler.sendMessage(msg); &#125; &#125;.start(); &#125;&#125; 使用post()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MainActivity extends AppCompatActivity &#123; public TextView mTextView; public Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.show); // 步骤1：在主线程中创建Handler实例 mHandler = new Handler(); // 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通过psot（）发送，需传入1个Runnable对象 mHandler.post(new Runnable() &#123; @Override public void run() &#123; // 指定操作UI内容 mTextView.setText("执行了线程1的UI操作"); &#125; &#125;); &#125; &#125;.start(); // 步骤3：开启工作线程（同时启动了Handler） // 此处用2个工作线程展示 new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTextView.setText("执行了线程2的UI操作"); &#125; &#125;); &#125; &#125;.start(); &#125;&#125; 效果 Demo地址https://github.com/Commandercc/DemoEX/blob/master/HandlerLearningDemo.zip?raw=true]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler通信机制原理学习]]></title>
    <url>%2F2020%2F06%2F05%2FHandler%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述在Android开发的多线程应用场景中，Handler机制十分常用，以前陆陆续续了解过，没系统的学习，现在系统的学习一下。 参考大神文章：https://www.jianshu.com/p/f0b23ee5a922 是什么？Handler是一套Android的消息传递机制。 作用在多线程的应用场景中，将工作线程中需更新UI的操作信息传递到 UI 主线程，从而实现工作线程对UI的更新处理，最终实现异步消息的处理。 为什么要用Handler多个线程并发更新UI的同时 保证线程安全 相关概念主要涉及 Handler、Message、Message Queue、Looper 工作原理解析1、工作流程Handler机制的工作流程主要包括4个步骤： 异步通信准备 消息发送 消息循环 消息处理 具体如下图： 线程阻塞含义： MessageQueue的主要方法next和enqueueMessage，其中next方法在队列为空或者消息暂未达到处理时间的时候，线程会阻塞，这里的阻塞是通过native层的epoll方式进行的阻塞。enqueueMessage方法在添加Message的同时也会判断是否需要唤醒线程，若是需要则在native层通过对文件的写入数据而触发epoll设置的事件监听，因此唤醒线程。 2、流程图 3、示意图 4、注意点线程（Thread）、循环器（Looper）、处理者（Handler）之间的对应关系如下： 1个线程（Thread）只能绑定 1个循环器（Looper），但可以有多个处理者（Handler） 1个循环器（Looper） 可绑定多个处理者（Handler） 1个处理者（Handler） 只能绑定1个1个循环器（Looper）]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager2学习]]></title>
    <url>%2F2020%2F06%2F03%2FViewPager2%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[引入1implementation "androidx.viewpager2:viewpager2:1.0.0" 前言 ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。 简单使用Demo基本思路 1、一个子项布局 2、一个adapter适配器 3.、在主布局引入viewpager2 4、viewpager2对象添加adapter activity_main.xml1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" tools:context=".MainActivity"&gt; &lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/page" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/RelativeLayout&gt; item_text.xml和recyclerview一样，该布局是适配器（即子项页面的布局）要用到的布局。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/item_text" android:layout_width="match_parent" android:layout_height="300dp" android:gravity="center" /&gt;&lt;/LinearLayout&gt; ViewAdapter.java1234567891011121314151617181920212223242526272829303132333435public class ViewAdapter extends RecyclerView.Adapter&lt;ViewAdapter.ViewPagerHolder&gt; &#123; private List&lt;Integer&gt; datas; //这个demo传入一组颜色数据 public ViewAdapter(List&lt;Integer&gt; datas) &#123; this.datas = datas; &#125; @NonNull @Override public ViewPagerHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_text, parent, false); //根据上面的子布局生成view return new ViewPagerHolder(view); &#125; @Override public void onBindViewHolder(@NonNull ViewPagerHolder holder, int position) &#123; holder.textView.setText("页面: " + position); holder.textView.setBackgroundColor(datas.get(position)); &#125; @Override public int getItemCount() &#123; return datas.size(); &#125; class ViewPagerHolder extends RecyclerView.ViewHolder &#123; TextView textView; public ViewPagerHolder(@NonNull View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text); &#125; &#125;&#125; MainActivity.java123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewPager2 vp2 = findViewById(R.id.page); List&lt;Integer&gt; colors = new ArrayList&lt;&gt;(); colors.add(Color.BLUE); colors.add(Color.GREEN); colors.add(Color.RED); //vp2.setOrientation(ViewPager2.ORIENTATION_VERTICAL); //竖直方向 默认水平方向 vp2.setAdapter(new ViewAdapter(colors)); &#125;&#125; 效果 与 Fragment 结合 在使用 ViewPager 的时候，可以使用 FragmentPagerAdapter 实现页数小的情况，用 FragmentStatePagerAdapter 实现页面比较多的情况。ViewPager2 则没有那么复杂，直接使用 FragmentStateAdapter 即可。 基本思路 1、fragment的布局 2、一个Adapter`承于FragmentStateAdapter 3、在主布局引入viewpager2 4、viewpager2 添加adapter fm_demo.xmlfragment的布局 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tvDemo" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:textSize="28sp" /&gt;&lt;/LinearLayout&gt; DemoFragment.java1234567891011121314151617181920212223public class DemoFragment extends Fragment &#123; private TextView tvDemo; private String title; public DemoFragment(String title) &#123; this.title = title; &#125; public DemoFragment() &#123; &#125; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fm_demo, container, false); //使用前面的 fm_demo 布局来构造fragment tvDemo = view.findViewById(R.id.tvDemo); tvDemo.setBackgroundColor(Color.YELLOW); tvDemo.setText(title); return view; &#125;&#125; FragmentAdapter.java123456789101112131415161718192021222324class FragmentAdapter extends FragmentStateAdapter &#123; private List&lt;String&gt; titles; public FragmentAdapter(@NonNull FragmentActivity fragmentActivity, List&lt;String&gt; titles) &#123; super(fragmentActivity); this.titles = titles; &#125; public FragmentAdapter(@NonNull FragmentActivity fragmentActivity) &#123; super(fragmentActivity); &#125; @NonNull @Override public Fragment createFragment(int position) &#123; return new DemoFragment(titles.get(position)); //构造fragment &#125; @Override public int getItemCount() &#123; return titles.size(); &#125;&#125; MainActivity.java主布局和前面简单demo一样，只有一个viewpager2 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ViewPager2 vp2 = findViewById(R.id.page); //简单demo// List&lt;Integer&gt; colors = new ArrayList&lt;&gt;();// colors.add(Color.BLUE);// colors.add(Color.GREEN);// colors.add(Color.RED);//// //vp2.setOrientation(ViewPager2.ORIENTATION_VERTICAL); //竖直方向 默认水平方向// vp2.setAdapter(new ViewAdapter(colors)); // 和fragment结合 List&lt;String&gt; titles = new ArrayList&lt;&gt;(); titles.add("页面1"); titles.add("页面2"); titles.add("页面3"); FragmentAdapter adapter = new FragmentAdapter(MainActivity.this,titles); vp2.setAdapter(adapter); &#125;&#125; 效果 配合 TabLayout 使用基本思路 1、需要的布局中引入 tabLayout 和 viewPage2 2、一个Tab项的布局页面 3、一个页面适配器 Adapter 继承自 FragmentStateAdapter 4、创建Tab ，并添加到TabLayout中 5、viewpager2对象添加前面的适配器 Adapter 6、ViewPager2 配合 TabLayout 的联动 方式一：TabLayoutMediator进行绑定 attach() 方式二：原始的监听事件中操作 7、选择性的注册 TabLayout 的选择事件监听 和 viewpage2的事件监听 布局中引入activity_main.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/linearLayout" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;com.google.android.material.tabs.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;androidx.viewpager2.widget.ViewPager2 android:layout_marginTop="100dp" android:id="@+id/page" android:layout_width="match_parent" android:layout_height="300dp"/&gt;&lt;/LinearLayout&gt; Tab项的布局页面tab_item.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center"&gt; &lt;TextView android:id="@+id/tvTitle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="5dp" tools:text="标签" /&gt; &lt;ImageView android:layout_width="15dp" android:layout_height="15dp" android:background="@mipmap/ic_launcher" /&gt;&lt;/LinearLayout&gt; 页面适配器 TabAdapterTabAdapter.java 12345678910111213141516171819public class TabAdapter extends FragmentStateAdapter &#123; private List&lt;String&gt; titles; public TabAdapter(@NonNull FragmentActivity fragmentActivity, List&lt;String&gt; titles) &#123; super(fragmentActivity); this.titles = titles; &#125; @NonNull @Override public Fragment createFragment(int position) &#123; return new DemoFragment(titles.get(position)); &#125; @Override public int getItemCount() &#123; return titles.size(); &#125;&#125; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends AppCompatActivity &#123; private TabLayout tabLayout; private List&lt;String&gt; titles; private TabLayoutMediator tabLayoutMediator; private ViewPager2 vp2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); vp2 = findViewById(R.id.page); tabLayout = findViewById(R.id.tabLayout); titles = new ArrayList&lt;&gt;(); titles.add("title0"); titles.add("title1"); titles.add("title2"); TabLayout.Tab tab1 = tabLayout.newTab(); tab1.setCustomView(R.layout.tab_item); //创建并添加 Tab TextView tvTitle = tab1.getCustomView().findViewById(R.id.tvTitle); tvTitle.setText("带图标"); tabLayout.addTab(tab1); TabLayout.Tab tab2 = tabLayout.newTab().setText("自定义标题1"); tabLayout.addTab(tab2); TabLayout.Tab tab3 = tabLayout.newTab().setText("自定义标题2"); tabLayout.addTab(tab3); //创建 Adapter TabAdapter tabAdapter = new TabAdapter(MainActivity.this, titles); vp2.setAdapter(tabAdapter); //tabLayout 和 vp2 联动 使用 tabLayoutMediator方式 tabLayoutMediator = new TabLayoutMediator(tabLayout, vp2, new TabLayoutMediator.TabConfigurationStrategy() &#123; @Override public void onConfigureTab(@NonNull TabLayout.Tab tab, int position) &#123; tab.setText(titles.get(position)); &#125; &#125;); //绑定 tabLayoutMediator.attach(); //tabLayout的事件监听 tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;); //vp2的事件监听 vp2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123; @Override public void onPageSelected(int position) &#123; &#125; &#125;); &#125; //解绑 @Override protected void onDestroy() &#123; if (tabLayoutMediator != null) &#123; tabLayoutMediator.detach(); &#125; super.onDestroy(); &#125;&#125; 说明TabLayout使用自定义布局和ViewPager2联动时会出现问题，TabLayout的自定义效果会无效，所以要想使用自定义的tablayout布局 ，就采用最原始的联动 原始联动即在上面监听事件的基础上进行修改： 1234567891011121314151617181920212223tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; vpTablayout.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;); vp2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123; @Override public void onPageSelected(int position) &#123; tabLayout.selectTab(tabLayout.getTabAt(position)); &#125; &#125;); 效果 常用法页面滑动事件监听1234567891011121314151617//滑动监听vp2.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; super.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; @Override public void onPageSelected(int position) &#123; Toast.makeText(MainActivity.this,"select: "+titles.get(position),Toast.LENGTH_SHORT).show(); &#125; @Override public void onPageScrollStateChanged(int state) &#123; super.onPageScrollStateChanged(state); &#125;&#125;); 禁止滑动12//禁止用户滑动 false为禁止滑动 true为可以滑动vp2.setUserInputEnabled(false); 设置页面间距1vp2.setPageTransformer(new MarginPageTransformer(10)) //页面间距为10dp 组合页面效果1234CompositePageTransformer compositePageTransformer = new CompositePageTransformer();compositePageTransformer.addTransformer(new MarginPageTransformer(25));compositePageTransformer.addTransformer(new ScaleInTransformer());vp2.setPageTransformer(compositePageTransformer); 123456789101112131415161718192021222324252627282930313233343536373839private class ScaleInTransformer implements ViewPager2.PageTransformer &#123; private static final float DEFAULT_MIN_SCALE = 0.85f; private static final float DEFAULT_CENTER = 0.5f; private float mMinScale = DEFAULT_MIN_SCALE; @Override public void transformPage(@NonNull View view, float position) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; view.setElevation(-Math.abs(position)); &#125; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); view.setPivotY(pageHeight / 2); view.setPivotX(pageWidth / 2); if (position &lt; -1) &#123; view.setScaleX(mMinScale); view.setScaleY(mMinScale); view.setPivotX(pageWidth); &#125; else if (position &lt;= 1) &#123; if (position &lt; 0) &#123; float scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale; view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); view.setPivotX(pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)); &#125; else &#123; float scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale; view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); view.setPivotX(pageWidth * ((1 - position) * DEFAULT_CENTER)); &#125; &#125; else &#123; view.setPivotX(0); view.setScaleX(mMinScale); view.setScaleY(mMinScale); &#125; &#125;&#125; 大概类似于下面这种滑动效果 transformPage(@NonNull View view, float position) 第一个参数，就是你当前想要进行transform的view。 第二参数position，我们通常会第一反应理解为是这个view在整个ViewPager中的第几个，但是在这里我们要注意，它并不是一个int型数据，而是一个浮点型，所以它代表的是第一个参数view的左上角x轴坐标参数。我们都知道，对于手机屏幕来说，屏幕左上角为坐标原点（0，0），那么在ViewPager显示第一个View时，View1的position就是0，但是当我们往左滑动的时候，它就会慢慢发生变化。当滑动结束的时候，View1的位置就从原来手机屏幕的位置，到了屏幕左边的位置，它的position就从0.0变成了-1.0。而对于第二个View，当屏幕还在展示View1时，它是在屏幕的右边，所以它的position就是1.0。当左滑结束，View2显示在屏幕上时，它的position就从1.0变成了0.0。依次可以类推。 ViewPager2的一屏多页效果ViewPager2的一屏多页实现跟ViewPager并无多大差别。需要把ViewPager2父容器的clipChildren设置为false，同时ViewPager2的clipChildren也设置为false并且将ViewPager2的offscreenPageLimit 设置为2以及为ViewPager2设置marge即可。代码如下： 123456789101112LinearLayout linearLayout = findViewById(R.id.linearLayout);linearLayout.setClipChildren(false);vp2.setClipChildren(false);vp2.setOffscreenPageLimit(2);ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)vp2.getLayoutParams();params.setMarginStart(80);params.setMarginEnd(80);CompositePageTransformer compositePageTransformer = new CompositePageTransformer();compositePageTransformer.addTransformer(new MarginPageTransformer(25));compositePageTransformer.addTransformer(new ScaleInTransformer());vp2.setPageTransformer(compositePageTransformer); Demo地址https://github.com/Commandercc/DemoEX/blob/master/ViewPager2Demo.zip]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BottomSheetDialog使用]]></title>
    <url>%2F2020%2F06%2F03%2FBottomSheetDialog%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说明这里只实现基本操作，复杂的操作在基础上添加即可。 实现如下效果 Demo添加依赖两个依赖，一个recyclerView的，一个Material库的。BottomSheetDialog就是Material库中的。 12implementation &apos;androidx.recyclerview:recyclerview:1.1.0&apos;implementation &apos;com.google.android.material:material:1.0.0&apos; Fruit类12345678910111213141516171819202122232425public class Fruit &#123; private int id; private String name; public Fruit(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; fruit_item.xmlRecyclerView中子项的布局 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/fruit_id" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="1" android:gravity="center"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="2" android:text="樱桃" android:gravity="center"/&gt;&lt;/LinearLayout&gt; FruitAdapter123456789101112131415161718192021222324252627282930313233343536373839public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; fruits; public FruitAdapter(List&lt;Fruit&gt; fruits) &#123; this.fruits = fruits; &#125; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123; Fruit fruit = fruits.get(position); holder.tv_id.setText(fruit.getId()+""); holder.tv_name.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return fruits.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder&#123; TextView tv_id; TextView tv_name; public ViewHolder(@NonNull View view) &#123; super(view); tv_id = view.findViewById(R.id.fruit_id); tv_name = view.findViewById(R.id.fruit_name); &#125; &#125;&#125; activity_bottom_sheet_dialog.xml1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".BottomSheetDialogActivity"&gt; &lt;Button android:id="@+id/btn_show" android:text="弹出" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; dialog_bottomsheet.xml弹窗的布局 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="600dp" android:orientation="vertical"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="40dp"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="水果列表" android:textStyle="bold"/&gt; &lt;/RelativeLayout&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id="@+id/dialog_recycleView" android:layout_width="match_parent" android:layout_height="500dp"/&gt;&lt;/LinearLayout&gt; BottomSheetDialogActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BottomSheetDialogActivity extends AppCompatActivity &#123; private BottomSheetDialog bottomSheetDialog; private BottomSheetBehavior mDialogBehavior; private RecyclerView recyclerView; private FruitAdapter adapter; private Button btn; private List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;(); private String[] fruitNames = &#123;"苹果","香蕉","樱桃","草莓","橘子"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_bottom_sheet_dialog); btn = findViewById(R.id.btn_show); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; initData(); showSheetDialog(); bottomSheetDialog.show(); &#125; &#125;); &#125; private void showSheetDialog() &#123; View view = View.inflate(BottomSheetDialogActivity.this,R.layout.dialog_bottomsheet,null); recyclerView = view.findViewById(R.id.dialog_recycleView); recyclerView.setLayoutManager(new LinearLayoutManager(this)); adapter = new FruitAdapter(fruits); recyclerView.setAdapter(adapter); bottomSheetDialog = new BottomSheetDialog(BottomSheetDialogActivity.this,R.style.dialog); //该style样式在最后说明了 bottomSheetDialog.setContentView(view); bottomSheetDialog.setCanceledOnTouchOutside(true); //设置背景为透明 bottomSheetDialog.getWindow().findViewById(R.id.design_bottom_sheet).setBackgroundResource(android.R.color.transparent); mDialogBehavior = BottomSheetBehavior.from((View)view.getParent()); mDialogBehavior.setPeekHeight(getPeekHeight()); //设置高度 &#125; /** * 弹窗高度，默认为屏幕高度的四分之三 * 子类可重写该方法返回peekHeight * * @return height */ private int getPeekHeight() &#123; int peekHeight = getResources().getDisplayMetrics().heightPixels; //设置弹窗高度为屏幕高度的3/4 return peekHeight - peekHeight/4; &#125; private void initData() &#123; Random random = new Random(); for (int i = 1; i &lt;= 30; i++) &#123; fruits.add(new Fruit(i,fruitNames[random.nextInt(5)])); &#125; &#125;&#125; 其他文件 enter_bottom_menu: 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromYDelta="100%p" android:toYDelta="0" /&gt; &lt;alpha android:duration="300" android:fromAlpha="0.0" android:toAlpha="1.0" /&gt;&lt;/set&gt; exit_bottom_menu: 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromYDelta="0" android:toYDelta="100%p"/&gt; &lt;alpha android:duration="300" android:fromAlpha="1.0" android:toAlpha="0.0"/&gt;&lt;/set&gt; style样式将下面这段添加到 res -&gt; values -&gt; styles 中即可引用 12345678910111213141516171819&lt;!-- dialog从ios效果动画 --&gt;&lt;style name="BottomShowAnimation" parent="@android:style/Animation.Dialog"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/enter_bottom_menu&lt;/item&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/exit_bottom_menu&lt;/item&gt;&lt;/style&gt;&lt;style name="dialog" parent="@android:style/Theme.Dialog"&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:background"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;!-- Dialog进入及退出动画 --&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/BottomShowAnimation&lt;/item&gt; &lt;!--弹窗背景是否变暗--&gt; &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpannableString]]></title>
    <url>%2F2020%2F06%2F02%2FSpannableString%2F</url>
    <content type="text"><![CDATA[概述安卓开发中TextView 是我们最常用的控件之一，我们用TextView为我们在页面中展示文本。展示普通文本当然没有任何难度,使用TextView的setText()方法设置一个字符串就可以了，但是当我们需要在文本中展示不同格式文本的时候，设置普通的字符串就不行了。那该怎么办？当然就说到我们今天的主角了。SpannableString和SpannableStringBuilder SpannableStringSpannableString和String一样都是一种字符串类型，他们都实现了CharSequence，所以SpannableString也可以直接使用TextView的setText()方法设置文本。SpannableString的特别之处就在于SpannableString可以打造丰富多彩的文本显示效果。SpannableString可以通过使用其方法setSpan()实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 可以实现的常用效果 自定义文本中文字的字体大小（包括绝对大小和相对大小，区别看下面解释） 设置文本中文字的前景色、背景色 为文本中的文字设置下划线，删除线 设置文本中的内容上标、下标 为文字设置风格，粗体斜体等 设置图文混排，即文字中添加图片 可以为部分文本设置点击事件 setSpan()123public void setSpan(Object what, int start, int end, int flags) &#123; super.setSpan(what, start, end, flags);&#125; setSpan()方法有四个参数，其中what就是所要设置的格式，start是需要设置格式的子字符串的起始下标，end就是结束下标，但并不包括这个位置。flag一共有四种值可选。如下： Spannable. SPAN_INCLUSIVE_EXCLUSIVE 前面包括，后面不包括，意思就是在这段文本前部插入新的文本会应用该样式，而在文本后部插入新文本则不会应用该样式 Spannable. SPAN_INCLUSIVE_INCLUSIVE 前面包括，后面包括，意思就是在这段文本前部插入新的文本会应用该样式，在文本后部插入新文本也会应用该样式 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 前面不包括，后面不包括 Spanned.SPAN_EXCLUSIVE_INCLUSIVE 前面不包括，后面包括 简单demo12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");ForegroundColorSpan foregroundColorSpan=new ForegroundColorSpan(Color.parseColor("#FF0000"));ss.setSpan(foregroundColorSpan,2,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 说明SpannableString的setSpan()方法可以同时使用多个，实现多种效果叠加。 setSpan()方法中的what是最重要的一个参数，对应各种span，不同的span对应不同的样式。 常用格式效果设置看一下不同的几种常见的span以及效果 为文本设置背景色 BackgroundColorSpan12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");BackgroundColorSpan backgroundColorSpan=new BackgroundColorSpan(Color.parseColor("#FFFF00"));ss.setSpan(backgroundColorSpan,2,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 为文本设置下划线以及删除线 UnderlineSpan：下划线 StrikethroughSpan ：删除线 1234567TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");UnderlineSpan underlineSpan=new UnderlineSpan();//下划线spanStrikethroughSpan strikethroughSpan=new StrikethroughSpan();//删除线ss.setSpan(underlineSpan,3,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);ss.setSpan(strikethroughSpan,0,3,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 设置文本字体 AbsoluteSizeSpan设置的是绝对大小，直接用具体数值指定文字大小 12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");AbsoluteSizeSpan absoluteSizeSpan=new AbsoluteSizeSpan(30,true); //参数size，以size的指定像素值来设定文本大小，如果参数dip为true则以size指定的dip为值来设定文本大小。ss.setSpan(absoluteSizeSpan,3,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 设置文本字体 RelativeSizeSpan设置的是相对大小，在TextView原有的文字大小的基础上，相对设置文字大小 12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");RelativeSizeSpan relativeSizeSpan=new RelativeSizeSpan(0.5f);ss.setSpan(relativeSizeSpan,3,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 设置字体样式（粗体、斜体等） StyleSpan12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");StyleSpan styleSpan=new StyleSpan(Typeface.BOLD);ss.setSpan(styleSpan,3,6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 设置文本中的内容上标 SuperscriptSpan 、下标SubscriptSpan 1234567 TextView main_tv=findViewById(R.id.main_tv); SpannableString ss=new SpannableString("其实我是一个好人"); SuperscriptSpan superscriptSpan=new SuperscriptSpan();//上标 SubscriptSpan subscriptSpan=new SubscriptSpan();//下标//ss.setSpan(superscriptSpan,3,5, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ss.setSpan(subscriptSpan,0,2,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); main_tv.setText(ss); 文本中插入图片 ImageSpan12345TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");ImageSpan imageSpan=new ImageSpan(this,R.mipmap.ic_launcher);ss.setSpan(imageSpan,2,3,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss); 给部分文本设置点击事件 ClickableSpan1234567891011TextView main_tv=findViewById(R.id.main_tv);SpannableString ss=new SpannableString("其实我是一个好人");ClickableSpan clickableSpan=new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; Toast.makeText(SecondActivity.this, "点击了", Toast.LENGTH_SHORT).show(); &#125;&#125;;ss.setSpan(clickableSpan,2,4,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);main_tv.setText(ss);main_tv.setMovementMethod(LinkMovementMethod.getInstance()); 使用ClickableSpan设置点击事件，最后还需要加上main_tv.setMovementMethod(LinkMovementMethod.getInstance())这一句，不然不生效。 (此方法在需要响应用户事件时使用) 超链接用法和点击事件一样，需要添加setMovementMethod方法附加响应 msp.setSpan(new URLSpan(“tel:4155551212”), 37, 39, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //电话 msp.setSpan(new URLSpan(“mailto:webmaster@google.com“), 39, 41, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //邮件 msp.setSpan(new URLSpan(“http://www.baidu.com&quot;), 41, 43, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //网络 msp.setSpan(new URLSpan(“sms:4155551212”), 43, 45, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //短信 使用sms:或者smsto: msp.setSpan(new URLSpan(“mms:4155551212”), 45, 47, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //彩信 使用mms:或者mmsto: msp.setSpan(new URLSpan(“geo:38.899533,-77.036476”), 47, 49, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //地图 SpannableStringBuilderSpannableStringBuilder 与 SpannableString 的区别就和string 与 stringBuilder 的区别类似。就是SpannableStringBuilder可以使用append()方法拼接，而SpannableString不可拼接。其他没有多大区别。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InputMethodManager输入法简介]]></title>
    <url>%2F2020%2F06%2F01%2FInputMethodManager%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[结构123public final class InputMethodManager&#123; .....&#125; 类概述 整个输入法框架（IMF）结构的核心API，应用程序之间进行调度和当前输入法交互。你可以用Context.getSystemService() 取得这一接口的实例。 架构总述输入法框架（IMF）共有三个主要部分： 输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的context中，用来沟通管理所有进程间交互的全局系统服务。 输入法(IME) ，实现一个允许用户生成文本的独立交互模块。系统绑定一个当前的输入法。使其创建和生成，决定输入法何时隐藏或者显示它的UI。同一时间只能有一个IME运行。 客户应用程序，通过输入法管理器控制输入焦点和IME的状态。一次只能有一个客户端使用IME。 常量第一组： 12345678// hideSoftInputFromWindow(IBinder, int)中的标志，表示如果用户未显式地显示软键盘窗口，则隐藏窗口。public static final int HIDE_IMPLICIT_ONLY = 0x0001; //常量值: 1// hideSoftInputFromWindow(IBinder, int)中的标志，表示软键盘窗口总是隐藏，除非开始时以SHOW_FORCED显示。public static final int HIDE_NOT_ALWAYS = 0x0002; // 常量值: 2 第二组： 12345678// showSoftInput(View, int, ResultReceiver)和hideSoftInputFromWindow(IBinder, int, ResultReceiver)中ResultReceiver结果代码标志：软键盘窗口从隐藏切换到显示时的状态。public static final int RESULT_SHOWN = 2; //常量值: 2// showSoftInput(View, int, ResultReceiver)和hideSoftInputFromWindow(IBinder, int, ResultReceiver)中ResultReceiver结果代码标志：软键盘窗口从显示切换到隐藏时的状态。public static final int RESULT_HIDDEN = 3; //常量值: 3 第三组： 12345678// showSoftInput(View, int, ResultReceiver)和hideSoftInputFromWindow(IBinder, int, ResultReceiver)中ResultReceiver结果代码标志：软键盘窗口不变保持显示时的状态。public static final int RESULT_UNCHANGED_SHOWN = 0; //常量值: 0// showSoftInput(View, int, ResultReceiver)和hideSoftInputFromWindow(IBinder, int, ResultReceiver)中ResultReceiver结果代码标志：软键盘窗口不变保持隐藏时的状态。public static final int RESULT_UNCHANGED_HIDDEN = 1; //常量值 1 第四组： 12345678// showSoftInput(View, int)标志，表示隐式显示输入窗口，非用户直接要求。窗口可能不显示。public static final int SHOW_IMPLICIT = 0x0001;// showSoftInput(View, int)标志，表示用户强制打开输入法（如长按菜单键），一直保持打开直至只有显式关闭。public static final int SHOW_FORCED = 0x0002; //常量值 2 方法12public void displayCompletions(View view, CompletionInfo[] completions)// 输入法自动实现该方法 12public InputMethodSubtype getCurrentInputMethodSubtype ()// 获取当前输入法类型 12public List&lt;InputMethodInfo&gt; getEnabledInputMethodList ()//获取已启用输入法列表 12public List&lt;InputMethodInfo&gt; getInputMethodList ()//获取输入法列表 1234567public void hideSoftInputFromInputMethod (IBinder token, int flags) //关闭/隐藏输入法软键盘区域，用户不再看到或与其交互。只能由当前激活输入法调用，因需令牌(token)验证。 参数:token 在输入法启动时提供令牌验证，验证后可对其进行操作。flags 提供额外的操作标志。当前可以为0或 HIDE_IMPLICIT_ONLY, HIDE_NOT_ALWAYS等位设置。 1234567public boolean hideSoftInputFromWindow (IBinder windowToken, int flags) //hideSoftInputFromWindow(IBinder, int, ResultReceiver)的无返回值版：从窗口上下文中确定当前接收输入的窗口，隐藏其输入法窗口 参数:windowToken 由窗口请求View.getWindowToken()返回得到的令牌(token)。flags 提供额外的操作标志。当前可以为0或 HIDE_IMPLICIT_ONLY位设置。 12345678public boolean hideSoftInputFromWindow (IBinder windowToken, int flags, ResultReceiver resultReceiver) //从窗口上下文中确定当前接收输入的窗口，要求隐藏其软键盘窗口。它可由用户调用并得到结果而不仅仅是显式要求输入法窗口隐藏。参数:windowToken 由窗口请求View.getWindowToken()返回得到的令牌(token)。flags 提供额外的操作标志。当前可以为0或 HIDE_IMPLICIT_ONLY位设置。resultReceiver 如不为空，当IME处理请求告诉你完成时调用。你收到的结果码可以是RESULT_UNCHANGED_SHOWN, RESULT_UNCHANGED_HIDDEN, RESULT_SHOWN, 或RESULT_HIDDEN。 12public void hideStatusIcon (IBinder imeToken)//隐藏状态栏图标 1234567891011121314public boolean isAcceptingText ()//当前服务视图接受全文编辑返回真。没有输入法联接为false，这时其只能处理原始按键事件。public boolean isActive (View view)//视图为当前输入的激活视图时返回真。public boolean isActive ()//输入法中的任意视图激活时返回真。public boolean isFullscreenMode ()//判断相关输入法是否以全屏模式运行。全屏时，完全覆盖你的UI时，返回真，否则返回假。public boolean isWatchingCursor (View view)//如当前输入法要看到输入编辑者的光标位置时返回真。 123456public void restartInput (View view)//如有输入法联接至视图，重启输入以显示新的内容。可在以下情况时调用此方法：视图的文字导致输入法外观变化或有按键输入流，如应用程序调用TextView.setText()时。参数:view 文字发生变化的视图。 12345678public void sendAppPrivateCommand (View view, String action, Bundle data)//对当前输入法调用 InputMethodSession.appPrivateCommand()。参数:view 可选的发送命令的视图，如你要发送命令而不考虑视图附加到输入法，此项可以为空。action 执行的命令名称。必须是作用域的名称，如前缀包名称，这样不同的开发者就不会创建冲突的命令。data 命令中包含的任何数据。 123456public void setInputMethod (IBinder token, String id)//强制切换到新输入法部件。只能由持有token的应用程序(application)或服务(service) 调用当前激活输入法。参数:token 在输入法启动时提供令牌验证，验证后可对其进行操作。id 切换到新输入法的唯一标识。 12345678public void setInputMethodAndSubtype (IBinder token, String id, InputMethodSubtype subtype)//强制切换到一个新的输入法和指定的类型。只能由持有token的应用程序(application)或服务(service) 调用当前激活输入法。参数:token 在输入法启动时提供令牌验证，验证后可对其进行操作。id 切换到新输入法的唯一标识。subtype 切换到新输入法的新类型。 12public void showInputMethodPicker ()//显示输入法菜单列表 12public void showStatusIcon (IBinder imeToken, String packageName, int iconId)//显示状态栏图标 12public void toggleSoftInput (int showFlags, int hideFlags)//切换软键盘 12345678public void toggleSoftInputFromWindow (IBinder windowToken, int showFlags, int hideFlags)//本方法切换输入法的窗口显示。如输入窗口已显示，它隐藏。如无输入窗口则显示。参数:windowToken 由窗口请求View.getWindowToken()返回得到的令牌(token)。showFlags 提供额外的操作标志。当前可以为0或 HIDE_IMPLICIT_ONLY位设置。hideFlags 提供额外的操作标志。可以是0或 HIDE_IMPLICIT_ONLY, HIDE_NOT_ALWAYS位设置。 12public void updateCursor (View view, int left, int top, int right, int bottom)//返回窗口的当前光标位置。 12public void updateExtractedText (View view, int token, ExtractedText text)//当内容变化时文本编辑器调用此方法，通知其新提取文本。 12public void updateSelection (View view, int selStart, int selEnd, int candidatesStart, int candidatesEnd)//返回当前选择区域。 12345678public boolean showSoftInput (View view, int flags, ResultReceiver resultReceiver)//如需要，显式要求当前输入法的软键盘区域向用户显示。当用户与视图交互，用户表示要开始执行输入操作时，可以调用此方法。参数:view 当前焦点视图，可接受软键盘输入。flags 提供额外的操作标志。当前可以是0或SHOW_IMPLICIT 位设置。resultReceiver 如不为空，当IME处理请求告诉你完成时调用。你收到的结果码可以是RESULT_UNCHANGED_SHOWN, RESULT_UNCHANGED_HIDDEN, RESULT_SHOWN, 或 RESULT_HIDDEN 。 1234567public boolean showSoftInput (View view, int flags)//showSoftInput(View, int, ResultReceiver)的无返回值版：如需要，显式要求当前输入法的软键盘区域向用户显示。参数:view 当前焦点视图，可接受软键盘输入。flags 提供额外的操作标志。当前可以是0或SHOW_IMPLICIT 位设置。 1234567public void showSoftInputFromInputMethod (IBinder token, int flags)//显示输入法的软键盘区域，这样用户可以到看到输入法窗口并能与其交互。只能由当前激活输入法调用，因需令牌(token)验证。参数:token 在输入法启动时提供令牌验证，验证后可对其进行操作。flags 提供额外的操作标志。可以是0或 SHOW_IMPLICIT, SHOW_FORCED位设置。 常用法调用显示系统默认的输入法方法一： 123InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);imm.showSoftInput(m_receiverView(接受软键盘输入的视图(View)),InputMethodManager.SHOW_FORCED(提供当前操作的标记，SHOW_FORCED表示强制显示)); 方法二： 123InputMethodManager imm=(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); (这个方法可以实现输入法在窗口上切换显示，如果输入法在窗口上已经显示，则隐藏，如果隐藏，则显示输入法到窗口上) 调用隐藏系统默认的输入法12345InputMethodManager imm=(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);imm.hideSoftInputFromWindow(editText.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);//(editText是一个EditText对象) 获取输入法的开关状态12345InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);boolean isOpen=imm.isActive();//isOpen若返回true，则表示输入法打开 不自动弹出键盘带有EditText控件的在第一次显示的时候会自动获得focus，并弹出键盘，如果不想自动弹出键盘，有两种方法： 法一： 在mainfest文件中把对应的activity设置 android:windowSoftInputMode=&quot;stateHidden&quot; 或者android:windowSoftInputMode=&quot;stateUnchanged&quot;。 法二： 可以在布局中放一个隐藏的TextView，然后在onCreate的时候requsetFocus。注意TextView不要设置Visiable=gone，否则会失效。 1234567891011&lt;TextView android:id="@+id/text_notuse" android:layout_width="wrap_content" android:layout_height="wrap_content" android:focusable="true" android:focusableInTouchMode="true" /&gt; TextView textView = (TextView)findViewById(R.id.text_notuse);textView.requestFocus(); 应用启动后自动打开输入法1234567891011/** * 用一个定时器控制当打开这个Activity的时候就出现软键盘 */ Timer timer=new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; InputMethodManager inputMethodManager=(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125;, 2000); 单机触发软键盘12345678/** * 当单击事件的时候触发显示软键盘 */ @Override public void onClick(View v) &#123; InputMethodManager imm=(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用@IntDef @Retention @StringDef]]></title>
    <url>%2F2020%2F06%2F01%2FAndroid%E4%B8%AD%E4%BD%BF%E7%94%A8%40IntDef%20%40Retention%20%40StringDef%2F</url>
    <content type="text"><![CDATA[在Android开发中官网不推荐使用枚举enums。占用内存多（Enums often require more than twice as much memory as static constants.）。 Android中当你的App启动后系统会给App单独分配一块内存，App的DEX code、Heap以及运行时的内存分配都会在这块内存中。 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends Activity &#123; //先定义 常量 public static final int RED = 0; public static final int GREEN = 1; public static final int BLUE = 2; //用 @IntDef "包住" 常量，这里使用@IntDef来代替Enum枚举，也可以使用@StringDef。它会像Enum枚举一样在编译时期检查变量的赋值情况！ @IntDef(&#123;RED, GREEN, BLUE&#125;) // @Retention 定义策略，是默认注解 @Retention(RetentionPolicy.SOURCE) ///表示注解所存活的时间,在运行时,而不会存在 .class 文件中 //接口定义 public @interface ColorTypes &#123;&#125; @ColorTypes int mColor = RED ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setColorType(GREEN); //声明变量，使用时需要设置一个标记 @ColorTypes int colorType = getColorType(); switch (colorType)&#123; case RED: break; case GREEN: break; case BLUE: break; default: break; &#125; &#125; public void setColorType(@ColorTypes int color) &#123; this.mColor = color; &#125; @ColorTypes public int getColorType() &#123; return mColor; &#125;&#125; 使用@StringDef 1234@StringDef(&#123; OK, ERROR &#125;) 注解生命周期 RetentionPolicy.SOURCE 源码注解，编译成.class文件后注解就不存在，用来提示开发者 RetentionPolicy.CLASS CLASS汇编注解，编译成.class文件后注解也还存在，用于自动生成代码 RetentionPolicy.RUNTIME 运行时动态注解，生命周期一直程序运行时都存在，常用于自动注入]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的滚动事件]]></title>
    <url>%2F2020%2F05%2F31%2FRecyclerView%E7%9A%84%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[滚动事件分类列表的滚动一般分为两种: 1.手指按下 -&gt; 手指拖拽列表移动 -&gt; 手指停止拖拽 -&gt; 抬起手指 2.手指按下 -&gt; 手指快速拖拽后抬起手指 -&gt; 列表继续滚动 -&gt; 停止滚动 上面的过程的状态变化如下： 1.静止 -&gt; 被迫拖拽移动 -&gt; 静止 2.静止 -&gt; 被迫拖拽移动 -&gt; 自己滚动 -&gt; 静止 监听RecyclerView的滚动两种方式： 123setOnScrollListener(OnScrollListener listener) //被淘汰addOnScrollListener(OnScrollListener listener) 其中 setOnScrollListener 由于可能出现空指针的风险，已经过时。建议用addOnScrollListener。 onScrollListener1234567public abstract static class OnScrollListener &#123; public void onScrollStateChanged(RecyclerView recyclerView, int newState)&#123;&#125; public void onScrolled(RecyclerView recyclerView, int dx, int dy)&#123;&#125;&#125; OnScrollListener类是个抽象类，有两个方法： 12void onScrollStateChanged(RecyclerView recyclerView, int newState): 滚动状态变化时回调void onScrolled(RecyclerView recyclerView, int dx, int dy): 滚动时回调 onScrollStateChanged(RecyclerView recyclerView, int newState)回调的两个变量的含义： recyclerView: 当前在滚动的RecyclerView newState: 当前滚动状态. 其中newState有三种值: 12345678910111213141516/** * The RecyclerView is not currently scrolling.（静止没有滚动） */public static final int SCROLL_STATE_IDLE = 0;/** * The RecyclerView is currently being dragged by outside input such as user touch input. *（正在被外部拖拽,一般为用户正在用手指滚动） */public static final int SCROLL_STATE_DRAGGING = 1;/** * The RecyclerView is currently animating to a final position while not under outside control. *（自动滚动） */public static final int SCROLL_STATE_SETTLING = 2; onScrolled(RecyclerView recyclerView, int dx, int dy)方法回调的三个变量含义: recyclerView : 当前滚动的view dx : 水平滚动距离 dy : 垂直滚动距离 dx &gt; 0 时为手指向左滚动,列表滚动显示右面的内容dx &lt; 0 时为手指向右滚动,列表滚动显示左面的内容dy &gt; 0 时为手指向上滚动,列表滚动显示下面的内容dy &lt; 0 时为手指向下滚动,列表滚动显示上面的内容 canScrollVertically和canScrollHorizontally方法1234567public boolean canScrollVertically (int direction)这个方法是判断View在竖直方向是否还能向上，向下滑动。其中，direction为 -1 表示手指向下滑动（屏幕向上滑动）， 1 表示手指向上滑动（屏幕向下滑动）。public boolean canScrollHorizontally (int direction)这个方法用来判断 水平方向的滑动@param direction为 -1 表示手指向左滑动， 1 表示手指向右滑动 例如：RecyclerView.canScrollVertically(1)的值表示是否能向下滚动,false表示已经滚动到底部RecyclerView.canScrollVertically(-1)的值表示是否能向上滚动，false表示已经滚动到顶部 两种判断是否到底部的方法方法一如果 当前 第一个可见item的位置 + 当前可见的item个数 &gt;= item的总个数 这样就可以判断出来，是在底部了。 1234567891011121314151617181920212223loadingMoreListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); if (dy &gt; 0) //向下滚动 &#123; int visibleItemCount = mLinearLayoutManager.getChildCount(); int totalItemCount = mLinearLayoutManager.getItemCount(); int pastVisiblesItems = mLinearLayoutManager.findFirstVisibleItemPosition(); if (!loading &amp;&amp; (visibleItemCount + pastVisiblesItems) &gt;= totalItemCount) &#123; loading = true; loadMoreDate(); &#125; &#125; &#125;&#125;; 通过 visibleItemCount + pastVisiblesItems &gt;= totalItemCount 来判断是否是底部。 方法二通过canScrollVertically 来判断 123456789101112131415161718192021222324252627loadingMoreListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if(!loading &amp;&amp; !recyclerView.canScrollVertically(1))&#123; loading = true; loadMoreDate(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy);// if (dy &gt; 0) //向下滚动// &#123;// int visibleItemCount = mLinearLayoutManager.getChildCount();// int totalItemCount = mLinearLayoutManager.getItemCount();// int pastVisiblesItems = mLinearLayoutManager.findFirstVisibleItemPosition();//// if (!loading &amp;&amp; (visibleItemCount + pastVisiblesItems) &gt;= totalItemCount) &#123;// loading = true;// loadMoreDate();// &#125;// &#125; &#125;&#125;;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drawable学习]]></title>
    <url>%2F2020%2F05%2F27%2FDrawable%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Drawable是什么 一种可以在Canvas上进行绘制的抽象的概念 颜色、图片等都可以是一个Drawable Drawable可以通过XML定义，或者通过代码创建 Android中Drawable是一个抽象类，每个具体的Drawable都是其子类 优点： 使用简单，比自定义View成本低 非图片类的Drawable所占空间小，能减小apk大小 Drawable的内部宽/高 一般getIntrinsicWidth/Height能获得内部宽/高 图片Drawable其内部宽高就是图片的宽高 颜色Drawable没有内部宽高的概念 内部宽高不等同于它的大小，一般Drawable没有大小概念(作为View背景时，会被拉伸至View的大小) 分类可见有很多种类，我们只需要了解几种常用的即可。 常用分类BitmapDrawable的作用和使用 表示一种图片，可以直接引用原始图片或者通过XML进行描述 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@color/colorPrimary" android:antialias="true" android:dither="true" android:filter="true" android:gravity="center" android:mipMap="false" android:tileMode="disabled" /&gt; 属性： gravity属性详情 NinePatchDrawable(.9图片)的作用 自动根据宽高进行缩放且不会失真 实际使用，可以直接引用图片或者通过XML描述 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;nine-patch xmlns:android="http://schemas.android.com/apk/res/android" android:src="@color/colorPrimary" android:antialias="true" android:dither="true" android:filter="true" android:gravity="center" android:mipMap="false" android:tileMode="disabled" /&gt; ShapeDrawable的作用 通过颜色构造的图形 可以是纯色的图形 也可以是有渐变效果的图形 shape标签创建的Drawable实体是GradientDrawable 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:radius="10dp" android:topLeftRadius="10dp" android:topRightRadius="10dp" android:bottomLeftRadius="10dp" android:bottomRightRadius="10dp"/&gt; &lt;gradient android:angle="45" android:centerX="30" android:centerY="30" android:centerColor="@color/colorAccent" android:endColor="@color/colorPrimary" android:startColor="@color/colorPrimaryDark" android:gradientRadius="20" android:type="linear" android:useLevel="true" /&gt; &lt;padding android:left="10dp" android:top="10dp" android:right="10dp" android:bottom="10dp" /&gt; &lt;size android:width="200dp" android:height="200dp" /&gt; &lt;solid android:color="@color/colorPrimary"/&gt; &lt;stroke android:width="10dp" android:color="@color/colorAccent" android:dashWidth="5dp" android:dashGap="3dp"/&gt;&lt;/shape&gt; ShapeDrawable的属性介绍 LayerDrawable的作用 XML标签为layer-list 层次化的Drawable合集 可以包含多个item，每个item表示一个Drawable item中可以通过android:drawable直接引用资源 android:top等表示Drawable相当于View上下左右的偏移量 微信文本输入框 在drawable目录下创建一个layer_list.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- 前景层--&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="#0ac39e" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 第二层，当前drawable为一个纯白色，相对view底部6dp外间距。--&gt; &lt;item android:bottom="6dp"&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 第三层，当前drawable为一个纯白色，相对view下，左，右各1dp的外间距。--&gt; &lt;item android:bottom="1dp" android:left="1dp" android:right="1dp"&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; 在布局中使用 1234567&lt;EditText android:layout_width="match_parent" android:layout_height="50dp" android:background="@drawable/layer_list" android:paddingLeft="5dp" android:paddingRight="5dp" android:text="文本框" /&gt; 效果 StateListDrawable的使用和要点 对应于selector标签 用于View根据状态选择不同的Drawable 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize="false" //StateListDrawable的固有大小是否根据状态而改变，默认false=根据状态而改变 android:dither="true" //是否开启抖动-让高质量图片在低质量屏幕上依旧效果好，默认true开启 android:variablePadding="false" //padding是否根据状态的改变而改变，不建议开启(false) &gt; &lt;item android:state_pressed="true" //Button被按下后却没有松开的状态 android:drawable="@color/colorAccent"/&gt; &lt;item android:state_focused="true" //View获取了焦点 android:drawable="@color/colorPrimary"/&gt; &lt;item android:state_selected="true" //用户选择了View android:drawable="@color/colorPrimary"/&gt; &lt;item android:state_checked="true" //用户选中了View，一般用于CheckBox这类在选中和没有选中状态之间切换的View android:drawable="@drawable/ic_launcher_background"/&gt; &lt;item android:state_enabled="true" //View处于可用状态 android:drawable="@drawable/ic_launcher_foreground"/&gt; &lt;item android:drawable="#FFFFFF"/&gt; //默认Drawable: 按顺序向下匹配，需要放在最下方，因为可以匹配任何状态&lt;/selector&gt; LevelListDrawable的作用 对应于level-list标签 拥有多个item，每个item都有maxLevel和minLevel Level的范围为0~10000 给定level后，会按从上至下的顺序匹配，直到找到范围合适的Drawable，并返回 item的level一定要降序或者升序 调用View的getBackground获得Drawable对象，并调用setLevel设置等级level ImageView的setImageLevel()能快速指定src引用的Drawable的Level LevelListDrawable是根据level改变，选择不同的Drawable，能用于实现进度条、音量调节等等 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:minLevel="0" android:maxLevel="10" android:drawable="@drawable/d1" /&gt; &lt;item android:minLevel="11" android:maxLevel="20" android:drawable="@drawable/d2" /&gt; &lt;item android:minLevel="21" android:maxLevel="30" android:drawable="@drawable/d3" /&gt; &lt;item android:minLevel="31" android:maxLevel="40" android:drawable="@drawable/d4" /&gt;&lt;/level-list&gt; TransitionDrawable的作用 对应于transition标签 实现两个Drawable之间的淡入淡出效果 获得背景的TransitionDrawable后，通过startTransition和reverseTransition方法实现效果和逆过程 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/transition_drawable" android:drawable="@drawable/ic_launcher" android:top="10dp" //四周的偏移量 android:bottom="10dp" android:right="10dp" android:left="10dp"/&gt; &lt;item android:drawable="@drawable/ic_launcher_round" /&gt;&lt;/transition&gt; InsetDrawable的作用和使用 对应inset标签 将其他Drawable内嵌到自身，并在四周留出间距 View需要背景比自己实际区域要小的时候，可以使用inset，layer-list也可以实现该需求 1234567&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/ic_launcher" android:insetTop="10dp" android:insetBottom="10dp" android:insetLeft="10dp" android:insetRight="10dp"&gt;&lt;/inset&gt; ScaleDrawable的作用 对应于scale标签 根据自己的等级level(0~10000)将指定的Drawable缩放到一定比例 android:scaleHeight=”70%”用于指定宽高的缩放比例=为原来的30% ScaleDrawable的level为0，不可见。为10000时，不缩放。 一般将level设置为1，就会按照属性指定的比例缩放。其他值也会改变缩放效果。 android:scaleGravity属性和gravity属性完全一致 123456&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/ic_launcher" android:scaleGravity="center" android:scaleHeight="70%" android:scaleWidth="70%"&gt;&lt;/scale&gt; ClipDrawable的作用 对应于clip标签 根据自己当前的等级level(0~10000)来裁剪另一个Drawable 裁剪方向由clipOrientation和gravity属性共同控制 level为0，Drawable不可见；10000表示不裁剪；为8000，表示裁减了2000；为1，表示裁剪了9999 ClipDrawable的gravity AnimationDrawable的作用 对应于animation-list标签 用于实现逐帧动画效果 android:oneShot决定是循环播放还是播放一次，false：循环播放 item中设置一帧一帧的Drawable以及持续时间 AnimationDrawable的setOneShot(boolean flag) 和android:oneShot配置一样 addFrame (Drawable frame, int duration) 动态的添加一个图片进入该动画中 stop()和start()用于停止和开始/继续播放，停止时会停留在当前一帧上 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/shake_anim_01" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_02" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_03" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_04" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_05" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_06" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_07" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_08" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_09" android:duration="100"/&gt; &lt;item android:drawable="@drawable/shake_anim_10" android:duration="100"/&gt;&lt;/animation-list&gt; 在代码中定义出AnimationDrawable对象，并设置到view的background上，然后设置开始播放就可以 123val animationDrawable = resources.getDrawable(R.drawable.animationdrawable) as AnimationDrawableiv.setBackgroundDrawable(animationDrawable)animationDrawable.start() //开始播放 ShapeDrawable的OvalShape、RectShape、ArcShape和PaintDrawable的作用和使用 1.用于获得有shape形状的drawable(椭圆、长方形、扇形以及更为通用PaintDrawable-具有圆角和边界) 123456789101112131415161718192021222324252627282930 * 一个继承自ShapeDrawable更为通用的Drawable：具有圆角 *====================================================*/PaintDrawable drawable3 = new PaintDrawable(Color.GREEN);drawable3.setCornerRadius(30);findViewById(R.id.textView3).setBackgroundDrawable(drawable3);/**============================================ * 通过Shape构造出相应的ShapeDrawable *=============================================*///椭圆形形状 : shape赋予ShapeDrawableOvalShape ovalShape = new OvalShape();ShapeDrawable drawable1 = new ShapeDrawable(ovalShape);drawable1.getPaint().setColor(Color.BLUE);drawable1.getPaint().setStyle(Paint.Style.FILL);findViewById(R.id.textView1).setBackgroundDrawable(drawable1);//矩形形状 : shape赋予ShapeDrawableRectShape rectShape = new RectShape();ShapeDrawable drawable2 = new ShapeDrawable(rectShape);drawable2.getPaint().setColor(Color.RED);drawable2.getPaint().setStyle(Paint.Style.FILL);findViewById(R.id.textView2).setBackgroundDrawable(drawable2);//扇形、扇面形状 : shape赋予ShapeDrawable//顺时针,开始角度30， 扫描的弧度跨度180ArcShape arcShape = new ArcShape(30, 180);ShapeDrawable drawable4 = new ShapeDrawable(arcShape);drawable4.getPaint().setColor(Color.YELLOW);drawable4.getPaint().setStyle(Paint.Style.FILL);findViewById(R.id.textView4).setBackgroundDrawable(drawable4); 自定义Drawable概况 一般作为ImageView的图像来显示 另一个是作为View的背景 自定义Drawable主要就是实现draw方法 setAlpha、setColorFilter、getOpacity也需要重写，但是模板固定 当自定义Drawable有固定大小时(比如绘制一张图片)，需要重写getIntrinsicWidth()/getIntrinsicHeight()方法(默认返回-1)，会影响到View的wrap_content布局 内部固定大小不等于Drawable的实际区域大小，getBounds能获得实际区域大小 自定义Drawable模板代码123456789101112131415161718192021222324252627class CustomDrawable(color: Int) : Drawable()&#123; var mPaint: Paint init &#123; mPaint = Paint(Paint.ANTI_ALIAS_FLAG) mPaint.color = color &#125; override fun draw(canvas: Canvas) &#123; val rect = bounds canvas.drawCircle(rect.exactCenterX(), rect.exactCenterY(), Math.min(rect.exactCenterX(), rect.exactCenterY()), mPaint) &#125; override fun setAlpha(alpha: Int) &#123; mPaint.alpha = alpha invalidateSelf() &#125; override fun setColorFilter(colorFilter: ColorFilter?) &#123; mPaint.colorFilter = colorFilter invalidateSelf() &#125; override fun getOpacity(): Int &#123; //not sure, so be safe return PixelFormat.TRANSLUCENT &#125;&#125; SVG矢量图SVG？ 可伸缩矢量图(Android 5.0推出) 定义用于网络的基于矢量的图形(在Web上应用非常广泛) 使用XML格式定义图形 图像缩放不会影响质量 万维网联盟标准(与DOM和XSL之类的W3C标准是一个整体） SVG和Bitmap的区别 SVG是一个绘图标准。 Bitmap是通过每个像素点上存储色彩信息来表示图像。 SVG放大不会失真, Bitmap会失真。 Bitmap需要为不同分辨率设计多套图表，SVG绘制一张图就能适配不同分辨率。 静态矢量图SVG-VectorDrawable 基于XML的静态矢量图 采用标签vector vector中path是最小单位，创建SVG-用指令绘制SVG图形 vector中group将不同path组合起来 VectorDrawable的vector标签有哪些属性12345678910111213141516&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="200dp" // SVG的具体大小 android:height="200dp" android:viewportWidth="100" //将宽度分为多少份，与path配合(50份等于100dp) 比如上面的代码，将200dp划分100份，如果在绘图中使用坐标（50,50），则意味着该坐标为正中间 android:viewportHeight="100"&gt; &lt;group&gt; //将不同`path`组合起来 &lt;path //SVG树形结构的最小单位，用指令绘制SVG图形 android:name="path1" //该path的名称 android:pathData="M 20,80 L 50,80 80,80" android:strokeColor="@color/colorAccent" android:strokeWidth="3" android:strokeLineCap="round"/&gt; &lt;path .../&gt; &lt;/group&gt;&lt;/vector&gt; VectorDrawable的path标签的全部指令 坐标轴以(0, 0)为中心， X轴水平向右， Y轴水平向下 指令大写-绝对定位，参考全局坐标系；指令小写-相对定位，参考父容器坐标系 指令和数据间空格可以省略 同一指令出现多次，可以只用一个。 A的参数：RX/RY：椭圆半轴大小 XROTATION：椭圆X轴与水平方向顺时针方向夹角 FLAG1：1-大角度弧线 0-小角度弧线 FLAG2：起点到终点的方向，1-顺时针，2-逆时针 X/Y：终点坐标 VectorDrawable实例12345678910111213141516171819//1. 使用`vector`标签定义矢量图VectorDrawable(ic_black_24dp.xml)&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="24dp" android:height="24dp" android:viewportWidth="24.0" android:viewportHeight="24.0"&gt; &lt;group android:name="test"&gt; //该组的名称：可以在AnimatedVectorDrawable中指定动画效果 &lt;path android:fillColor="#FF000000" android:pathData="M12,6c1.11,0 2,-0.9 2,-2 0,-0.38 -0.1,-0.73 -0.29,-1.03L12,0l-1.71,2.97c-0.19,0.3 -0.29,0.65 -0.29,1.03 0,1.1 0.9,2 2,2zM16.6,15.99l-1.07,-1.07 -1.08,1.07c-1.3,1.3 -3.58,1.31 -4.89,0l-1.07,-1.07 -1.09,1.07C6.75,16.64 5.88,17 4.96,17c-0.73,0 -1.4,-0.23 -1.96,-0.61L3,21c0,0.55 0.45,1 1,1h16c0.55,0 1,-0.45 1,-1v-4.61c-0.56,0.38 -1.23,0.61 -1.96,0.61 -0.92,0 -1.79,-0.36 -2.44,-1.01zM18,9h-5L13,7h-2v2L6,9c-1.66,0 -3,1.34 -3,3v1.54c0,1.08 0.88,1.96 1.96,1.96 0.52,0 1.02,-0.2 1.38,-0.57l2.14,-2.13 2.13,2.13c0.74,0.74 2.03,0.74 2.77,0l2.14,-2.13 2.13,2.13c0.37,0.37 0.86,0.57 1.38,0.57 1.08,0 1.96,-0.88 1.96,-1.96L20.99,12C21,10.34 19.66,9 18,9z"/&gt; &lt;/group&gt;&lt;/vector&gt;//2. 使用矢量图&lt;ImageView android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:src="@drawable/ic_black_24dp"/&gt; 矢量图动画-AnimatedVectorDrawableAnimatedVectorDrawable的作用是给VectorDrawable提供动画效果，Google的工程师将AnimatedVectorDrawable比喻一个胶水，通过AnimatedVectorDrawable来连接静态的VectorDrawable和动态的objectAnimator。 针对静态矢量图-VectorDrawable来做动画 xml标签为animated-vector 在target子标签下指明VectorDrawable的名字(都是android:name=”…”属性指明)，并指定动画效果android:animation=”@animator/…” AnimatedVectorDrawable中指明的target和name属性，必须与VectorDrawable中需要的name保持一致，这样系统能找到找到要实现的动画元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//1. 静态矢量图-VectorDrawable(vector_two_line.xml)&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="200dp" android:height="200dp" android:viewportWidth="100" android:viewportHeight="100"&gt; &lt;group&gt; &lt;path android:name="path1" //路径1的名称 android:pathData="M 20,80 L 50,80 80,80" android:strokeColor="@color/colorAccent" android:strokeWidth="3" android:strokeLineCap="round"/&gt; &lt;path android:name="path2" //路径2的名称 android:pathData="M 20,20 L 50,20 80,20" android:strokeColor="@color/colorAccent" android:strokeWidth="3" android:strokeLineCap="round"/&gt; &lt;/group&gt;&lt;/vector&gt;//2. 轨迹动画效果-属性动画ObjectAnimator(res/animator/trimpath_animator)&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:propertyName="trimPathEnd" android:valueFrom="0" android:valueTo="1" android:valueType="floatType" android:interpolator="@android:interpolator/accelerate_decelerate"&gt;&lt;/objectAnimator&gt;//3. 粘合静态SVG和属性动画：AnimatedVectorDrawable(vector_trimpath_anim.xml)&lt;animated-vector xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/vector_two_line"&gt; //静态SVG &lt;target android:animation="@animator/trimpath_animator" //属性动画 android:name="path1"&gt; //静态SVG中路径1的名称 &lt;/target&gt; &lt;target android:animation="@animator/trimpath_animator" //属性动画 android:name="path2"&gt; //静态SVG中路径2的名称 &lt;/target&gt;&lt;/animated-vector&gt;//4. 布局中使用AnimatedVectorDrawable&lt;ImageView android:id="@+id/imageview" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:src="@drawable/vector_trimpath_anim"/&gt; //动画矢量图 开启动画12val drawable = imageview.drawable(drawable as Animatable).start()]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios学习]]></title>
    <url>%2F2020%2F05%2F27%2Faxios%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[为什么要用axios axios的基本使用 get，获取数据 post，提交数据（表单提交以及文件上传） put，更新数据 （提交所有的数据） patch，提交数据 （提交修改的数据） delete，删除数据 1.get的使用12345axios(&#123; method: 'get', url: '', params: &#123;&#125;&#125;).then(res =&gt; &#123; do something &#125;) 或者简写为： 1axios.get(url, params).then(res =&gt; &#123; do something &#125;) params会出现在请求头中的querry string parameters中，并且会出现在浏览器的地址栏中，即会拼接到url中。 2.post方法的使用post的请求头中会有一个content-type，该字段有两个值，一个为form-data，一般用于表单提交（文件上传，图片上传等等）；另一个是application/json即，传递的是json数据。 12345axios(&#123; method: 'post', url: '', data: &#123;&#125;&#125;).then(res =&gt; &#123; do something &#125;) 或者写别名方法： 1axios.post(url, data).then(res =&gt; &#123; do something &#125;) 如果需要传递的是form-data，那么我们需要先实例化一个FormData，然后将data指向form-data即可 3.delete的使用方法12345axios(&#123; method: 'delete', url: '', params: &#123;&#125;&#125;).then(res =&gt; &#123; do something &#125;) config的第三个字段可以为params，这样参数会拼接在url中，如果我们不想使之出现在url中，我们只需要将params替换为data。 并发请求同时进行多个请求，并统一处理返回值，如果在某些场景中我们需要同时依赖两个接口返回的数据，那么我们可以使用并发请求。 axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2 12345678axios.all([ // 这里的参数是一个数组，里面包含了axios请求 axios.get('url1'), // 请求的先后顺序就是代码中的顺序 axios.get('url2')]).then( axios.spread((res1, res2) =&gt; &#123; // spread用来分割返回值 console.log(res1, res2) &#125;) axios深入创建axios实例12345678910111213// axios实例化let api = axios.create(&#123; baseURL: 'localhost:8080', // 请求的域名 timeout: 1000, // 设置请求的超时时长，超过时长报401超时 method: 'get,post', headers: &#123; // 设置请求头 token: '' &#125;, params: &#123;&#125;, data: &#123;&#125;&#125;)// 使用axios实例api.get('/data.json') axios配置 全局配置，例如axios.defaults.timeout = 1000 实例配置, 在创建axios实例时传入的配置，如果不传实例配置就会使用全局配置 请求配置，在使用axios请求时，可以单独传入新的配置 常见配置 这三种配置的优先级为：请求配置 &gt; 实例配置 &gt; 全局配置 axios拦截器请求拦截器： 1234axios.interceptors.request.use( config =&gt; &#123;&#125;, // 在发送请求前的一些处理逻辑 err =&gt; &#123;&#125; // 在请求错误后的处理) 响应拦截器： 1234axios.interceptors.response.use( res =&gt; &#123; return res &#125;, // 请求成功后对响应数据做一定的处理 err =&gt; &#123; return Promis.reject(err)&#125; // 在响应错误后的处理，可以用catch捕捉) 拦截器可以做到的事请求拦截： 请求拦截中错误拦截较少，通常都是配置相关的拦截可能的错误比如请求超时，可以将页面跳转到一个错误页面中。 响应拦截： 响应的成功拦截中，主要是对数据进行过滤。 响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面 axios错误处理一般来说，如果我们在调用接口时请求错误或者响应错误，程序处理流程都会进入到catch代码块中，例如： 123axios.get('/data.json').then(callback).catch(err =&gt; &#123; console.log(err)&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2020%2F05%2F26%2Fvuex%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[了解Vuexvuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension ，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 官网https://vuex.vuejs.org/zh/ 安装1npm install vuex --save 引入1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 说明每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 最简单的store让我们来创建一个简单的store: 首先，我们需要在某个地方存放我们的Vuex代码： 这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件 在index.js文件中写入如下代码 1234567891011121314151617import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ //改变count的状态 &#125; &#125;&#125;)export default store //导出对象 其次，我们让所有的Vue组件都可以使用这个store对象 来到main.js文件，导入store对象，并且放在new Vue中 这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了 单页面的状态管理如下图，在单个组件中进行状态管理是一件非常简单的事情： State：不用多说，就是我们的状态。 View：视图层，可以针对State的变化，显示不同的信息。 Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。 看一个简单的单界面状态管理的例子 多界面状态管理看一张官方的图 来重新实现一下上面的计数器案例 使用步骤小结我们来对使用步骤，做一个简单的小结： 1.提取出一个公共的store对象，用于保存在多个组件中共享的状态 2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到 3.在其他组件中使用store对象中保存的状态即可 通过this.$store.state属性的方式来访问状态 通过this.$store.commit(&#39;mutation中方法&#39;)来修改状态 注意事项： 我们通过提交mutation的方式，而非直接改变store.state.count。 这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。 Vuex核心概念Vuex有几个比较核心的概念 State Getters Mutation Action Module State单一状态树Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT )”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 Getters基本使用有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中： 获取学生年龄大于20的个数： 我们可以在Store中定义getters 通过属性访问： Getter 接受 state 作为其第一个参数： 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getter 也可以接受其他 getter 作为第二个参数： 123456getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125; 我们可以很容易地在任何组件中使用它： 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。 通过方法访问： 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 123456789getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;//调用store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125; 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。 Mutation状态更新Vuex的store状态的更新唯一方式：提交Mutation Mutation主要包括两部分： 字符串的事件类型（type） 一个回调函数（handler）,该回调函数的第一个参数就是state。 定义示例： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; //声明了一个 increment 事件 // 变更状态 state.count++ &#125; &#125;&#125;) 通过mutation更新 在自定义方法methods中，提交 在mutations中声明的事件 123increment: function() &#123; this.$store.commit('increment') // &#125; mutation传递参数 在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数，参数被称为是mutation的载荷(Payload) 123456789// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;//调用store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： 1234567891011// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;//调用store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式 1234567891011store.commit(&#123; type: 'increment', amount: 10&#125;)//mutation中声明方法和前面一致mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; Mutation 需遵守 Vue 的响应规则 既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加 新属性 时，你应该 使用 Vue.set(obj, &#39;newProp&#39;, 123), 或者 以新对象替换老对象。例如，利用对象展开运算符 我们可以这样写： 1state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代 Mutation 事件类型 问题：在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况. 如何避免上述的问题呢?在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然. 具体做法： 我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称. 12// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION' 123456789101112131415// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types' const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) //或者导入全部的常量 import * as types from…… 使用时直接 [types.SOME_MUTATION] Mutation同步函数 通常情况下, Vuex要求我们Mutation中的方法必须是同步方法. 主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照. 但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成. ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 解析：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; Action的分发： 在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Actions 支持同样的载荷方式和对象方式进行分发： 12345678910// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) Moudle Module是模块的意思, 为什么在Vuex中我们要使用模块呢? Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理. 当应用变得非常复杂时,store对象就有可能变得相当臃肿. 为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等 12345678910111213141516171819202122const moduleA = &#123; state: () =&gt; (&#123; ... &#125;), mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: () =&gt; (&#123; ... &#125;), mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态 模块内部的mutation和getter，接收的第一参数（state）是模块的局部状态对象,rootState 1234567891011121314151617181920212223const moduleA = &#123; state: &#123; count: 0&#125;, mutations: &#123; increment (state) &#123; // state是模块的局部状态，也就是上面的state state.count++ &#125; &#125;, getters: &#123; doubleCount (state, getters, rootState) &#123; // 参数 state为当前局部状态，rootState为根节点状态 return state.count * 2 &#125; &#125;, actions: &#123; incremtnIfOddRootSum ( &#123; state, commit, rootState &#125; ) &#123; // 参数 state为当前局部状态，rootState为根节点状态 if ((state.cont + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125; &#125;&#125; 命名空间 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: () =&gt; (&#123; ... &#125;), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: () =&gt; (&#123; ... &#125;), getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: () =&gt; (&#123; ... &#125;), getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router详解]]></title>
    <url>%2F2020%2F05%2F24%2Fvue-router%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[认识 vue-router vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。 我们可以访问其官方网站对其进行学习: https://router.vuejs.org/zh/ vue-router是基于路由和组件的： 路由用于设定访问路径, 将路径和组件映射起来。 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换。 安装和使用 vue-router安装vue-router1npm install vue-router --save 在模块化工程中使用 第一步：导入路由对象，并且调用 Vue.use(VueRouter) 第二步：创建路由实例，并且传入路由映射配置 第三步：在Vue实例中挂载创建的路由实例 1234import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; Vue.use(VueRouter) 使用 vue-router 的步骤 第一步: 创建路由组件 第二步: 配置路由映射: 组件和路径映射关系 第三步: 使用路由: 通过&lt;router-link&gt;和&lt;router-view&gt; 操作演示创建 router 实例 挂载到Vue实例中 创建路由组件 配置组件和路径的映射关系 使用路由 说明： &lt;router-link&gt;: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个&lt;a&gt;标签. &lt;router-view&gt;: 该标签会根据当前的路径, 动态渲染出不同的组件. 网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和&lt;router-view&gt;处于同一个等级.在路由切换时, 切换的是&lt;router-view&gt;挂载的组件, 其他内容不会发生改变. 效果 设置路由的默认路径需求：默认情况下, 进入网站的首页, 我们希望&lt;router-view&gt;渲染首页的内容.但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以. 问题：如何可以让路径默认跳到到首页, 并且&lt;router-view&gt;渲染首页组件呢? 方案：多配置一个映射 配置解析： 我们在routes中又配置了一个映射. path配置的是根路径: / redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了 History 模式History模式：路径显示中不含 # （vue默认路径显示方式为hash模式，路径中带有#，可以参考上面的运行截图） 如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可: 效果： router-link 补充一些属性tag: 可以指定&lt;router-link&gt;之后渲染成什么组件, 比如下面的代码会被渲染成一个&lt;li&gt;元素, 而不是&lt;a&gt; 1&lt;router-link to='/home' tag='li'&gt; replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中 active-class: 当&lt;router-link&gt;对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称。在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.但是通常不会修改类的属性, 会直接使用默认的router-link-active即可. 该class具体的名称也可以通过router实例的属性进行修改： 可以看到 后面第二个class的名称变成了 active 路由代码跳转有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了比如, 我们将代码修改如下: 动态路由在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：/user/zhangsan或/user/lisi除了有前面的/user之外，后面还跟上了用户的ID，这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。 方式： 1path: &apos;/user/:id&apos; 懒加载官方解释：当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了 懒加载做了什么？ 路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块. 只有在这个路由被访问到的时候, 才加载对应的组件 方式在ES6中, 我们有更加简单的写法： 1const Home = () =&gt; import(&apos;../components/home.vue&apos;) 效果 嵌套路由概述嵌套路由是一个很常见的功能 比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容. 一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件. 路径和组件关系如下： 步骤 创建对应的子组件, 并且在路由映射中配置对应的子路由. 在组件内部使用&lt;router-view&gt;标签. 使用演示创建home页面的两个字组件页面 message 页面 和 news 页面 因为创建的两个组件是home下的，因此在配置路径时，为home添加children属性，并在children内配置message和news的路径（不加 斜杠 /），如下 在home页面配置字组件的路由连接和显示 通过 &lt;router-link&gt;和 &lt;router-view&gt;标签 效果 嵌套路由默认路径配置示意如下： 传递参数方式 params的类型: 配置路由格式: /router/:id 传递的方式: 在path后面跟上对应的值 传递后形成的路径: /router/123, /router/abc query的类型: query是对象的形式，变量 key-value 方式存在 配置路由格式: /router, 也就是普通配置 传递的方式: 对象中使用query的key作为传递方式 传递后形成的路径: /router?id=123, /router?id=abc 示例： 12345// params 类型 to 绑定的相当于一个字符串&lt;router-link :to=&quot;&apos;/user/&apos;+userId&quot;&gt;用户&lt;/router-link&gt; //query 类型 to 绑定的相当于一个对象，对象内有两个变量 path 和 query，并且query也是对象的形式&lt;router-link :to=&quot;&#123;path: &apos;/profile&apos;,query: &#123;name: &apos;zx&apos;,id: userId&#125;&#125;&quot;&gt;档案&lt;/router-link&gt; 使用使用也有两种方式： &lt;router-link&gt;的方式 JavaScript代码方式 操作演示 - &lt;router-link&gt; 方式先创建一个新的组件Profile.vue，并配置好路由映射 配置router-link 可以明显看出，和 params 方式的不同之处：params 操作演示 JavaScript方式也是很简单，调用this.$router.push() 里面传入一个对象即可，对象包含两个变量 一个path，一盒query 获取传递的参数 获取 params 方式传递的参数： 1$route.params 获取 query 方式传递的参数: 1234//获取整个query对象$route.query//获取query对象中的某个key的value值$route.query.name 获取参数通过$route对象获取的，在使用了vue-router 的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新。获取传递的信息如下: $route和$router的区别 $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法 $route为当前router跳转对象里面可以获取name、path、query、params等 导航守卫官网https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90 vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发. beforeEach12345router.beforeEach((to, from, next) =&gt; &#123; //to and from are Route Object,next() must be called to resolve the hook&#125; window.document.title = to.meta.title next()&#125;) 导航钩子的三个参数解析: to: 即将要进入的目标的路由对象。 from: 当前导航即将要离开的路由对象。 next: 调用该方法后, 才能进入下一个钩子. 该方法必须调用，否则无法完成正常跳转。 next的几种使用： next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 afterEach123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 简单示例：beforeEach改变页面标题 路由独享守卫上面我们使用的导航守卫, 被称之为全局守卫. 可以在路由配置上直接定义 beforeEnter 守卫： 这些守卫与全局前置守卫的方法参数是一样的。 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内的守卫可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave 123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 12345678beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; next() &#125; else &#123; next(false) &#125;&#125; keep-alive keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。它有两个非常重要的属性: include - 字符串或正则表达，只有匹配的组件会被缓存 exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存 router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存： 1234//取消缓存某个组件,注意exclude后面的多个组件名之间不能有空格&lt;keep-alive exclude=&quot;Profile,User&quot;&gt; &lt;router-view/&gt;&lt;/keep-alive&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础语法]]></title>
    <url>%2F2020%2F05%2F19%2FVue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础语法Mustache将data中的文本数据，插入到HTML中 v-once该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变 v-html某些情况下，我们从服务器请求到的数据本身就是一个HTML代码，如果我们直接通过 1&#123;&#123;&#125;&#125; 来输出，会将HTML代码也一起输出。但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染 v-textv-text作用和Mustache比较相似：都是用于将数据显示在界面中，v-text通常情况下，接受一个string类型 v-prev-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法,比如下面的代码：第一个h2元素中的内容会被编译解析出来对应的内容第二个h2元素中会直接显示 1&#123;&#123;message&#125;&#125; v-bind概述v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(后面学)在开发中，有哪些属性需要动态进行绑定呢？还是有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等比如通过Vue实例中的data绑定元素的src和href，代码如下： 语法糖v-bind有一个对应的语法糖，也就是简写方式。在开发中，我们通常会使用语法糖的形式，因为这样更加简洁 简写方式如下：（一个冒号） v-bind绑定class 很多时候，我们希望动态的来切换class，比如：当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。 绑定class有两种方式： 对象语法 数组语法 对象语法 对象语法的含义是:class后面跟的是一个对象，有下面这些用法： 用法一：直接通过{}绑定一个类 1&lt;h2 :class="&#123;'active': isActive&#125;"&gt;Hello World&lt;/h2&gt; 用法二：也可以通过判断，传入多个值 1&lt;h2 :class="&#123;'active': isActive, 'line': isLine&#125;"&gt;Hello World&lt;/h2&gt; 用法三：和普通的类同时存在，并不冲突 注：如果isActive和isLine都为true，那么会有title/active/line三个类 1&lt;h2 class="title" :class="&#123;'active': isActive, 'line': isLine&#125;"&gt;Hello World&lt;/h2&gt; 用法四：如果过于复杂，可以放在一个methods或者computed中 注：classes是一个计算属性 1&lt;h2 class="title" :class="classes"&gt;Hello World&lt;/h2&gt; 数组语法 数组语法的含义是:class后面跟的是一个数组，有下面这些语法： 用法一：直接通过{}绑定一个类 1&lt;h2 :class="['active']"&gt;Hello World&lt;/h2&gt; 用法二：也可以传入多个值 1&lt;h2 :class=“[‘active’, 'line']"&gt;Hello World&lt;/h2&gt; 用法三：和普通的类同时存在，并不冲突 注：会有title/active/line三个类 1&lt;h2 class="title" :class=“[‘active’, 'line']"&gt;Hello World&lt;/h2&gt; 用法四：如果过于复杂，可以放在一个methods或者computed中 注：classes是一个计算属性 1&lt;h2 class="title" :class="classes"&gt;Hello World&lt;/h2&gt; v-bind绑定style 我们可以利用v-bind:style来绑定一些CSS内联样式。 在写CSS属性名的时候，比如font-size,我们可以使用驼峰式 (camelCase) fontSize ;或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’ 绑定class有两种方式： 对象语法 数组语法 对象语法 1:style="&#123;color: currentColor, fontSize: fontSize + 'px'&#125;" style后面跟的是一个对象类型 对象的key是CSS属性名称 对象的value是具体赋的值，值可以来自于data中的属性 数组语法 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; style后面跟的是一个数组类型 多个值以 ，分割即可 计算属性概念我们知道，在模板中可以直接通过插值语法显示一些data中的数据。但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示。比如我们有firstName和lastName两个变量，我们需要显示完整的名称。但是如果多个地方都需要显示完整的名称，我们就需要写多个 我们可以将上面的代码换成计算属性： 计算属性是写在实例的computed选项中 计算属性的缓存我们可能会考虑这样的一个问题： methods和computed看起来都可以实现我们的功能，那么为什么还要多一个计算属性这个东西呢？ 原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。 v-on概述在前端开发中，我们需要经常和用于交互。这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等。在Vue中如何监听事件呢？使用v-on指令 语法糖v-on:click可以写成@click v-on参数当通过methods中定义方法，以供@click调用时，需要注意参数问题： 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。 v-on修饰符在某些情况下，我们拿到event的目的可能是进行一些事件处理。Vue提供了修饰符来帮助我们方便的处理一些事件： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 v-if、v-else-if、v-else这三个指令与JavaScript的条件语句if、else、else if类似。Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件。 v-if的原理： v-if后面的条件为false时，对应的元素以及其子元素不会渲染。也就是根本没有不会有对应的标签出现在DOM中。 简单演示： v-showv-show的用法和v-if非常相似，也用于决定一个元素是否渲染： v-if和v-show对比 v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？ v-if当条件为false时，压根不会有对应的元素在DOM中。 v-show当条件为false时，仅仅是将元素的display属性设置为none而已。 开发中如何选择呢？ 当需要在显示与隐藏之间切片很频繁时，使用v-show 当只有一次切换时，通过使用v-if v-for遍历数组当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。 v-for的语法类似于JavaScript中的for循环。 格式如下：item in items的形式。 两种情况： 如果在遍历的过程中不需要使用索引值 语法格式：v-for=”movie in movies”：依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie 如果在遍历的过程中，我们需要拿到元素在数组中的索引值 语法格式：v-for=(item, index) in items：其中的index就代表了取出的item在原数组的索引值。 demo： v-for遍历对象v-for可以用户遍历对象：比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来。 组件的key属性官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。 了解一下：key的作用主要是为了高效的更新虚拟DOM 检测数据更新因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。 push() pop() shift() unshift() splice() sort() reverse() 表单绑定v-model概述表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。Vue中使用v-model指令来实现表单元素和数据的双向绑定。 案例的解析：当我们在输入框输入内容时，因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。所以，通过v-model实现了双向的绑定。 原理v-model其实是一个语法糖，它的背后本质上是包含两个操作： 1.v-bind绑定一个value属性 2.v-on指令给当前元素绑定input事件 也就是说下面的代码：等同于下面的代码： 123&lt;input type="text" v-model="message"&gt;等同于&lt;input type="text" v-bind:value="message" v-on:input="message = $event.target.value"&gt; v-model：radio 单选框注意：v-model 绑定同一个值 v-model：checkbox复选框分为两种情况：单个勾选框和多个勾选框 单个勾选框： v-model即为布尔值。 此时input的value并不影响v-model的值。 选中时，v-model 绑定的值 即为 true 多个复选框： 当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。 当选中某一个时，就会将input的value添加到数组中。 v-model：select和checkbox一样，select也分单选和多选两种情况。 单选：只能选中一个值。 v-model绑定的是一个值。当我们选中option中的一个时，会将它对应的value赋值到mySelect中 多选：可以选中多个值。 v-model绑定的是一个数组。当选中多个值时，就会将选中的option对应的value添加到数组mySelects中 修饰符 lazy修饰符：默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。lazy修饰符可以让数据在失去焦点或者回车时才会更新。 number修饰符：默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。number修饰符可以让在输入框中输入的内容自动转成数字类型。 trim修饰符：如果输入的内容首尾有很多空格，通常我们希望将其去除，trim修饰符可以过滤内容左右两边的空格。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2020%2F05%2F19%2FVue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[认识Vue 官网： https://cn.vuejs.org/v2/guide/ Vue (读音 /vjuː/，类似于 view)，不要读错。 Vue是一个渐进式的框架，什么是渐进式的呢？渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。 Vue有很多特点和Web开发中常见的高级功能 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM Vue.js 安装方式一：直接CDN引入 可以选择引入开发环境版本还是生产环境版本： 12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 方式二：下载和引入 123开发环境 https://vuejs.org/js/vue.js 生产环境 https://vuejs.org/js/vue.min.js 方式三：NPM安装 View 中的MVVM View层： 视图层 在我们前端开发中，通常就是DOM层。 主要的作用是给用户展示各种信息。 Model层： 数据层 数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。 VueModel层： 视图模型层 视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。 Vue生命周期放一张官网的图： 简化版：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发机制详解]]></title>
    <url>%2F2020%2F05%2F11%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简述顶级View对点击事件的分发： 点击事件达到顶级View（一般是一个 ViewGroup ）以后，会调用 ViewGroup的 dispatchTouchEvent 方法，然后的逻辑是这样的：如果顶级 ViewGroup 拦截事件的 onInterceptTouchEvent 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。也就是说，如果都提供的话，onTouch 会屏蔽掉 onTouchEvent 。在 onTouchEvent 中，如果设置了 mOnClickListener，则 onClick 会被调用。如果顶级 ViewGroup 不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子 View 的 dispatchTouchEvent 会被调用。到此为止，事件已经从顶级View传递给了下一层View，接下来的传递过程和顶级 View 是一致的，如此循环，完成整个事件的分发。 事件分发、拦截与消费 View 相关dispatchTouchEvent 是事件分发机制中的核心，所有的事件调度都归它管 我们知道 View 可以注册很多事件监听器，例如：单击事件(onClick)、长按事件(onLongClick)、触摸事件(onTouch)，并且View自身也有 onTouchEvent 方法，那么问题来了，这么多与事件相关的方法应该由谁管理？毋庸置疑就是 dispatchTouchEvent，所以 View 也会有事件分发。 消费： 1234567891011&lt;RelativeLayout android:background=&quot;#CCC&quot; android:id=&quot;@+id/layout&quot; android:onClick=&quot;myClick&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot;&gt; &lt;View android:clickable=&quot;true&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; /&gt;&lt;/RelativeLayout&gt; 现在你有了一个 RelativeLayout - View 你开开心心的为 RelativeLayout 设置了一个点击事件myClick，然而你会发现不论怎么点都不会接收到信息，仔细一看，发现内部的 View 有一个属性 android:clickable=&quot;true&quot; 正是这个看似不起眼的属性把事件给消费掉了，由此我们可以得出如下结论:1. 不论 View 自身是否注册点击事件，只要 View 是可点击的就会消费事件。2. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。 ViewGroup相关ViewGroup(通常是各种Layout) 的事件分发相对来说就要麻烦一些，因为 ViewGroup 不仅要考虑自身，还要考虑各种 ChildView，一旦处理不好就容易引起各种事件冲突 前面事件分发机制中我们了解到事件是通过ViewGroup一层一层传递的，最终传递给 View，ViewGroup 要比它的 ChildView 先拿到事件，并且有权决定是否告诉要告诉 ChildView。在默认的情况下 ViewGroup 事件分发流程是这样的。 1.判断自身是否需要(询问 onInterceptTouchEvent 是否拦截)，如果需要，调用自己的 onTouchEvent。 2.自身不需要或者不确定，则询问 ChildView ，一般来说是调用手指触摸位置的 ChildView。 3.如果子 ChildView 不需要则调用自身的 onTouchEvent。 用伪代码应该是这样的: 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; 几个点： 1. ViewGroup 中可能有多个 ChildView，如何判断应该分配给哪一个？ 这个很容易，就是把所有的 ChildView 遍历一遍，如果手指触摸的点在 ChildView 区域内就分发给这个View。 2. 当该点的 ChildView 有重叠时应该如何分配？ 当 ChildView 重叠时，一般会分配给显示在最上面的 ChildView。如何判断哪个是显示在最上面的呢？后面加载的一般会覆盖掉之前的，所以显示在最上面的是最后加载的。 3. ViewGroup 和 ChildView 同时注册了事件监听器(onClick等)，哪个会执行? 事件优先给 ChildView，会被 ChildView消费掉，ViewGroup 不会响应。 4. 所有事件都应该被同一 View 消费 在上面的例子中我们分析后可以了解到，同一次点击事件只能被一个 View 消费，这是为什呢？主要是为了防止事件响应混乱，如果再一次完整的事件中分别将不同的事件分配给了不同的 View 容易造成事件响应混乱。 View 中 onClick 事件需要同时接收到 ACTION_DOWN 和 ACTION_UP 才能触发，如果分配给了不同的 View，那么 onClick 将无法被正确触发。 安卓为了保证所有的事件都是被一个 View 消费的，对第一次的事件( ACTION_DOWN )进行了特殊判断，View 只有消费了 ACTION_DOWN 事件，才能接收到后续的事件(可点击控件会默认消费所有事件)，并且会将后续所有事件传递过来，不会再传递给其他 View，除非上层 View 进行了拦截。如果上层 View 拦截了当前正在处理的事件，会收到一个 ACTION_CANCEL，表示当前事件已经结束，后续事件不会再传递过来。 如下: 123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.gcssloop.viewtest.MainActivity"&gt; &lt;View android:id="@+id/view1" android:background="#E4A07B" android:layout_width="200dp" android:layout_height="200dp"/&gt; &lt;View android:id="@+id/view2" android:layout_margin="100dp" android:background="#BDDA66" android:layout_width="200dp" android:layout_height="200dp"/&gt;&lt;/RelativeLayout&gt; 当手指点击有重叠区域时，分如下几种情况: 只有 View1 可点击时，事件将会分配给 View1，即使被 View2 遮挡，这一部分仍是 View1 的可点击区域。 只有 View2 可点击时，事件将会分配给 View2。 View1 和 View2 均可点击时，事件会分配给后加载的 View2，View2 将事件消费掉，View1接收不到事件。 注意: 上面说的是可点击，可点击包括很多种情况，只要你给View注册了 onClickListener、onLongClickListener、OnContextClickListener 其中的任何一个监听器或者设置了 android:clickable=”true” 就代表这个 View 是可点击的。另外，某些 View 默认就是可点击的，例如，Button，CheckBox 等。 给 View 注册 OnTouchListener 不会影响 View 的可点击状态。即使给 View 注册 OnTouchListener ，只要不返回 true 就不会消费事件。]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发机制原理]]></title>
    <url>%2F2020%2F05%2F11%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述安卓上面的View是树形结构的，View可能会重叠在一起，当我们点击的地方有多个View都可以响应的时候，这个点击事件应该给谁呢？为了解决这一个问题，就有了事件分发机制。 如下图，View是一层一层嵌套的，当手指点击 View1 的时候，下面的ViewGroupA、 RootView 等也是能够响应的，为了确定到底应该是哪个View处理这次点击事件，就需要事件分发机制来帮忙。 View结构 理解： 简单来说，Window是一个抽象类，是所有视图的最顶层容器，视图的外观和行为都归他管，不论是背景显示，标题栏还是事件处理都是他管理的范畴，它其实就像是View界的太上皇(虽然能管的事情看似很多，但是没实权，因为抽象类不能直接使用)。 而 PhoneWindow 作为 Window 的唯一亲儿子(唯一实现类)，自然就是 View 界的皇帝了，PhoneWindow 的权利可是非常大大，不过对于我们来说用处并不大，因为皇帝平时都是躲在深宫里面的，虽然偶尔用特殊方法能见上一面，但想要完全指挥 PhoneWindow 为你工作是很困难的。 而上面说的 DecorView 是 PhoneWindow 的一个内部类，其职位相当于小太监，就是跟在 PhoneWindow 身边专业为 PhoneWindow 服务的，除了自己要干活之外，也负责消息的传递，PhoneWindow 的指示通过 DecorView 传递给下面的 View，而下面 View 的信息也通过 DecorView 回传给 PhoneWindow。 事件分发、拦截与消费概述下表省略了 PhoneWidow 和 DecorView。 √ 表示有该方法。 X 表示没有该方法。 这个三个方法均有一个 boolean(布尔) 类型的返回值，通过返回 true 和 false 来控制事件传递的流程 从上表可以看到 Activity 和 View 都是没有事件拦截的，这是因为： Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果。 View最为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。 事件分发流程前面我们了解到了我们的View是树形结构的，基于这样的结构，我们的事件可以进行有序的分发。 事件收集之后最先传递给 Activity， 然后依次向下传递，大致如下： 1Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 这样的事件分发机制逻辑非常清晰，可是，你是否注意到一个问题？如果最后分发到View，如果这个View也没有处理事件怎么办，就这样让事件浪费掉？ 当然不会啦，如果没有任何View消费掉事件，那么这个事件会按照反方向回传，最终传回给Activity，如果最后 Activity 也没有处理，本次事件才会被抛弃: 1Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这种设计是非常精巧的，上层View既可以直接拦截该事件，自己处理，也可以先询问(分发给)子View，如果子View需要就交给子View处理，如果子View不需要还能继续交给上层View处理。既保证了事件的有序性，又非常的灵活。 几种情形分析1.点击 View1 区域但没有任何 View 消费事件 当手指在 View1 区域点击了一下之后，如果所有View都不消耗事件，你就能看到一个完整的事件分发流程，大致如下(简化版)： 红色箭头方向表示事件分发方向。 绿色箭头方向表示事件回传方向。 上面的流程中存在部分不合理内容，主要为了理解： 事件返回时 dispatchTouchEvent 直接指向了父View的 onTouchEvent 这一部分是不合理的，实际上它仅仅是给了父View的 dispatchTouchEvent一个 false 返回值，父View根据返回值来调用自身的 onTouchEvent。 ViewGroup 是根据 onInterceptTouchEvent 的返回值来确定是调用子View的 dispatchTouchEvent 还是自身的 onTouchEvent， 并没有将调用交给 onInterceptTouchEvent。 情形模拟： 测试: 情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。 事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。 12345678910MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 2.点击 View1 区域且事件被 View1 消费如果事件被View1消费掉了则事件会回传告诉上层View这个事件已经被我解决了，上层View就无需再响应了。 注意：这张图中的事件回传路径才是正确的路径 可以看出，事件一旦被消费就意味着消息传递的结束，上层View知道了事件已经被消费掉，就不再处理了。 情形模拟 情景：老板: 我觉得咱们这个app按钮不好看，做的有光泽一点，要让人有一种想点的欲望。 事件顺序，老板(MainActivity)要做改界面，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)就在按钮上添加了一道光(为啥是小王呢？因为公司没有设计师)。 1234567MainActivity [老板]: dispatchTouchEvent 把按钮做的好看一点,要有光泽,给人一种点击的欲望.RootView [经理]: dispatchTouchEvent 技术部,老板说按钮不好看,要加一道光.RootView [经理]: onInterceptTouchEvent ViewGroupA [组长]: dispatchTouchEvent 给按钮加上一道光.ViewGroupA [组长]: onInterceptTouchEvent View1 [码农]: dispatchTouchEvent 加一道光.View1 [码农]: onTouchEvent 做好了. 3.点击 View1 区域但事件被 ViewGroupA 拦截上层的View有权拦截事件，不传递给下层View，例如 ListView 滑动的时候，就不会将事件传递给下层的子 View。 注意：可以看到，如果上层拦截了事件，下层View将接收不到事件信息。 情形模拟 情景：老板: 报告一下项目进度。 事件顺序，老板(MainActivity)要知道项目进度，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到技术组组长(ViewGroupA)的时候，组长(ViewGroupA)上报任务即可。无需告知码农小王(View1)。 123456MainActivity [老板]: dispatchTouchEvent 现在项目做到什么程度了?RootView [经理]: dispatchTouchEvent 技术部,你们的app快做完了么?RootView [经理]: onInterceptTouchEvent ViewGroupA [组长]: dispatchTouchEvent 项目进度?ViewGroupA [组长]: onInterceptTouchEvent ViewGroupA [组长]: onTouchEvent 正在测试,明天就测试完了 原则总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 1.如果事件被消费，就意味着事件信息传递终止。 2.如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 3.判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手势检测]]></title>
    <url>%2F2020%2F04%2F12%2F%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[概述Android 手势检测，主要是 GestureDetector 相关内容的用法和注意事项。在开发 Android 手机应用过程中，可能需要对一些手势作出响应，如：单击、双击、长按、滑动、缩放等。这些都是很常用的手势。 GestureDetector GestureDetector 可以使用 MotionEvents 检测各种手势和事件。GestureDetector.OnGestureListener 是一个回调方法，在发生特定的事件时会调用 Listener 中对应的方法回调。这个类只能用于检测触摸事件的 MotionEvent，不能用于轨迹球事件。(话说轨迹球已经消失多长时间了，估计很多人都没见过轨迹球这种东西)。 如何使用： 创建一个 GestureDetector 实例。 在onTouchEvent（MotionEvent）方法中，确保调用 GestureDetector 实例的 onTouchEvent（MotionEvent）。回调中定义的方法将在事件发生时执行。 如果侦听 onContextClick（MotionEvent），则必须在 View 的 onGenericMotionEvent（MotionEvent）中调用 GestureDetector OnGenericMotionEvent（MotionEvent）。 GestureDetector 本身的方法比较少，使用起来也非常简单，下面让我们先看一下它的简单使用示例，分解开来大概需要三个步骤。 1234567891011121314151617// 1.创建一个监听回调SimpleOnGestureListener listener = new SimpleOnGestureListener() &#123; @Override public boolean onDoubleTap(MotionEvent e) &#123; Toast.makeText(MainActivity.this, "双击666", Toast.LENGTH_SHORT).show(); return super.onDoubleTap(e); &#125;&#125;;// 2.创建一个检测器final GestureDetector detector = new GestureDetector(this, listener);// 3.给监听器设置数据源view.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return detector.onTouchEvent(event); &#125;&#125;); 构造函数 第 1 种构造函数里面需要传递两个参数，上下文(Context) 和 手势监听器(OnGestureListener)，这个很容易理解，就不再过多叙述，上面的例子中使用的就是这一种。 第 2 种构造函数则需要多传递一个 Handler 作为参数，这个有什么作用呢？其实作用也非常简单，这个 Handler 主要是为了给 GestureDetector 提供一个 Looper。 在通常情况下是不需这个 Handler 的，因为它会在内部自动创建一个 Handler 用于处理数据，如果你在主线程中创建 GestureDetector，那么它内部创建的 Handler 会自动获得主线程的 Looper，然而如果你在一个没有创建 Looper 的子线程中创建 GestureDetector 则需要传递一个带有 Looper 的 Handler 给它，否则就会因为无法获取到 Looper 导致创建失败。 第 2 种构造函数使用方式如下(下面是两种在子线程中创建 GestureDetector 的方法)： 12345678910111213141516171819// 方式一、在主线程创建 Handlerfinal Handler handler = new Handler();new Thread(new Runnable() &#123; @Override public void run() &#123; final GestureDetector detector = new GestureDetector(MainActivity.this, new GestureDetector.SimpleOnGestureListener() , handler); // ... 省略其它代码 ... &#125;&#125;).start();// 方式二、在子线程创建 Handler，并且指定 Loopernew Thread(new Runnable() &#123; @Override public void run() &#123; final Handler handler = new Handler(Looper.getMainLooper()); final GestureDetector detector = new GestureDetector(MainActivity.this, new GestureDetector.SimpleOnGestureListener() , handler); // ... 省略其它代码 ... &#125;&#125;).start(); 当然了，使用其它创建 Handler 的方式也是可以的，重点传递的 Handler 一定要有 Looper，敲黑板，重点是 Handler 中的 Looper。假如子线程准备了 Looper 那么可以直接使用第 1 种构造函数进行创建，如下： 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); // &lt;- 重点在这里 final GestureDetector detector = new GestureDetector(MainActivity.this, new GestureDetector.SimpleOnGestureListener()); // ... 省略其它代码 ... &#125;&#125;).start(); 手势监听器既然是手势检测，自然要在对应的手势出现的时候通知调用者，最合适的自然是事件监听器模式。目前 GestureDetecotor 有四种监听器。 1.OnContextClickListener由于 OnContextClickListener 主要是用于检测外部设备按钮的，关于它需要注意一点，如果侦听 onContextClick(MotionEvent)，则必须在 View 的 onGenericMotionEvent(MotionEvent)中调用 GestureDetector 的 OnGenericMotionEvent(MotionEvent)。 2.OnDoubleTapListener很明显就是用于检测双击事件的，它有三个回调接口，分别是onDoubleTap、onDoubleTapEvent和 onSingleTapConfirmed。 onDoubleTap 与 onSingleTapConfirmed,onDoubleTap : 双击，由两次连续的单机组成，它不可能和 onSingleTapConfirmed 共存 。 onSingleTapConfirmed : 严格的单击行为。注意它和 onSingleTapUp 的区别，如果触发了 onSingleTapConfirmed ，那么后面不可能再紧跟着另一个单击行为，即这只能是单击，而不可能是双击中的一次单击 如果你只想监听双击事件，那么只用关注 onDoubleTap 就行了，如果你同时要监听单击事件则需要关注 onSingleTapConfirmed 这个回调函数。 如果你需要同时监听两种点击事件可以这样写： 1234567891011GestureDetector detector = new GestureDetector(this, new GestureDetector .SimpleOnGestureListener() &#123; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; Toast.makeText(MainActivity.this, "单击", Toast.LENGTH_SHORT).show(); return false; &#125; @Override public boolean onDoubleTap(MotionEvent e) &#123; Toast.makeText(MainActivity.this, "双击", Toast.LENGTH_SHORT).show(); return false; &#125;&#125;); 关于 onSingleTapConfirmed 原理也非常简单，这一个回调函数在单击事件发生后300ms后触发(注意，不是立即触发的)，只有在确定不会有后续的事件后，既当前事件肯定是单击事件才触发 onSingleTapConfirmed，所以在进行点击操作时，onDoubleTap 和 onSingleTapConfirmed 只会有一个被触发，也就不存在冲突了。 onDoubleTapEvent在双击事件确定发生时会对第二次按下产生的 MotionEvent 信息进行回调。 onDoubleTap 在第二次手指按下(dowm)时触发，onDoubleTapEvent 是一种实时回调。 3.OnGestureListener这个是手势检测中较为核心的一个部分了，主要检测以下类型事件：按下(Down)、 一扔(Fling)、长按(LongPress)、滚动(Scroll)、触摸反馈(ShowPress) 和 单击抬起(SingleTapUp)。 onDown手指轻轻触摸屏幕的一瞬间，由1个 ACTION_DOWN 触发。 123@Override public boolean onDown(MotionEvent e) &#123; return true;&#125; down 在事件分发体系中是一个较为特殊的事件，为了保证事件被唯一的 View 消费，哪个 View 消费了 down 事件，后续的内容就会传递给该 View。如果我们想让一个 View 能够接收到事件，有两种做法： 1、让该 View 可以点击，因为可点击状态会默认消费 down 事件。 2、手动消费掉 down 事件。 由于图片、文本等一些控件默认是不可点击的，所以我们要么声明它们的 clickable 为 true，要么在发生 down 事件是返回 true。所以 onDown 在这里的作用就很明显了，就是为了保证让该控件能拥有消费事件的能力，以接受后续的事件。 onFling用户按下触摸屏、快速滑动后松开，由1个 ACTION_DOWN 、多个 ACTION_MOVE 和 1个 ACTION_UP 触发，这是快速滑动行为。 Fling 中文直接翻译过来就是一扔、抛、甩，最常见的场景就是在 ListView 或者 RecyclerView 上快速滑动时手指抬起后它还会滚动一段时间才会停止。onFling 就是检测这种手势的。 12345@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return super.onFling(e1, e2, velocityX, velocityY);&#125; 在 onFling 的回调中共有四个参数，分别是： 我们可以通过 e1 和 e2 获取到手指按下和抬起时的坐标、时间等相关信息，通过 velocityX 和 velocityY 获取到在这段时间内的运动速度，单位是像素／秒(即 1 秒内滑动的像素距离)。 onLongPress用户长久的按着屏幕不放，即长按。 这个是检测长按事件的，即手指按下后不抬起，在一段时间后会触发该事件。 123@Override public void onLongPress(MotionEvent e) &#123;&#125; onScroll手指按下屏幕并拖动，由1个 ACTION_DOWN ，多个 ACTION_MOVE 触发，这是拖动行为。 onScroll 就是监听滚动事件的，它看起来和 onFling 比较像，不同的是，onSrcoll 后两个参数不是速度，而是滚动的距离。 12345@Overridepublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return super.onScroll(e1, e2, distanceX, distanceY);&#125; onShowPress手指轻轻触摸屏幕，尚未松开或拖动，由一个 ACTION_DOWN 触发，注意和 onDown() 的区别，他强调的是没有松开或者拖动的状态。 它是用户按下时的一种回调，主要作用是给用户提供一种视觉反馈，可以在监听到这种事件时可以让控件换一种颜色，或者产生一些变化，告诉用户他的动作已经被识别。 不过这个消息和 onSingleTapConfirmed 类似，也是一种延时回调，延迟时间是 180 ms，假如用户手指按下后立即抬起或者事件立即被拦截，时间没有超过 180 ms的话，这条消息会被 remove 掉，也就不会触发这个回调。 123@Override public void onShowPress(MotionEvent e) &#123;&#125; onSingleTapUp手指（轻轻触摸屏幕后）松开，伴随着1个 MotionEvent.ACTION_UP 而触发，这是单击行为。 1234@Override public boolean onSingleTapUp(MotionEvent e) &#123; return super.onSingleTapUp(e);&#125; 这个也很容易理解，就是用户单击抬起时的回调，但是它和上面的 onSingleTapConfirmed 之间有何不同呢？和 onClick 又有何不同呢？ 单击事件触发： 123GCS: onSingleTapUpGCS: onClickGCS: onSingleTapConfirmed 双击事件触发： 1234GCS: onSingleTapUpGCS: onClickGCS: onDoubleTap // &lt;- 双击GCS: onClick 4.SimpleOnGestureListener这个里面并没有什么内容，只是对上面三种 Listener 的空实现，在上面的例子中使用的基本都是这监听器。因为它用起来更方便一点。 这主要是 GestureDetector 构造函数的设计问题，以只监听 OnDoubleTapListener 为例，如果想要使用 OnDoubleTapListener 接口则需要这样进行设置： 123456789101112131415161718GestureDetector detector = new GestureDetector(this, new GestureDetector .SimpleOnGestureListener());detector.setOnDoubleTapListener(new GestureDetector.OnDoubleTapListener() &#123; @Override public boolean onSingleTapConfirmed(MotionEvent e) &#123; Toast.makeText(MainActivity.this, "单击确认", Toast.LENGTH_SHORT).show(); return false; &#125; @Override public boolean onDoubleTap(MotionEvent e) &#123; Toast.makeText(MainActivity.this, "双击", Toast.LENGTH_SHORT).show(); return false; &#125; @Override public boolean onDoubleTapEvent(MotionEvent e) &#123; // Toast.makeText(MainActivity.this,"",Toast.LENGTH_SHORT).show(); return false; &#125;&#125;); 相关方法除了各类监听器之外，与 GestureDetector 相关的方法其实并不多，只有几个]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多点触控详解]]></title>
    <url>%2F2020%2F04%2F12%2F%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述多点触控 ( Multitouch，也称 Multi-touch )，即同时接受屏幕上多个点的人机交互操作，多点触控是从 Android 2.0 开始引入的功能，在 Android 2.2 时对这一部分进行了重新设计。 相关事件 相关方法 自己自己手动进行计算，判断手指的抬起和落下兼容2.2以前： 1234567891011121314151617181920String TAG = "Gcs";int action = event.getAction() &amp; MotionEvent.ACTION_MASK;int index = (event.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt; MotionEvent.ACTION_POINTER_INDEX_SHIFT;switch (action) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"第1个手指按下"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"最后1个手指抬起"); break; case MotionEvent.ACTION_POINTER_1_DOWN: // 此时相当于 ACTION_POINTER_DOWN Log.e(TAG,"第"+(index+1)+"个手指按下"); break; case MotionEvent.ACTION_POINTER_1_UP: // 此时相当于 ACTION_POINTER_UP Log.e(TAG,"第"+(index+1)+"个手指抬起"); break;&#125; 看几个关键点： 1.action 与 Index 的获得 我们在 前面了解过，Android中的事件一般用最后8位来表示事件类型，再往前8位来表示Index。 例如多指触控的按下事件，其事件类型是 0x00000005， 其Index标志位是 0x00000005，随着更多的手指按下，其中变化的部分是 Index 标志位，最后两位是始终不变的，所以我们只要能将这两个分离开就行了。 取得事件类型(action) 这个非常简单，ACTION_MASK=0x000000ff， 与 getAction() 进行按位与操作后保留最后8位内容(十六进制每一个字符转化为二进制是4位)。 例如：0x00000105 &amp; 0x000000ff = 0x00000005 12// 获取事件类型int action = event.getAction() &amp; MotionEvent.ACTION_MASK; 取得事件索引(index) ACTION_POINTER_INDEX_MASK = 0x0000ff00ACTION_POINTER_INDEX_SHIFT = 8首先让 getAction() 与 ACTION_POINTER_INDEX_MASK 按位与之后，只保留 Index 那8位，之后再右移8位，最终就拿到了 Index 的真实数值。 例如：0x00000105 &amp; 0x0000ff00 = 0x000001000x00000100 » 8 = 0x00000001 123// 获取index编号int index = (event.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt; MotionEvent.ACTION_POINTER_INDEX_SHIFT; 只考虑兼容 2.2 以上的版本： 123456789101112131415161718String TAG = "Gcs";int index = event.getActionIndex();switch (event.getActionMasked()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"第1个手指按下"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"最后1个手指抬起"); break; case MotionEvent.ACTION_POINTER_DOWN: Log.e(TAG,"第"+(index+1)+"个手指按下"); break; case MotionEvent.ACTION_POINTER_UP: Log.e(TAG,"第"+(index+1)+"个手指抬起"); break;&#125; index 和 pointId 的变化规则在 2.2 版本以上，我们可以通过 getActionIndex() 轻松获取到事件的索引(Index)，但是这个事件索引的变化还是有点意思的，Index 变化有以下几个特点： 1、从 0 开始，自动增长。 这个前面说过了。 2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。 注意最后两次触发的事件，它的 Index 都是 1，这样也比较容易解释，当原本的第 2 个手指抬起后，屏幕上就只剩下两个手指了，之前的第 3 个手指就变成了第 2 个，于是抬起时触发事件的 Index 为 1，即之前落下的手指抬起，后面手指的 Index 会随之减小。 3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。 4、对 move 事件无效。 这个也比较容易理解，我们所取得的 Index 属性实际上是从事件上分离下来的，但是 move 事件始终为 0x00000002，也就是说，在 move 时不论你移动哪个手指，使用 getActionIndex() 获取到的始终是数值 0。 既然 move 事件无法用事件索引(Index)区别，那么该如何区分 move 是那个手指发出的呢？这就要用到 pointId 了，pointId 和 index 最大的区别就是 pointId 是不变的，始终为第一次落下时生成的数值，不会受到其他手指抬起和落下的影响。 pointId 与 index 的异同 Move相关事件actionIndex 与 pointerIndex在 move 中无法取得 actionIndex 的，我们需要使用 pointerIndex 来获取更多的信息，例如某个手指的坐标： 12getX(int pointerIndex)getY(int pointerIndex) 实际上这个 pointerIndex 和 actionIndex 区别并不大，两者的数值是相同的，你可以认为 pointerIndex 是特地为 move 事件准备的 actionIndex。 pointerIndex 与 pointerId 这两个数值使用以下两个方法相互转换： 通常情况下，pointerIndex 和 pointerId 是相同的，但也可能会因为某些手指的抬起而变得不同。 遍历多点触控先来一个简单的，遍历出多个手指的 move 事件： 12345678String TAG = "Gcs";switch (event.getActionMasked()) &#123; case MotionEvent.ACTION_MOVE: for (int i = 0; i &lt; event.getPointerCount(); i++) &#123; Log.i("TAG", "pointerIndex="+i+", pointerId="+event.getPointerId(i)); // TODO &#125;&#125; 通过遍历 pointerCount 获取到所有的 pointerIndex，同时通过 pointerIndex 来获取 pointerId，可以通过不同手指抬起和按下后移动来观察 pointerIndex 和 pointerId 的变化。 在多点触控中追踪单个手指： 要实现追踪单个手指还是有些麻烦的，需要同时使用上 actionIndex， pointerId 和 pointerIndex，例如，我们只追踪第2个手指，并画出其位置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 绘制出第二个手指第位置 */public class MultiTouchTest extends CustomView &#123; String TAG = "Gcs"; // 用于判断第2个手指是否存在 boolean haveSecondPoint = false; // 记录第2个手指第位置 PointF point = new PointF(0, 0); public MultiTouchTest(Context context) &#123; this(context, null); &#125; public MultiTouchTest(Context context, AttributeSet attrs) &#123; super(context, attrs); mDeafultPaint.setAntiAlias(true); mDeafultPaint.setTextAlign(Paint.Align.CENTER); mDeafultPaint.setTextSize(30); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int index = event.getActionIndex(); switch (event.getActionMasked()) &#123; case MotionEvent.ACTION_POINTER_DOWN: // 判断是否是第2个手指按下 if (event.getPointerId(index) == 1)&#123; haveSecondPoint = true; point.set(event.getY(), event.getX()); &#125; break; case MotionEvent.ACTION_POINTER_UP: // 判断抬起的手指是否是第2个 if (event.getPointerId(index) == 1)&#123; haveSecondPoint = false; point.set(0, 0); &#125; break; case MotionEvent.ACTION_MOVE: if (haveSecondPoint) &#123; // 通过 pointerId 来获取 pointerIndex int pointerIndex = event.findPointerIndex(1); // 通过 pointerIndex 来取出对应的坐标 point.set(event.getX(pointerIndex), event.getY(pointerIndex)); &#125; break; &#125; invalidate(); // 刷新 return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.save(); canvas.translate(mViewWidth/2, mViewHeight/2); canvas.drawText("追踪第2个按下手指的位置", 0, 0, mDeafultPaint); canvas.restore(); // 如果屏幕上有第2个手指则绘制出来其位置 if (haveSecondPoint) &#123; canvas.drawCircle(point.x, point.y, 50, mDeafultPaint); &#125; &#125;&#125;]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MotionEvent学习]]></title>
    <url>%2F2020%2F04%2F12%2FMotionEvent%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述Android 将所有的输入事件都放在了 MotionEvent 中，随着安卓的不断发展壮大，MotionEvent 也开始变得越来越复杂。主要学一下单点触控、多点触控、鼠标事件 以及 getAction() 和 getActionMasked() 单点触控涉及事件： 方法： 12345event.getX(); //触摸点相对于其所在组件坐标系的坐标event.getY();event.getRawX(); //触摸点相对于屏幕默认坐标系的坐标event.getRawY(); 针对单点触控的事件处理一般是这样写的: 12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // ▼ 注意这里使用的是 getAction()，先埋一个小尾巴。 switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: // 手指按下 break; case MotionEvent.ACTION_MOVE: // 手指移动 break; case MotionEvent.ACTION_UP: // 手指抬起 break; case MotionEvent.ACTION_CANCEL: // 事件被拦截 break; case MotionEvent.ACTION_OUTSIDE: // 超出区域 break; &#125; return super.onTouchEvent(event);&#125; 理解 ACTION_CANCEL ACTION_CANCEL 的触发条件是事件被上层拦截，我们知道当事件被上层 View 拦截的时候，ChildView 是收不到任何事件的，ChildView 收不到任何事件，自然也不会收到 ACTION_CANCEL 了，所以说这个 ACTION_CANCEL 的正确触发条件并不是这样，那么是什么呢？ 事实上，只有上层 View 回收事件处理权的时候，ChildView 才会收到一个 ACTION_CANCEL 事件。 例如：上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE事件，且移动的方向和 RecyclerView 的可滑动方向一致，所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，并且不会再收到后续事件。 多点触控比较复杂，后面再学。 getAction() 与 getActionMasked()当多个手指在屏幕上按下的时候，会产生大量的事件，如何在获取事件类型的同时区分这些事件就是一个大问题了。一般来说我们可以通过为事件添加一个int类型的index属性来区分，但为了添加一个通常数值不会超过10的index属性就浪费一个int大小的空间简直是不能忍受的，于是工程师们将这个index属性和事件类型直接合并了。 int类型共32位(0x00000000)，他们用最低8位(0x000000ff)表示事件类型，再往前的8位(0x0000ff00)表示事件编号，以手指按下为例讲解数值是如何合成的: ACTION_DOWN 的默认数值为 (0x00000000)ACTION_POINTER_DOWN 的默认数值为 (0x00000005) 注意：上面表格中用粗体标示出的数值，可以看到随着按下手指数量的增加，这个数值也是一直变化的，进而导致我们使用 getAction() 获取到的数值无法与标准的事件类型进行对比，为了解决这个问题，他们创建了一个 getActionMasked()方法，这个方法可以清除index数值，让其变成一个标准的事件类型。1、多点触控时必须使用 getActionMasked() 来获取事件类型。2、单点触控时由于事件数值不变，使用 getAction() 和 getActionMasked()两个方法都可以。3、使用 getActionIndex() 可以获取到这个index数值。不过请注意，getActionIndex() 只在 down 和 up 时有效，move 时是无效的。 PointId 虽然前面刚刚说了一个 actionIndex，可以使用 getActionIndex() 获得，但通过 actionIndex 字面意思知道，这个只表示事件的序号，而且根据其说明文档解释，这个 ActionIndex 只有在手指按下(down)和抬起(up)时是有用的，在移动(move)时是没有用的. PointId 在手指按下时产生，手指抬起或者事件被取消后消失，是一个事件流程中唯一不变的标识，可以在手指按下时 通过 getPointerId(int pointerIndex)获得。 (参数中的 pointerIndex 就是 actionIndex)。 因此追踪事件流就采用 PointId。 历史数据（批处理）由于我们的设备非常灵敏，手指稍微移动一下就会产生一个移动事件，所以移动事件会产生的特别频繁，为了提高效率，系统会将近期的多个移动事件(move)按照事件发生的顺序进行排序打包放在同一个 MotionEvent 中，与之对应的产生了以下方法： 注意： pin 全称是 pointerIndex，表示第几个手指，此处为了节省空间使用了缩写。 历史数据只有 ACTION_MOVE 事件。 历史数据单点触控和多点触控均可以用。 看一下官方给的简单示例： 12345678910111213141516void printSamples(MotionEvent ev) &#123; final int historySize = ev.getHistorySize(); final int pointerCount = ev.getPointerCount(); for (int h = 0; h &lt; historySize; h++) &#123; System.out.printf("At time %d:", ev.getHistoricalEventTime(h)); for (int p = 0; p &lt; pointerCount; p++) &#123; System.out.printf(" pointer %d: (%f,%f)", ev.getPointerId(p), ev.getHistoricalX(p, h), ev.getHistoricalY(p, h)); &#125; &#125; System.out.printf("At time %d:", ev.getEventTime()); for (int p = 0; p &lt; pointerCount; p++) &#123; System.out.printf(" pointer %d: (%f,%f)", ev.getPointerId(p), ev.getX(p), ev.getY(p)); &#125;&#125; 获取事件发生的时间 pos 表示历史数据中的第几个数据。( pos &lt; getHistorySize() ) 返回值类型为 long，单位是毫秒。 获取压力（接触面积大小）MotionEvent支持获取某些输入设备(手指或触控笔)的与屏幕的接触面积和压力大小，主要有以下方法： 描述中使用了手指，触控笔也是一样的。 pin 全称是 pointerIndex，表示第几个手指。(pin &lt; getPointerCount() ) pos 表示历史数据中的第几个数据。( pos &lt; getHistorySize() ) 注意： 1、获取接触面积大小和获取压力大小是需要硬件支持的。2、非常不幸的是大部分设备所使用的电容屏不支持压力检测，但能够大致检测出接触面积。3、大部分设备的 getPressure() 是使用接触面积来模拟的。4、由于某些未知的原因(可能系统版本和硬件问题)，某些设备不支持该方法。]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix详解]]></title>
    <url>%2F2020%2F04%2F10%2FAndroid%20Matrix%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述我们在自定义 View 控件时随处可见 Matrix 的身影，主要用于坐标转换映射，我们可以通过 Matrix 矩阵来控制视图的变换。 Matrix 本质上是一个如下图所示的矩阵： 上面每个值都有其对应的操作。 Matrix 提供了如下几个操作： 缩放（Scale） 对应 MSCALE_X 与 MSCALE_Y 位移（Translate） 对应 MTRANS_X 与 MTRANS_Y 错切（Skew） 对应 MSKEW_X 与 MSKEW_Y 旋转（Rotate） 旋转没有专门的数值来计算，Matrix 会通过计算缩放与错切来处理旋转。 最后三个参数是控制透视的，这三个参数主要在3D效果中运用，通常为(0, 0, 1)，不在本篇讨论范围内，暂不过多叙述 示意假设通知栏高度为20像素，导航栏高度为40像素,那么我们在内容区的(0，0)位置绘制一个点，最终就要转化为在实际坐标系中的(0，60)位置绘制一个点。 原理矩阵乘法规则还记得吗？ 我们在使用 Matrix 处理视图变换时本质上是通过矩阵映射坐标。所以上述的几个操作都是对矩阵的操作，我们新建一个 Matrix 后其矩阵为默认状态，其值如下： 可以看到默认状态下的数据都是初始值，即不做任何变换处理，所有坐标保持原样 缩放对于单个坐标来说，缩放只要将其坐标值值乘以缩放值即可。假设对某个点宽度缩放 k1 倍，高度缩放 k2 倍，该点坐标为 x0、y0，缩放后坐标为 x、y，那么缩放的公式如下： 用矩阵来描述一下（上面提到了，与缩放相关的两个位置是 MSCALE_X 与 MSCALE_Y，即下图k1,k2的位置） 等号左边的矩阵就是计算后的缩放结果。 Matrix 中用于缩放操作的方法有如下两个： 12void setScale(float sx, float sy);void setScale(float sx, float sy, float px, float py); 前面两个参数 sx、sy，分别是宽和高的缩放比例。第二个重载方法多了两个参数 px、py，这两个参数用来描述缩放的枢轴点 枢轴点是指定转换应保持不变的坐标。当我们不传这两个参数时，枢轴点默认为左上角的点，缩放都是向下和向右，所以枢轴点可以大概的理解为缩放的锚点，缩放从这个点开始向四周扩散。 通过矩阵来理解一下： 12Matrix matrix = new Matrix()matrix.setScale(0.5F, 0.5F, 300F, 300F); 缩放 0.5 倍，枢轴点为 300，调用该方法后矩阵变换为： 前面提到过，上图右上角两个150值对应的位置是 MTRANS_X 与 MTRANS_Y，即和平移操作相关的两个位置。因此，实际上我们设置了枢轴点后 Matrix 会做一次位移操作，平移距离就是 s * p. 位移位移操作是指将坐标（x0,y0）平移一定的距离，我们直接将坐标加上平移的距离即可得到平移后的坐标： 通过矩阵理解（上面提到了，与平移相关的两个位置是 MTRANS_X 与 MTRANS_Y，即下图△x,△y的位置）： 用于设置位移操作的方法： 1void setTranslate(float dx, float dy); 错切看张图感受一下： 上图是通过下面的代码设置错切的示意图 1matrix.setSkew(0.3F, 0.3F); 分别设置了水平错切、垂直错切的值为 0.3，效果就是上面的样子。错切公式如下： 通过矩阵理解（上面提到了，与错切相关的两个位置是 MSKEW_X 与 MSKEW_Y，即下图k1,k2的位置）： 错切操作方法(和前面缩放一样) 12void setSkew(float kx, float ky);void setSkew(float kx, float ky, float px, float py); 旋转旋转公式： 矩阵： 设置旋转的方法： 12void setRotate(float degrees);void setRotate(float degrees, float px, float py); Matrix复合变换复合变换是指矩阵同时实现两种或以上变换，例如在平移的同时改变其大小。 Matrix 的复合变换实际上就是矩阵相乘，原理很简单，但是因为矩阵相乘不符合交换律、且执行顺序对结果会有影响，所以想准确的使用好符合变换需要了解其原理。 上面我们在介绍这几种变换的同时也说了他们对应的方法，可以看到他们都是 set 方法，但 Matrix 中实际上提供了三种操作，分别是：设置（set）、前乘（pre）以及后乘（post）。 所以上述介绍的几个 set 方法都有与之对应的 pre 及 post 方法，方法列表如下： 123456789101112131415161718192021//scale 缩放boolean preScale(float sx, float sy);boolean preScale(float sx, float sy, float px, float py);boolean postScale(float sx, float sy);boolean postScale(float sx, float sy, float px, float py);//translate 平移boolean preTranslate(float dx, float dy);boolean postTranslate(float dx, float dy);//skew 错切boolean preSkew(float kx, float ky);boolean preSkew(float kx, float ky, float px, float py);boolean postSkew(float kx, float ky);boolean postSkew(float kx, float ky, float px, float py);//rotate 旋转boolean preRotate(float degrees);boolean preRotate(float degrees, float px, float py);boolean postRotate(float degrees);boolean postRotate(float degrees, float px, float py); 这三种的区别： 设置（set）：如果我们不需要考虑复合变换的情况，一般可以直接使用 set 方法，因为 set 方法可能会重置之前的 Matrix 状态，导致之前设置的变换失效。 前乘（pre）： 前乘相当于矩阵右乘： 我们假设当前矩阵 M 为： 用pre方法做一次平移操作 1matrix.preTranslate(100, 100); 变换过程如下：（可以很明显的看到，当前是右乘） 后乘 后乘相当于矩阵左乘： 还是用刚才上面那个矩阵，同样对其做一次平移操作，使用post 1matrix.postTranslate(100, 100); 变换过程如下：（可以看到，是左乘）]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathMeasure学习]]></title>
    <url>%2F2020%2F04%2F10%2FPathMeasure%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述顾名思义，PathMeasure是一个用来测量Path的类，主要有以下方法: 构造方法 公共方法 方法详解构造函数无参构造函数： 1PathMeasure () 用这个构造函数可创建一个空的 PathMeasure，但是使用之前需要先调用 setPath 方法来与 Path 进行关联。被关联的 Path 必须是已经创建好的，如果关联之后 Path 内容进行了更改，则需要使用 setPath 方法重新关联。 有参构造函数： 1PathMeasure (Path path, boolean forceClosed) 用这个构造函数是创建一个 PathMeasure 并关联一个 Path， 其实和创建一个空的 PathMeasure 后调用 setPath 进行关联效果是一样的，同样，被关联的 Path 也必须是已经创建好的，如果关联之后 Path 内容进行了更改，则需要使用 setPath 方法重新关联。 该方法有两个参数，第一个参数自然就是被关联的 Path 了，第二个参数是用来确保 Path 闭合，如果设置为 true， 则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)。 在这里有两点需要明确: 不论 forceClosed 设置为何种状态(true 或者 false)， 都不会影响原有Path的状态，即 Path 与 PathMeasure 关联之后，之前的的 Path 不会有任何改变。 forceClosed 的设置状态可能会影响测量结果，如果 Path 未闭合但在与 PathMeasure 关联的时候设置 forceClosed 为 true 时，测量结果可能会比 Path 实际长度稍长一点，获取到到是该 Path 闭合时的状态。 setPath、 isClosed 和 getLengthsetPath 是 PathMeasure 与 Path 关联的重要方法，效果和 构造函数 中两个参数的作用是一样的。 isClosed 用于判断 Path 是否闭合，但是如果你在关联 Path 的时候设置 forceClosed 为 true 的话，这个方法的返回值则一定为true。 getLength 用于获取 Path 的总长度。 getSegmentgetSegment 用于获取Path的一个片段，方法如下： 1boolean getSegment (float startD, float stopD, Path dst, boolean startWithMoveTo) 方法各个参数释义： 如果 startD、stopD 的数值不在取值范围 [0, getLength] 内，或者 startD == stopD 则返回值为 false，不会改变 dst 内容。 如果在安卓4.4或者之前的版本，在默认开启硬件加速的情况下，更改 dst 的内容后可能绘制会出现问题，请关闭硬件加速或者给 dst 添加一个单个操作，例如: dst.rLineTo(0, 0) 示意Demo1：我们创建了一个 Path， 并在其中添加了一个矩形，现在我们想截取矩形中的一部分，就是下图中红色的部分。 矩形边长400dp，起始点在左上角，顺时针 12345678910111213canvas.translate(mViewWidth / 2, mViewHeight / 2); // 平移坐标系Path path = new Path(); // 创建Path并添加了一个矩形,设置绘制方向为顺时针path.addRect(-200, -200, 200, 200, Path.Direction.CW);Path dst = new Path(); // 创建用于存储截取后内容的 Path，此时path中并没有内容PathMeasure measure = new PathMeasure(path, false); // 将 Path 与 PathMeasure 关联// 截取一部分存入dst中，并使用 moveTo 保持截取得到的 Path 第一个点的位置不变measure.getSegment(200, 600, dst, true); canvas.drawPath(dst, mDeafultPaint); // 绘制 dst 结果如下： 从上图可以看到我们成功到将需要到片段截取了出来，然而当 dst 中有内容时会怎样呢？ 12345678910111213canvas.translate(mViewWidth / 2, mViewHeight / 2); // 平移坐标系Path path = new Path(); // 创建Path并添加了一个矩形path.addRect(-200, -200, 200, 200, Path.Direction.CW);Path dst = new Path(); // 创建用于存储截取后内容的 Pathdst.lineTo(-300, -300); // &lt;--- 在 dst 中添加一条线段PathMeasure measure = new PathMeasure(path, false); // 将 Path 与 PathMeasure 关联measure.getSegment(200, 600, dst, true); // 截取一部分 并使用 moveTo 保持截取得到的 Path 第一个点的位置不变canvas.drawPath(dst, mDeafultPaint); // 绘制 Path 结果如下： 从上面的示例可以看到 dst 中的线段保留了下来，可以得到结论：被截取的 Path 片段会添加到 dst 中，而不是替换 dst 中到内容。 前面两个例子中 startWithMoveTo 均为 true， 如果设置为false会怎样呢? 12345678910111213canvas.translate(mViewWidth / 2, mViewHeight / 2); // 平移坐标系Path path = new Path(); // 创建Path并添加了一个矩形path.addRect(-200, -200, 200, 200, Path.Direction.CW);Path dst = new Path(); // 创建用于存储截取后内容的 Pathdst.lineTo(-300, -300); // 在 dst 中添加一条线段PathMeasure measure = new PathMeasure(path, false); // 将 Path 与 PathMeasure 关联measure.getSegment(200, 600, dst, false); // &lt;--- 截取一部分 不使用 startMoveTo, 保持 dst 的连续性canvas.drawPath(dst, mDeafultPaint); // 绘制 Path 结果如下： 从该示例我们又可以得到一条结论：如果 startWithMoveTo 为 true, 则被截取出来到Path片段保持原状，如果 startWithMoveTo 为 false，则会将截取出来的 Path 片段的起始点移动到 dst 的最后一个点，以保证 dst 的连续性。 从而我们可以用以下规则来判断 startWithMoveTo 的取值： nextContour我们知道 Path 可以由多条曲线构成，但不论是 getLength , getSegment 或者是其它方法，都只会在其中第一条线段上运行，而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。 示意Demo2：如下，我们创建了一个 Path 并使其中包含了两个闭合的曲线，内部的边长是200，外面的边长是400，现在我们使用 PathMeasure 分别测量两条曲线的总长度。 12345678910111213141516171819canvas.translate(mViewWidth / 2, mViewHeight / 2); // 平移坐标系Path path = new Path();path.addRect(-100, -100, 100, 100, Path.Direction.CW); // 添加小矩形 周长800path.addRect(-200, -200, 200, 200, Path.Direction.CW); // 添加大矩形 周长1600canvas.drawPath(path,mDeafultPaint); // 绘制 PathPathMeasure measure = new PathMeasure(path, false); // 将Path与PathMeasure关联float len1 = measure.getLength(); // 获得第一条路径的长度measure.nextContour(); // 跳转到下一条路径float len2 = measure.getLength(); // 获得第二条路径的长度Log.i("LEN","len1="+len1); // 输出两条路径的长度Log.i("LEN","len2="+len2); log输出结果: 12com.gcssloop.canvas I/LEN: len1=800.0com.gcssloop.canvas I/LEN: len2=1600.0 通过测试，我们可以得到以下内容： 1.曲线的顺序与 Path 中添加的顺序有关。 2.getLength 获取到到是当前一条曲线分长度，而不是整个 Path 的长度。 3.getLength 等方法是针对当前的曲线。 getPosTan这个方法是用于得到路径上某一长度的位置以及该位置的正切值： 1boolean getPosTan (float distance, float[] pos, float[] tan) 参数释义： 使用 Math.atan2(tan[1], tan[0]) 将 tan 转化为角(单位为弧度)的时候要注意参数顺序。 12345// 省略部分代码tan = new float[2];PathMeasure measure = new PathMeasure(path, false); // 创建 PathMeasuremeasure.getPosTan(measure.getLength() * currentValue, pos, tan); // 获取当前位置的坐标以及趋势float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // 计算图片旋转角度 getMatrix这个方法是用于得到路径上某一长度的位置以及该位置的正切值的矩阵： boolean getMatrix (float distance, Matrix matrix, int flags) 方法参数含义： 12345//示意操作// 获取当前位置的坐标以及趋势的矩阵measure.getMatrix(measure.getLength() * currentValue, mMatrix, PathMeasure.TANGENT_MATRIX_FLAG | PathMeasure.POSITION_MATRIX_FLAG);mMatrix.preTranslate(-mBitmap.getWidth() / 2, -mBitmap.getHeight() / 2); Path &amp; SVG我们知道，用Path可以创建出各种个样的图形，但如果图形过于复杂时，用代码写就不现实了，不仅麻烦，而且容易出错，所以在绘制复杂的图形时我们一般是将 SVG 图像转换为 Path。 什么是SVG？SVG 是一种矢量图，内部用的是 xml 格式化存储方式存储这操作和数据，你完全可以将 SVG 看作是 Path 的各项操作简化书写后的存储格式。 Path 和 SVG 结合通常能诞生出一些奇妙的东西，具体去查看其它文章。]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2020%2F04%2F09%2F%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[概述贝塞尔曲线的运用是十分广泛的，可以说贝塞尔曲线奠定了计算机绘图的基础(因为它可以将任何复杂的图形用精确的数学语言进行描述)，在你不经意间就已经使用过它了。 贝塞尔曲线作用十分广泛，简单举几个的例子: QQ小红点拖拽效果 一些炫酷的下拉刷新控件 阅读软件的翻书效果 一些平滑的折线图的制作 很多炫酷的动画效果 了解贝塞尔曲线的原理贝塞尔曲线是用一系列点来控制曲线状态的，这些点简单分为两类： 一阶曲线原理：一阶曲线是没有控制点的，仅有两个数据点(A 和 B)，最终效果一个线段。 上图表示的是一阶曲线生成过程中的某一个阶段，动态过程可以参照下图(本文中贝塞尔曲线相关的动态演示图片来自维基百科)。 一阶曲线其实就是前面讲解过的lineTo 公式：B(t)就是运动点在t时刻的坐标，p0起点，p1终点 二阶曲线原理：二阶曲线由两个数据点(A 和 C)，一个控制点(B)来描述曲线状态，大致如下： 上图中红色曲线部分就是传说中的二阶贝塞尔曲线，动图生成过程： 二阶对应的方法就是quadTo() 公式：起点P0和終点P2，控制点就是P1，运动点在P0,P1，P2三个点的约束下，运动形成的轨迹就是红色的曲线 三阶曲线原理：三阶曲线由两个数据点(A 和 D)，两个控制点(B 和 C)来描述曲线状态，如下： 动态描述： 三阶曲线对应的方法是cubicTo 公式： 实战：做一个水位上升的动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class BezierView :View &#123; val mPaint = Paint(Paint.ANTI_ALIAS_FLAG) val mPath = Path() val paint = Paint(Paint.ANTI_ALIAS_FLAG) var viewWidth = 0f //控件的宽高 var viewHeight = 0f var commandX = 0f //控制点的坐标 var commandY = 0f var waterHeight = 0f //水位高度 var isInc = true //判断控制点是该右移还是左移 constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context?) : super(context) //初始化画笔 路径 init &#123; //画笔 mPaint.color = Color.parseColor("#AFDEE4") //辅助画笔 paint.color = Color.RED paint.strokeWidth = 5f &#125; //获取控件的宽和高 override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) viewWidth = w.toFloat() viewHeight = h.toFloat() //控制点 开始时的y坐标 commandY = 7/8f * viewHeight //终点一开始的y坐标，也是就水位水平高度 红色辅助线 waterHeight = 15/16f * viewHeight &#125; //绘制 override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) //起始点位置 mPath.moveTo(-1/4f*viewWidth,waterHeight) //绘制水波浪 mPath.quadTo(commandX,commandY,viewWidth + 1/4f*viewWidth,waterHeight) //绘制波浪下方闭合区域 mPath.lineTo(viewWidth+1/4f*viewWidth,viewHeight) //这里的绘制过程画图看看就明白了，画完波浪往下画一条线，再往左画一条线，最后闭合 mPath.lineTo(-1/4f*viewWidth,viewHeight) mPath.close() //绘制路径 canvas.drawPath(mPath,mPaint) //绘制红色水位高度辅助线 canvas.drawLine(0f,waterHeight,viewWidth,waterHeight,paint) //产生波浪左右涌动的感觉 if (commandX &gt;= viewWidth + 1 / 4F * viewWidth) &#123;//控制点坐标大于等于终点坐标改标识 isInc = false; &#125; else if (commandX &lt;= -1 / 4F * viewWidth) &#123;//控制点坐标小于等于起点坐标改标识 isInc = true; &#125; commandX = if (isInc) commandX + 20 else commandX - 20 //水位不断加高 当距离控件顶端还有1/8的高度时，不再上升 if (commandY &gt;= 1 / 8f * viewHeight) &#123; commandY -= 2; waterHeight -= 2; &#125; //路径重置 mPath.reset(); // 重绘 invalidate(); &#125; //测量 override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec) val wSpecMode = MeasureSpec.getMode(widthMeasureSpec) val wSpecSize = MeasureSpec.getSize(widthMeasureSpec) val hSpecMode = MeasureSpec.getMode(heightMeasureSpec) val hSpecSize = MeasureSpec.getSize(heightMeasureSpec) if (wSpecMode == MeasureSpec.AT_MOST &amp;&amp; hSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(300, 300) &#125; else if (wSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(300, hSpecSize) &#125; else if (hSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(wSpecSize, 300) &#125; &#125;&#125;]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas绘制自定义图形]]></title>
    <url>%2F2020%2F04%2F08%2FCanvas%E7%BB%98%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[Path操作速查表 Canvas绘制自定义图形前面写的就是Canvas 所有的简单图形的绘制。除了简单图形的绘制， Canvas 还可以使用 drawPath(Path path) 来绘制自定义图形。 drawPath(Path path, Paint paint) 画自定义图形前面的那些方法，都是绘制某个给定的图形，而 drawPath() 可以绘制自定义图形。当你要绘制的图形比较特殊，使用前面的那些方法做不到的时候，就可以使用 drawPath() 来绘制。 drawPath(path) 这个方法是通过描述路径的方式来绘制图形的，它的 path 参数就是用来描述图形路径的对象。path 的类型是 Path ，使用方法大概像下面这样： 12345678910111213141516171819class MyView : View &#123; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) val paint = Paint() val path = Path() override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) paint.color = Color.RED paint.style = Paint.Style.FILL path.addArc(200f, 200f, 400f, 400f, -225f, 225f); path.arcTo(400f, 200f, 600f, 400f, -180f, 225f, false); path.lineTo(400f, 542f); canvas.drawPath(path,paint) &#125;&#125; Path 可以描述直线、二次曲线、三次曲线、圆、椭圆、弧形、矩形、圆角矩形。把这些图形结合起来，就可以描述出很多复杂的图形。 Path 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。 Path 方法第一类：直接描述路径第一组： addXxx() ——添加子图形 addCircle(float x, float y, float radius, Direction dir) 添加圆 x, y, radius 这三个参数是圆的基本信息，最后一个参数 dir 是画圆的路径的方向。 路径方向有两种：顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于普通情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围的。下面再讨论dir这个参数 在用 addCircle() 为 Path 中新增一个圆之后，调用 canvas.drawPath(path, paint) ，就能画一个圆出来 12path.addCircle(300f,300f,200f,Path.Direction.CW)canvas.drawPath(path,paint) 其他的 Path.add-() 方法和这类似，例如： addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir) 添加椭圆 addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir) 添加矩形 addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加圆角矩形 addPath(Path path) 添加另一个 Path 和前面addCircle()的使用都差不多，不再做过多介绍 第二组：xxxTo() ——画线（直线或曲线） lineTo(float x, float y) / rLineTo(float x, float y) 画直线 从当前位置向目标位置画一条直线， x 和 y 是目标位置的坐标。这两个方法的区别是，lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。 当前位置：所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 123paint.setStyle(Style.STROKE);path.lineTo(100, 100); // 由当前位置 (0, 0) 向 (100, 100) 画一条直线path.rLineTo(100, 0); // 由当前位置 (100, 100) 向正右方 100 像素的位置画一条直线 quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) 画二次贝塞尔曲线 这条二次贝塞尔曲线的起点就是当前位置，而参数中的 x1, y1 和 x2, y2 则分别是控制点和终点的坐标。和 rLineTo(x, y) 同理，rQuadTo(dx1, dy1, dx2, dy2) 的参数也是相对坐标 cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 画三次贝塞尔曲线 moveTo(float x, float y) / rMoveTo(float x, float y) 移动到目标位置 不论是直线还是贝塞尔曲线，都是以当前位置作为起点，而不能指定起点。但你可以通过 moveTo(x, y) 或 rMoveTo() 来改变当前位置，从而间接地设置这些方法的起点。 123path.lineTo(300f,300f) //画斜线path.moveTo(600f,300f) //移动点path.lineTo(600f,0f) //画直线 moveTo(x, y) 虽然不添加图形，但它会设置图形的起点，所以它是非常重要的一个辅助方法。 第二组还有两个特殊的方法： arcTo() 和 addArc()。它们也是用来画线的，但并不使用当前位置作为弧线的起点。 arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) arcTo(RectF oval, float startAngle, float sweepAngle) 画弧形 这个方法和 Canvas.drawArc() 比起来，少了一个参数 useCenter，而多了一个参数 forceMoveTo 。 少了 useCenter ，是因为 arcTo() 只用来画弧形而不画扇形，所以不再需要 useCenter 参数；而多出来的这个 forceMoveTo 参数的意思是，绘制是要「抬一下笔移动过去」，还是「直接拖着笔过去」，区别在于是否留下移动的痕迹 123path.lineTo(100f,100f)path.arcTo(100f,100f,300f,300f,-90f,90f,true) //前面4个参数代表所在椭圆的上下左右4个顶点距离父容器左边和上边的距离，第5个参数表示从-90度位置开始画，第6个参数表示划过90弧度，第7个参数表示直接从前面（100,100）点的位置移过来，不留痕迹canvas.drawPath(path,paint) 123path.lineTo(100f,100f)path.arcTo(100f,100f,300f,300f,-90f,90f,false) //这次留下移动轨迹，直接连线连到弧形起点canvas.drawPath(path,paint) addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle) 又是一个弧形的方法。一个叫 arcTo ，一个叫 addArc()，都是弧形，区别在哪里？其实很简单： addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() ，其只有6个参数。 close() 封闭当前子图形 它的作用是把当前的子图形封闭，即由当前位置向当前子图形的起点绘制一条直线。 1234path.moveTo(300f,300f)path.lineTo(600f,300f)path.lineTo(450f,450f)canvas.drawPath(path,paint) //未使用close 12345path.moveTo(300f,300f)path.lineTo(600f,300f)path.lineTo(450f,450f)path.close() //调用close来封闭图形 path.lineTo(300f, 300f)canvas.drawPath(path,paint) close() 和 lineTo(起点坐标) 是完全等价的。 不是所有的子图形都需要使用 close() 来封闭。当需要填充图形时（即 Paint.Style 为 FILL 或 FILL_AND_STROKE），Path 会自动封闭子图形 12345paint.style = Paint.Style.FILLpath.moveTo(300f,300f)path.lineTo(600f,300f)path.lineTo(450f,450f)canvas.drawPath(path,paint) 以上就是 Path 的第一类方法：直接描述路径的。 Path 方法第二类：辅助的设置或计算这类方法的使用场景比较少,理解其中一个方法： setFillType(FillType fillType)。 Path.setFillType(Path.FillType ft) 设置填充方式 前面在说 dir 参数的时候提到， Path.setFillType(fillType) 是用来设置图形自相交时的填充算法的： 方法中填入不同的 FillType 值，就会有不同的填充效果。FillType 的取值有四个： EVEN_ODD WINDING （默认值） INVERSE_EVEN_ODD INVERSE_WINDING 其中后面的两个带有 INVERSE_ 前缀的，只是前两个的反色版本，所以只要把前两个，即 EVEN_ODD 和 WINDING，搞明白就可以了。 先来看一下通常情形下的效果 接下来了解一下填充的原理 EVEN_ODD 即 even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。射线的方向无所谓，同一个点射向任何方向的射线，结果都是一样的还以左右相交的双圆为例： WINDING 即 non-zero winding rule （非零环绕数原则）：首先，它需要你图形中的所有线条都是有绘制方向的： 然后，同样是从平面中的点向任意方向射出一条射线，但计算规则不一样：以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。和前面奇偶规则一样，射线的方向并不影响结果。 关于图形的方向 图形的方向：对于添加子图形类方法（如 Path.addCircle() Path.addRect()）的方向，由方法的 dir 参数来控制，这个在前面已经讲过了；而对于画线类的方法（如 Path.lineTo() Path.arcTo()）就更简单了，线的方向就是图形的方向。 所以，完整版的 EVEN_ODD 和 WINDING 的效果应该是这样的： Canvas绘制Bitmap和文字drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap 绘制 Bitmap 对象，也就是把这个 Bitmap 中的像素内容贴过来。其中 left 和 top 是要把 bitmap 绘制到的位置坐标。它的使用非常简单。 123456789101112131415class MyView : View &#123; constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) val paint = Paint() val bitmap = BitmapFactory.decodeResource(context.resources,R.drawable.test_006) override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) paint.color = Color.RED paint.style = Paint.Style.FILL paint.strokeWidth = 10f canvas.drawBitmap(bitmap,300f,300f,paint) &#125;&#125; 它还有一些重载方法，不列举了 drawText(String text, float x, float y, Paint paint) 绘制文字 界面里所有的显示内容，都是绘制出来的，包括文字。 drawText() 这个方法就是用来绘制文字的。参数 text 是用来绘制的字符串，x 和 y 是绘制的起点坐标。 Paint.setTextSize(float textSize) 123paint.setTextSize(18);canvas.drawText(text, 100, 25, paint);paint.setTextSize(36); 重置路径重置Path有两个方法，分别是reset和rewind，两者区别主要有一下两点： 这个两个方法应该何时选择呢？ 选择权重: FillType &gt; 数据结构 因为“FillType”影响的是显示效果，而“数据结构”影响的是重建速度。]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas和Paint基础]]></title>
    <url>%2F2020%2F04%2F08%2FCanvas%E5%92%8CPaint%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Canvas常用操作速查表 Canvas.drawXXX() 和 Paint 基础drawXXX() 系列方法和 Paint 的基础掌握了，就能够应付简单的绘制需求。它们主要包括： Canvas 类下的所有 draw- 打头的方法，例如 drawCircle() drawBitmap()。 Paint 类的几个最常用的方法。具体是： Paint.setStyle(Style style) 设置绘制模式 Paint.setColor(int color) 设置颜色 Paint.setStrokeWidth(float width) 设置线条宽度 Paint.setTextSize(float textSize) 设置文字大小 Paint.setAntiAlias(boolean aa) 设置抗锯齿开关 Paint系列简单方法Paint.setColor(int color)要画一个红色的圆，并不是写成 canvas.drawCircle(300, 300, 200, RED, paint) 这样，而是像下面这样： 12paint.setColor(Color.RED); // 设置为红色canvas.drawCircle(300, 300, 200, paint); Paint.setStyle(Paint.Style style)etStyle(Style style) 这个方法设置的是绘制的 Style 。Style 具体来说有三种： FILL, STROKE 和 FILL_AND_STROKE 。FILL 是填充模式，STROKE是画线模式（即勾边模式），FILL_AND_STROKE 是两种模式一并使用：既画线又填充。它的默认值是 FILL，填充模式。 而如果你想画的不是实心圆，而是空心圆（或者叫环形），也可以使用paint.setStyle(Paint.Style.STROKE) 来把绘制模式改为画线模式。 Paint.setStrokeWidth(float width)在 STROKE 和 FILL_AND_STROKE 下，还可以使用 paint.setStrokeWidth(float width) 来设置线条的宽度,单位也是像素。 开启抗锯齿在绘制的时候，往往需要开启抗锯齿来让图形和文字的边缘更加平滑。开启抗锯齿很简单，只要在 new Paint() 的时候加上一个 ANTI_ALIAS_FLAG参数就行。另外，你也可以使用 Paint.setAntiAlias(boolean aa) 来动态开关抗锯齿。 1Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); Canvas的draw系列方法Canvas.drawColor(@ColorInt int color) 颜色填充这是最基本的 drawXXX() 方法：在整个绘制区域统一涂上指定的颜色。例如 drawColor(Color.BLACK) 会把整个区域染成纯黑色。 类似的方法还有 drawRGB(int r, int g, int b) 和 drawARGB(int a, int r, int g, int b) ，它们和 drawColor(color) 只是使用方式不同，作用都是一样的。 这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。 drawCircle(float centerX, float centerY, float radius, Paint paint) 画圆前两个参数 centerX ，centerY 是圆心的坐标，第三个参数 radius 是圆的半径，单位都是像素，它们共同构成了这个圆的基本信息（即用这几个信息可以构建出一个确定的圆）；第四个参数 paint ，它提供基本信息之外的所有风格信息，例如颜色、线条粗细、阴影等。 drawRect(float left, float top, float right, float bottom, Paint paint) 画矩形left, top, right, bottom 是矩形四条边的坐标。(含义是left和right距view坐标系左边、top和bottom距上边的距离) 另外，它还有两个重载方法 drawRect(RectF rect, Paint paint) 和 drawRect(Rect rect, Paint paint) ，让你可以直接填写 RectF 或 Rect 对象来绘制矩形。 drawPoint(float x, float y, Paint paint) 画点x 和 y 是点的坐标。点的大小可以通过 paint.setStrokeWidth(width) 来设置；点的形状可以通过 paint.setStrokeCap(cap) 来设置：ROUND 画出来是圆形的点，SQUARE 或 BUTT 画出来是方形的点。 123paint.setStrokeWidth(20);paint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(50, 50, paint); drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 画点（批量）1234float[] points = &#123;0, 0, 50, 50, 50, 100, 100, 50, 100, 100, 150, 50, 150, 100&#125;;// 绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)canvas.drawPoints(points, 2 /* 跳过两个数，即前两个 0 */, 8 /* 一共绘制 8 个数（4 个点）*/, paint); drawOval(float left, float top, float right, float bottom, Paint paint) 画椭圆另外，它还有一个重载方法 drawOval(RectF rect, Paint paint)，让你可以直接填写 RectF 来绘制椭圆。 drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 画线startX, startY, stopX, stopY 分别是线的起点和终点坐标。由于直线不是封闭图形，所以 setStyle(style) 对直线没有影响。 drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 画线（批量）12float[] points = &#123;20, 20, 120, 20, 70, 20, 70, 120, 20, 120, 120, 120, 150, 20, 250, 20, 150, 20, 150, 120, 250, 20, 250, 120, 150, 120, 250, 120&#125;;canvas.drawLines(points, paint); drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) 画圆角矩形left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。 1canvas.drawRoundRect(100, 100, 500, 300, 50, 50, paint); 它还有一个重载方法 drawRoundRect(RectF rect, float rx, float ry, Paint paint)，让你可以直接填写 RectF 来绘制圆角矩形。 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 绘制弧形或扇形drawArc() 是使用一个椭圆来描述弧形的。left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 绘制的时候都是顺时针绘制的 12canvas.drawArc(200f,100f,800f,500f,-110f,100f,true,paint)//从-110度位置开始顺时针绘制划过100度canvas.drawArc(200f,100f,800f,500f,0f,180f,true,paint)//从0度位置开始顺时针绘制划过180度（绘制了个半圆）]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View绘制流程]]></title>
    <url>%2F2020%2F04%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[参考：http://www.gcssloop.com/category/customview 简述View的工作流程主要是指 measure、layout、draw这三大流程，即测量、布局和绘制。其中 measure 确定 View 的测量宽/高，layout 确定 View 的最终宽/高和四个顶点的位置，而 draw 则将View 绘制到屏幕上。 简版自定义View绘制流程 流程中的函数构造函数构造函数是View的入口，可以用于初始化一些的内容，和获取自定义属性。 View的构造函数有四种重载分别如下: 1234public void SloopView(Context context) &#123;&#125;public void SloopView(Context context, AttributeSet attrs) &#123;&#125;public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; 前两个最常用 12345//一般在直接New一个View的时候调用。public void SloopView(Context context) &#123;&#125;//一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。public void SloopView(Context context, AttributeSet attrs) &#123;&#125; 以下方法调用的是一个参数的构造函数： 12//在Avtivity中SloopView view = new SloopView(this); 以下方法调用的是两个参数的构造函数： 1234//在layout文件中 - 格式为： 包名.View名&lt;com.sloop.study.SloopView android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 测量View的大小（onMeasure）View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。 测量View大小使用的是onMeasure函数，我们可以从onMeasure的两个参数中取出宽高的相关数据： 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthsize MeasureSpec.getSize(widthMeasureSpec); //取出宽度的确切数值 int widthmode MeasureSpec.getMode(widthMeasureSpec); //取出宽度的测量模式 int heightsize MeasureSpec.getSize(heightMeasureSpec); //取出高度的确切数值 int heightmode MeasureSpec.getMode(heightMeasureSpec); //取出高度的测量模式&#125; 从上面可以看出 onMeasure 函数中有 widthMeasureSpec 和 heightMeasureSpec 这两个 int 类型的参数， 毫无疑问他们是和宽高相关的， 但它们其实不是宽和高， 而是由宽、高和各自方向上对应的测量模式来合成的一个值： 测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中： 实际上关于上面的东西了解即可，在实际运用之中只需要记住有三种模式，用 MeasureSpec 的 getSize是获取数值， getMode是获取模式即可。 如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsie) 这个函数。 确定View大小（onSizeChanged）这个函数在视图大小发生改变时调用。 在测量完View并使用setMeasuredDimension函数之后View的大小基本上已经确定了,但View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。 onSizeChanged如下： 1234@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh);&#125; 可以看出，它又四个参数，分别为 宽度，高度，上一次宽度，上一次高度。 这个函数比较简单，我们只需关注 宽度(w), 高度(h) 即可，这两个参数就是View最终的大小。 确定子View布局位置（onLayout）确定布局的函数是onLayout，它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数 在自定义ViewGroup中，onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用以下函数设置子View位置。 1child.layout(l, t, r, b); 四个参数分别为： 绘制内容（onDraw）onDraw是实际绘制的部分，也就是我们真正关心的部分，使用的是Canvas绘图。 1234@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);&#125; 对外提供操作方法和监听回调自定义完View之后，一般会对外暴露一些接口，用于控制View的状态等，或者监听View的变化.]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap详解]]></title>
    <url>%2F2020%2F04%2F08%2FBitmap%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述Bitmap图像处理的最重要类之一。用它可以获取图像文件信息，进行图像颜色变换、剪切、旋转、缩放等操作，并可以指定格式保存图像文件 Bitmap类重要函数1234567891011121314151617public void recycle() // 回收位图占用的内存空间，把位图标记为Deadpublic final boolean isRecycled() //判断位图内存是否已释放 public final int getWidth()//获取位图的宽度 public final int getHeight()//获取位图的高度public final boolean isMutable()//图片是否可修改 public int getScaledWidth(Canvas canvas)//获取指定密度转换后的图像的宽度 public int getScaledHeight(Canvas canvas)//获取指定密度转换后的图像的高度 public boolean compress(CompressFormat format, int quality, OutputStream stream)//按指定的图片格式以及画质，将图片转换为输出流。 format：Bitmap.CompressFormat.PNG或Bitmap.CompressFormat.JPEG quality：画质，0-100.0表示最低画质压缩，100以最高画质压缩。对于PNG等无损格式的图片，会忽略此项设置。public static Bitmap createBitmap(Bitmap src) //以src为原图生成不可变得新图像 public static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter)//以src为原图，创建新的图像，指定新图像的高宽以及是否可变。 public static Bitmap createBitmap(int width, int height, Config config)——创建指定格式、大小的位图 public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height)以source为原图，创建新的图片，指定起始坐标以及新图像的高宽。public static createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter)// 倒数第二个是Matrix参数，进行平移、缩放、旋转等操作 在Android中Bitamp指的就是一张图片，一般是png和jpeg格式。 Bitmap类中有一个enum类型的Config，其中有4个值: ALPHA_88位位图；1 个字节，只有透明度，没有颜色值 RGB_56516位位图；2 个字节，r = 5，g = 6，b = 5，一个像素点 5+6+5 = 16 ARGB_444416位位图；2 个字节，a = 4，r = 4，g = 4，b = 4，一个像素点 4+4+4+4 = 16 ARGB_888832 位位图； 4个字节，a = 8，r = 8，g = 8， b = 8，一个像素点 8 + 8 + 8 + 8 = 32 源码中默认采用ARGB_8888 参数理解： 1234567* @param source 原始 Bitmap* @param x 在原始 Bitmap 中 x方向的其起始坐标（你可能只需要原始 Bitmap x方向上的一部分）* @param y 在原始 Bitmap 中 y方向的其起始坐标（你可能只需要原始 Bitmap y方向上的一部分）* @param width 需要返回 Bitmap 的宽度（px）（如果超过原始Bitmap宽度会报错）* @param height 需要返回 Bitmap 的高度（px）（如果超过原始Bitmap高度会报错）* @param m Matrix类型，表示需要做的变换操作* @param filter 是否需要过滤，只有 matrix 变换操作才有效 理解： 一张 1024 * 1024 像素，采用ARGB8888格式，一个像素32位，每个像素就是4字节，占有内存就是4M 若采用RGB565，一个像素16位，每个像素就是2字节，占有内存就是2M。两个开源库Glide和Picasso, Glide加载图片默认格式RGB565，Picasso为ARGB8888，默认情况下，Glide占用内存会比Picasso低，色彩不如Picasso鲜艳，自然清晰度就低. BitmapFactory工厂类Option 参数类: 12345678910111213141516public boolean inJustDecodeBounds//如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息。public int inSampleSize//采样率public int outWidth//获取图片的宽度值public int outHeight//获取图片的高度值 public int inDensity//用于位图的像素压缩比 public int inTargetDensity//用于目标位图的像素压缩比（要生成的位图） public byte[] inTempStorage //创建临时文件，将图片存储public boolean inScaled//设置为true时进行图片压缩，从inDensity到inTargetDensitypublic boolean inDither //如果为true,解码器尝试抖动解码public Bitmap.Config inPreferredConfig //设置解码器public String outMimeType //设置解码图像public boolean inPurgeable//当存储Pixel的内存空间在系统内存不足时是否可以被回收public boolean inInputShareable //inPurgeable为true情况下才生效，是否可以共享一个InputStreampublic boolean inPreferQualityOverSpeed //为true则优先保证Bitmap质量其次是解码速度public boolean inMutable //配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段public int inScreenDensity //当前屏幕的像素密度 参数 inSampleSize 的理解： 这个是读取bitmap时用到的属性,是为了对原图降采样 比如原图是一个 4000 4000 点阵的图,占用内存就是 4000 4000 单个像素占用字节数单个像素占用字节数取决于你用的是 RGB565, ARGB8888 等. 4000 4000 这个解析度已很接近目前市面主流机器的默认照片解析度.假设你用的是RGB565解析这张图,那一个点就占用2个字节.如果完整解析这个图片,就需要 大约3.2MB的内存.如果你用了一个GridView,同时显示了30张这种图,那几乎可以确定你会收到一个OOM异常. 所以需要对这种大图进行降采样,以减小内存占用.毕竟拇指大小的地方根本用不着显示那么高的解析度.因为直接从点阵中隔行抽取最有效率,所以为了兼顾效率, inSampleSize 这个属性只认2的整数倍为有效.比如你将 inSampleSize 赋值为2,那就是每隔2行采1行,每隔2列采一列,那你解析出的图片就是原图大小的1/4.这个值也可以填写非2的倍数,非2的倍数会被四舍五入，向下寻找2的整数次幂. 综上,用这个参数解析bitmap就是为了减少内存占用. inSampleSize的默认值和最小值为1（当小于1时，解码器将该值当做1来处理） 那如何设置 inSampleSize 呢？ 1234567891011121314151617181920212223/** * @description 计算图片的压缩比率 * * @param options 参数 * @param reqWidth 目标的宽度 * @param reqHeight 目标的高度 * @return */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; // 计算出实际宽高和目标宽高的比率 final int halfHeight = height / 2; final int halfWidth = width / 2; while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize; &#125; 看一下insampleSize的效果 1234val bitmap = BitmapFactory.decodeResource(resources,R.drawable.img_002) Log.d("bitmap",""+bitmap.width+" "+bitmap.height) //原图大小 val bitmap2 = decodeBitmap(resources,R.drawable.img_002,250,360) Log.d("bitmap2",""+bitmap2.width+" "+bitmap2.height) // 使用了InsimpleSize，这里为4 看下图 可见，当inSampleSize大小为4时，得到的bitmap宽高都为原来的1/4 参数inpreferredconfig理解： 如果inPreferredConfig不为null，解码器会尝试使用此参数指定的颜色模式来对图片进行解码，如果inPreferredConfig为null或者在解码时无法满足此参数指定的颜色模式，解码器会自动根据原始图片的特征以及当前设备的屏幕位深，选取合适的颜色模式来解码，例如，如果图片中包含透明度，那么对该图片解码时使用的配置就需要支持透明度，默认会使用ARGB_8888来解码。也就是说inPreferredConfig指定的配置并非是一个强制选项，而是建议的（preferred）选项，Android在实际解码时会参考此参数的配置，但如果此配置不满足，Android会重新选取一个合适的配置来对图片进行解码。 这里说明一下，网上存在一种说法，设置RGB565选项可以减少内存。经过实际的分析，基本上指定inPreferredConfig为RGB565和不设置inPreferredConfig的效果是一样的。 工厂方法： 12345678910public static Bitmap decodeFile(String pathName, Options opts) //从文件读取图片 public static Bitmap decodeFile(String pathName)public static Bitmap decodeStream(InputStream is) //从输入流读取图片public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts)public static Bitmap decodeResource(Resources res, int id) //从资源文件读取图片public static Bitmap decodeResource(Resources res, int id, Options opts) public static Bitmap decodeByteArray(byte[] data, int offset, int length) //从数组读取图片public static Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)public static Bitmap decodeFileDescriptor(FileDescriptor fd)//从文件读取文件 与decodeFile不同的是这个直接调用JNI函数进行读取 效率比较高public static Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts) 重点说明 在不配置Options的情况下： 1、decodeFile、decodeStream在解析时不会对Bitmap进行一系列的屏幕适配，解析出来的将是原始大小的图 2、decodeResource在解析时会对Bitmap根据当前设备屏幕像素密度densityDpi的值进行缩放适配操作，使得解析出来的Bitmap与当前设备的分辨率匹配，达到一个最佳的显示效果，并且Bitmap的大小将比原始的大 看一下用decodeResource解析出来的和原图的对比 图片操作1.获取图片长宽 12345678val options = BitmapFactory.Options() //如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息。 options.inJustDecodeBounds = true BitmapFactory.decodeResource(context.resources,R.drawable.peitu03,options) val srcWidth = options.outWidth val srcHeight = options.outHeight Log.d("test","宽:"+srcWidth+" 高："+srcHeight) //test: 宽:198 高：151 2.对图片进行缩放 1234 val matrix = Matrix() matrix.postScale(0.5f,0.5f) val bitmap = Bitmap.createBitmap(bitmap2,0,0,500,400,matrix,true)//得到 250*200大小的 3.简单的压缩处理 我这里有一张6m左右的图片，按照正常的加载bitmap，程序肯定加载不出来，因为图片过大 12345//直接加载，报错val bitmap = BitmapFactory.decodeResource(this.resources,R.drawable.img_009)iv.setImageBitmap(bitmap)//报此异常 trying to draw too large(463147136bytes) bitmap 因此，为了能让图片加载出来，我们可以对图片进行简单的压缩处理，这里就要用到前面讲的那个Options的参数 inSampleSize 123456789101112131415161718192021222324252627282930313233343536val bitmap = decodeBitmap(this.resources,R.drawable.img_009,400,600)iv.setImageBitmap(bitmap)//对图片进行简单的压缩处理fun decodeBitmap(res: Resources,resId: Int,targetWidth: Int,targetHeight: Int): Bitmap &#123; Log.d("bitmap","参数宽高"+targetWidth+" "+targetHeight) val options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeResource(res,resId,options) options.inSampleSize = calculateInSampleSize(options,targetWidth,targetHeight) Log.d("bitmap","insamplesize: "+options.inSampleSize) options.inJustDecodeBounds = false return BitmapFactory.decodeResource(res,resId,options) &#125; //取得合适的InSampleSize的值 fun calculateInSampleSize( options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int ): Int &#123; val width = options.outWidth val height = options.outHeight var inSampleSize = 1 if (height &gt; reqHeight || width &gt; reqWidth) &#123; //计算图片高度和我们需要高度的最接近比例值 val heightRatio = Math.round(height.toFloat() / reqHeight.toFloat()) //宽度比例值 val widthRatio = Math.round(width.toFloat() / reqWidth.toFloat()) //取比例值中的较大值作为inSampleSize inSampleSize = if (heightRatio &gt; widthRatio) heightRatio else widthRatio &#125; return inSampleSize &#125; 可见可以加载出来了： 几个方法1.compress方法 构造方法： compress(Bitmap.CompressFormat format, int quality, OutputStream stream) 将bitmap数据质量压缩并转换成流，若format参数设置为了png格式，quality设置无效 format 图片的格式，支持3种JPEG,PNG,WEBP quality 压缩质量压缩率，0-100，0表示压缩程度最大，100为原质量，但png无效 stream 输出流 返回值,boolean 简单使用 1234567891011121314151617181920212223242526int count = image.getWidth() * image.getHeight() / 1024;Log.d("bitmap:compress", "压缩前:" + count);ByteArrayOutputStream bout = new ByteArrayOutputStream();// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中image.compress(Bitmap.CompressFormat.JPEG, 50, bout); //修改第二个参数 count = image.getWidth() * image.getHeight() / 1024;Log.d("bitmap:compress", "压缩后:" + count);Log.d("bitmap:compress", "压缩后:" + bout.toByteArray().length / 1024);运行以上代码--输出: 压缩前 85 压缩后 85 压缩后 24 --如果将第二个参数50改为10 则会压缩前 85 压缩后 85 压缩后 13 -- 可以发现bitmap基本上没有被压缩，因为我们一开始就提到了compress压缩是存储压缩，不是内存压缩，所以在内存中并没有改变大小，但bytes本身变小了，适合存储和传输！ 这种压缩方法之所以称之为质量压缩，是因为它不会减少图片的像素。它是在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的。进过它压缩的图片文件大小会有改变，但是导入成bitmap后占得内存是不变的。因为要保持像素不变，所以它就无法无限压缩，到达一个值之后就不会继续变小了。显然这个方法并不适用与缩略图，其实也不适用于想通过压缩图片减少内存的适用，仅仅适用于想在保证图片质量的同时减少文件大小的情况而已。 2.copy方法 构造方法： copy(Bitmap.Config config, boolean isMutable) 拷贝一个Bitmap的像素到一个新的指定信息配置的Bitmap config 配置信息 isMutable 是否支持可改变可写入 返回值，bitmap，成功返回一个新的bitmap，失败就null 12Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.m); bitmap = bitmap.copy(Bitmap.Config.RGB_565,true);]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义view基础]]></title>
    <url>%2F2020%2F04%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[自定义View绘制知识的需要了解掌握的四个内容 1.Canvas 的 drawXXX() 系列方法及 Paint 最常见的使用Canvas.drawXXX() 是自定义绘制最基本的操作。掌握了这些方法，你才知道怎么绘制内容，例如怎么画圆、怎么画方、怎么画图像和文字。组合绘制这些内容，再配合上 Paint 的一些常见方法来对绘制内容的颜色和风格进行简单的配置，就能够应付大部分的绘制需求了。 2.Paint 的内容Paint 可以做的事，不只是设置颜色，也不只是实心空心、线条粗细、有没有阴影，它可以做的风格设置真的是非常多、非常细 3.Canvas 对绘制的辅助——范围裁切和几何变换。大多数时候，它们并不会被用到，但一旦用到，通常都是很炫酷的效果。 4.使用不同的绘制方法来控制绘制顺序控制绘制顺序解决的并不是「做不到」的问题，而是性能问题。同样的一种效果，你不用绘制顺序的控制往往也能做到，但需要用多个 View 甚至是多层 View 才能拼凑出来，因此代价是 UI 的性能；而使用绘制顺序的控制的话，一个 View 就全部搞定了。 入门 绘制一个简单的圆新建一个MyView类,继承自View 123456789101112class MyView : View &#123; //这个构造函要添加 constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) val paint = Paint() override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) //绘制一个圆 canvas.drawCircle(300f,300f,200f,paint) &#125;&#125; 在xml布局文件中引用 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;com.ccc.myview.MyView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; 运行效果 View中的坐标系在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负（注意，是下正上负，不是上正下负，和上学时候学的坐标系方向不一样）。也就是下面这个样子。 所以一个 View 的坐标 (x, y) 处，指的就是相对它的左上角那个点的水平方向 x 像素、竖直方向 y 像素的点。例如，(300, 300) 指的就是左上角的点向右 300 、向下 300 的位置； (100, -50) 指的就是左上角的点向右 100 、向上 50 的位置。 也就是说， canvas.drawCircle(300, 300, 200, paint) 这行代码绘制出的圆，在 View 中的位置和尺寸应该是这样的： View的位置由4个顶点决定的（如下A、B、C、D） 4个顶点的位置描述分别由4个值决定： （记住：View的位置是相对于父控件而言的） Top：子View上边界到父view上边界的距离 Left：子View左边界到父view左边界的距离 Bottom：子View下边距到父View上边界的距离 Right：子View右边界到父view左边界的距离]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射学习]]></title>
    <url>%2F2020%2F02%2F24%2Fjava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介 定义：Java语言中 一种 动态（运行时）访问、检测 &amp; 修改它本身的能力 作用：动态（运行时）获取 类的完整结构信息 &amp; 调用对象的方法（类的结构信息包括：变量、方法等） 特点优点灵活性高。因为反射属于动态编译，即只有到运行时才动态创建 &amp;获取对象实例。 静态编译：在编译时确定类型 &amp; 绑定对象。如常见的使用new关键字创建对象 动态编译：运行时确定类型 &amp; 绑定对象。动态编译体现了Java的灵活性、多态特性 &amp; 降低类之间的藕合性 缺点 执行效率低 因为反射的操作 主要通过JVM执行，所以时间成本会 高于 直接执行相同操作 因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。 编译器难以对动态调用的代码提前做优化，比如方法内联。 反射需要按名检索类和方法，有一定的时间开销。 容易破坏类结构因为反射操作饶过了源码，容易干扰类原有的内部逻辑 应用场景 动态获取 类文件结构信息（如变量、方法等 &amp; 调用对象的方法 常用的需求场景有：动态代理、工厂模式优化、Java JDBC数据库操作等 使用反射能干啥？ 反射的实现主要是通过操作 java.lang.Class 类，因此来学一下这个类 java.lang.Class 类 定义：java.lang.Class类是反射机制的基础 作用：存放着对应类型对象的 运行时信息 在Java程序运行时，Java虚拟机为所有 类型 维护一个java.lang.Class对象 该Class对象存放着所有关于该对象的 运行时信息 泛型形式为Class&lt;T&gt; 看下面一段代码，对于2个String类型对象，它们的Class对象相同： 123Class c1 = "hello".getClass();Class c2 = Class.forName("java.lang.String"); //Class.forName()返回与给定的字符串名称相关联类或接口的Class对象。System.out.println(c1 == c2); // true 结论：每种类型的Class对象只有1个 = 地址只有1个 其他类 Java反射机制的实现除了依靠Java.lang.Class类，还需要依靠：Constructor类、Field类、Method类，分别作用于类的各个组成部分： 使用步骤在使用Java反射机制时，主要步骤包括： 获取目标类型的Class对象 通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象 通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作 步骤1：获取目标类型的Class对象获取目标类型的Class对象的方式主要有4种: 123456789101112131415161718192021222324252627282930&lt;-- 方式1：Object.getClass() --&gt; // Object类中的getClass()返回一个Class类型的实例 Boolean carson = true; Class&lt;?&gt; classType = carson.getClass(); System.out.println(classType); // 输出结果：class java.lang.Boolean &lt;-- 方式2：T.class 语法 --&gt; // T = 任意Java类型 Class&lt;?&gt; classType = Boolean.class; System.out.println(classType); // 输出结果：class java.lang.Boolean // 注：Class对象表示的是一个类型，而这个类型未必一定是类 // 如，int不是类，但int.class是一个Class类型的对象&lt;-- 方式3：static method Class.forName --&gt; Class&lt;?&gt; classType = Class.forName("java.lang.Boolean"); // 使用时应进行异常处理 System.out.println(classType); // 输出结果：class java.lang.Boolean &lt;-- 方式4：TYPE语法 --&gt; Class&lt;?&gt; classType = Boolean.TYPE; System.out.println(classType); // 输出结果：boolean 步骤2：通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 即以下方法都属于`Class` 类的方法。&lt;-- 1. 获取类的构造函数（传入构造函数的参数类型）-&gt;&gt; // a. 获取指定的构造函数 （公共 / 继承） Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // b. 获取所有的构造函数（公共 / 继承） Constructor&lt;?&gt;[] getConstructors(); // c. 获取指定的构造函数 （ 不包括继承） Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // d. 获取所有的构造函数（ 不包括继承） Constructor&lt;?&gt;[] getDeclaredConstructors(); // 最终都是获得一个Constructor类对象// 特别注意： // 1. 不带 "Declared" 的方法支持取出包括继承、公有（Public） &amp; 不包括私有（Private）的构造函数 // 2. 带 "Declared"的方法是支持取出包括公共（Public）、保护（Protected）、默认（包）访问和私有（Private）的构造方法，但不包括继承的构造函数 // 下面同理&lt;-- 2. 获取类的属性（传入属性名） --&gt; // a. 获取指定的属性（公共 / 继承） Field getField(String name) ; // b. 获取所有的属性（公共 / 继承） Field[] getFields() ; // c. 获取指定的所有属性 （不包括继承） Field getDeclaredField(String name) ； // d. 获取所有的所有属性 （不包括继承） Field[] getDeclaredFields() ；// 最终都是获得一个Field类对象&lt;-- 3. 获取类的方法（传入方法名 &amp; 参数类型）--&gt; // a. 获取指定的方法（公共 / 继承） Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ； // b. 获取所有的方法（公共 / 继承） Method[] getMethods() ； // c. 获取指定的方法 （ 不包括继承） Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) ； // d. 获取所有的方法（ 不包括继承） Method[] getDeclaredMethods() ；// 最终都是获得一个Method类对象&lt;-- 4. Class类的其他常用方法 --&gt;getSuperclass(); // 返回父类String getName(); // 作用：返回完整的类名（含包名，如java.lang.String ） Object newInstance(); // 作用：快速地创建一个类的实例// 具体过程：调用默认构造器（若该类无默认构造器，则抛出异常 // 注：若需要为构造器提供参数需使用java.lang.reflect.Constructor中的newInstance（） 步骤3：通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法 &amp; 属性的具体信息 &amp; 进行操作这部分方法很重要，熟练了后实际操作才能感受到反射的好用 1234567891011121314151617181920212223242526272829303132// 即以下方法都分别属于`Constructor`类、`Method`类 &amp; `Field`类的方法。&lt;-- 1. 通过Constructor 类对象获取类构造函数信息 --&gt; String getName()；// 获取构造器名 Class getDeclaringClass()；// 获取一个用于描述类中定义的构造器的Class对象 int getModifiers()；// 返回整型数值，用不同的位开关描述访问修饰符的使用状况 Class[] getExceptionTypes()；// 获取描述方法抛出的异常类型的Class对象数组 Class[] getParameterTypes()；// 获取一个用于描述参数类型的Class对象数组&lt;-- 2. 通过Field类对象获取类属性信息 --&gt; String getName()；// 返回属性的名称 Class getDeclaringClass()； // 获取属性类型的Class类型对象 Class getType()；// 获取属性类型的Class类型对象 int getModifiers()； // 返回整型数值，用不同的位开关描述访问修饰符的使用状况 Object get(Object obj) ；// 返回指定对象上 此属性的值 void set(Object obj, Object value) // 设置 指定对象上此属性的值为value &lt;-- 3. 通过Method 类对象获取类方法信息 --&gt; String getName()；// 获取方法名 Class getDeclaringClass()；// 获取方法的Class对象 int getModifiers()；// 返回整型数值，用不同的位开关描述访问修饰符的使用状况 Class[] getExceptionTypes()；// 获取用于描述方法抛出的异常类型的Class对象数组 Class[] getParameterTypes()；// 获取一个用于描述参数类型的Class对象数组&lt;--额外：java.lang.reflect.Modifier类 --&gt;// 作用：获取访问修饰符static String toString(int modifiers) // 获取对应modifiers位设置的修饰符的字符串表示static boolean isXXX(int modifiers) // 检测方法名中对应的修饰符在modifiers中的值 访问权限问题 背景 反射机制的默认行为受限于Java的访问控制。如：无法访问（ private ）私有的方法、字段 冲突 Java安全机制只允许查看任意对象有哪些域，而不允许读它们的值。若强制读取，将抛出异常 解决方案 脱离Java程序中安全管理器的控制、屏蔽Java语言的访问检查，从而脱离访问控制 具体实现手段：使用Field类、Method类 &amp; Constructor类对象的setAccessible() 123456789void setAccessible(boolean flag) // 作用：为反射对象设置可访问标志// 规则：flag = true时 ，表示已屏蔽Java语言的访问检查，使得可以访问 &amp; 修改对象的私有属性boolean isAccessible() // 返回反射对象的可访问标志的值static void setAccessible(AccessibleObject[] array, boolean flag) // 设置对象数组可访问标志 基础实例学习利用反射获取类的属性 &amp; 赋值Student 类： 12345678class Student &#123; private String name; public Student() &#123; System.out.println("创建了一个Student实例"); &#125;&#125; 12345678910111213141516171819202122try &#123; //1.获取Student类的Class对象 Class studentClass = Student.class; //2.通过Class对象创建Student类的对象 Object mStudent = studentClass.newInstance(); //3.通过Class对象获取Student类的name属性 Field f = studentClass.getDeclaredField("name"); //4.设置私有访问权限 f.setAccessible(true); //5.对新创建的Student对象设置name值 f.set(mStudent,"zx"); //6.获取新创建Student对象的name属性&amp;输出 System.out.println(f.get(mStudent));&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 上面的代码自己可以改着看看，比如将序号4的代码注释掉，就会出现我们上面提到的访问权限的问题。会提示你不能访问private修饰的属性。 1java.lang.IllegalAccessException: Class TestDemo can not access a member of class Student with modifiers "private" 利用反射调用类的构造函数123456789101112class Student &#123; private String name; public Student() &#123; System.out.println("调用了无参构造函数"); &#125; public Student(String name) &#123; System.out.println("调用了有参构造函数"); &#125;&#125; 1234567891011121314try &#123; //1.获取Student类的Class对象 Class studentClass = Student.class; //2.1 通过Class对象获取Constructor类对象，从而调用无参构造方法 //注：构造函数的调用实际上是在newInstance()，而不是在getConstructor()中调用 Object mObj1 = studentClass.getConstructor().newInstance(); // 2.2 通过Class对象获取Constructor类对象（传入参数类型），从而调用有参构造方法 Object mObj2 = studentClass.getConstructor(String.class).newInstance("zx"); &#125; catch (Exception e) &#123; e.printStackTrace();&#125; 利用反射调用类对象的方法12345678910111213141516171819202122class Student &#123; private String name; public Student() &#123; System.out.println("调用了无参构造函数"); &#125; public Student(String name) &#123; System.out.println("调用了有参构造函数"); &#125; //无参数方法 public void setName1() &#123; System.out.println("调用了无参方法： setName1()"); &#125; //有参数的方法 public void setName2(String str) &#123; System.out.println("调用了有参方法 setName2(String str): "+str); &#125;&#125; 1234567891011121314151617181920212223try &#123; //获取student类的Class对象 Class studentClass = Student.class; //2.通过Class对象创建Student类的对象 Object mStudent = studentClass.newInstance(); //3.1 通过Class对象获取方法 setName1() 的Method对象： 需传入方法名 //因为该方法无参，所以不需要传入参数 Method msetName1 = studentClass.getMethod("setName1"); //通过Method对象调用setName1() ： 需传入创建的实例 msetName1.invoke(mStudent); //3.2 通过Class对象获取方法setName2() 的Method对象： 需传入方法名 &amp; 参数类型 Method msetName2 = studentClass.getMethod("setName2", String.class); //通过Method对象调用setName2() : 需传入创建的实例 &amp; 参数值 msetName2.invoke(mStudent,"zx");&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 常见需求场景讲解工厂模式优化 背景采用简单工厂模式 冲突 操作成本高：每增加一个接口的子类，必须修改工厂类的逻辑 系统复杂性提高：每增加一个接口的子类，都必须向工厂类添加逻辑 解决方案采用反射机制： 通过 传入子类名称 &amp; 动态创建子类实例，从而使得在增加产品接口子类的情况下，也不需要修改工厂类的逻辑 实例演示 步骤1. 创建抽象产品类的公共接口 Product.java： 123abstract class Product&#123; public abstract void show();&#125; 步骤2. 创建具体产品类（继承抽象产品类），定义生产的具体产品 1234567891011121314151617&lt;-- 具体产品类A：ProductA.java --&gt;public class ProductA extends Product&#123; @Override public void show() &#123; System.out.println("生产出了产品A"); &#125;&#125;&lt;-- 具体产品类B：ProductB.java --&gt;public class ProductB extends Product&#123; @Override public void show() &#123; System.out.println("生产出了产品B"); &#125;&#125; 步骤3. 创建工厂类 Factory.java 1234567891011121314151617181920212223public class Factory &#123; // 定义方法：通过反射动态创建产品类实例 public static Product getInstance(String ClassName) &#123; Product concreteProduct = null; try &#123; // 1. 根据 传入的产品类名 获取 产品类类型的Class对象 Class product_Class = Class.forName(ClassName); // 2. 通过Class对象动态创建该产品类的实例 concreteProduct = (Product) product_Class.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 3. 返回该产品类实例 return concreteProduct; &#125; &#125; 步骤4：外界通过调用工厂类的静态方法（反射原理），传入不同参数从而创建不同具体产品类的实例 TestReflect.java 123456789public class Test &#123; public static void main(String args[]) &#123; // 1. 通过调用工厂类的静态方法（反射原理），从而动态创建产品类实例 // 需传入完整的类名 &amp; 包名 Product concreteProduct = Factory.getInstance("model.ProductA"); // 2. 调用该产品类对象的方法，从而生产产品 concreteProduct.show(); &#125;&#125; 可以明显看出，通过采用反射机制（通过传入子类名称 &amp; 动态创建子类实例），从而使得在增加产品接口子类的情况下，也不需要修改工厂类的逻辑 &amp; 增加系统复杂度。 工厂模式再优化 背景 在上述方案中，通过调用工厂类的静态方法（反射原理），从而动态创建产品类实例（该过程中：需传入完整的类名 &amp; 包名） 冲突 开发者 无法提前预知 接口中的子类类型 &amp; 完整类名 解决方案 通过 属性文件的形式（ Properties） 配置所要的子类信息，在使用时直接读取属性配置文件从而获取子类信息（完整类名） 实例演示 步骤1、2、3同上 步骤4：创建属性配置文件 Product.properties 123//写入抽象产品接口的子类信息（即完整的类名）ProductA = model.ProductAProductB = model.ProductB 项目结构如下： 步骤5：下面引用创建的properties文件 之所以要贴出项目结构图，就是为了引用的时候别搞错路径 1234567891011121314151617public static void main(String args[]) throws Exception &#123; //1.读取属性配置文件 Properties pro = new Properties(); FileInputStream inputStream = new FileInputStream("src/Product.properties"); //注意路径 pro.load(inputStream); //System.out.println(pro.getProperty("ProductA")); //2.获取属性配置文件中的产品类名 String className = pro.getProperty("ProductA"); //3.动态生成产品类实例 Product concreteProduct = Factory.getInstance(className); //4.调用该产品类对象的方法，从而生产产品 concreteProduct.show();&#125; 结果同上 上面读取配置文件还可以采用ClassLoader 只不过，ClassLoader采用的是相对路径，上面的FileInputStream采用的是绝对路径 123ClassLoader classLoader = Test.class.getClassLoader();InputStream is = classLoader.getResourceAsStream("Product.properties");pro.load(is); 使用反射前后对比如果Factory类中我们没有采用反射，而是采用常规写法，如下： 1234567891011121314151617181920class Factory &#123; public static Product Manufacture(String ProductName)&#123;//工厂类里用switch语句控制生产哪种商品；//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。 switch (ProductName)&#123; case "A": return new ProductA(); case "B": return new ProductB(); case "C": return new ProductC(); default: return null; &#125; &#125;&#125; 可见，如果我们新增加了一款产品 ProductD，那就要去修改工厂类，如果采用反射的话，就没必要了]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2F2020%2F02%2F23%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合框架概述 Java 集合可分为 Collection 和 Map 两种体系 Collection 接口 ：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Map 接口：双列数据，保存具有映射关系key-value对的集合 Collection接口继承树 Map接口继承树 Collection 接口说明 Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了 泛型以后，Java 集合可以记住容器中对象的数据类型 Collection接口方法 添加 add(Object obj) addAll(Collection coll) 获取有效元素的个数 int size() 清空集合 void clear() 是否是空集合 boolean isEmpty() 是否包含某个元素 boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象 boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。 删除 boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 boolean removeAll(Collection coll)：取当前集合的差集 取两个集合的交集 boolean retainAll(Col lection c)：把交集的结果存在当前集合中，不影响c 集合是否相等 boolean equals(Object obj) 转成对象数组 Object[] toArray() 获取集合对象的哈希值 hashCode() 遍历 iterator()：返回迭代器对象，用于集合遍历 Iterator 迭代器接口 Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。 迭代器模式，就是为容器而生。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常 12345//hasNext():判断是否还有下一个元素while(iterator.hasNext())&#123; //next():①指针下移 ②将下移以后集合位置上的元素返回 System.out.println(iterator.next());&#125; Iterator 接口remove() 方法 1234567Iterator iter = coll.iterator();//回到起点 while(iter.hasNext())&#123; Object obj = iter.next(); if(obj.equals("Tom"))&#123; iter.remove(); &#125;&#125; 使用 foreach 循环遍历集合元素 Java 5.0 提供了 foreach 循环迭代访问 Collection和数组 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素 遍历集合的底层调用Iterator完成操作 123for(Person person: persons) &#123; System.out.println(person.getName());&#125; List接口实现类 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List接口方法 List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来 操作集合元素的方法 void add(int index, Object ele): 在index 位置插入ele 元素 boolean addAll(int index, Collection eles): 从index 位置开始将eles中 中的所有元素添加进来 Object get(int index): 获取指定index 位置的元素 int indexOf(Object obj): 返回obj 在集合中首次出现的位置 int lastIndexOf(Object obj): 返回obj 在当前集合中末次出现的位置 Object remove(int index): 移除指定index 位置的元素，并返回此元素 Object set(int index, Object ele): 设置指定index 位置的元素为ele List subList(int fromIndex, int toIndex): 返回从fromIndex 到toIndex位置的子集合 List 实现类之一：ArrayList 概述： ArrayList 是 List 接口的典型实现类、主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 ArrayList 的JDK1.8 之前与之后的实现区别？ JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 List 实现类之二：LinkedList 对于 频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高 新增方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() LinkedList： 双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量： prev变量记录前一个元素的位置 next变量记录下一个元素的位置 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; List 实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用 新增方法： void addElement(Object obj) void insertElementAt(Object obj,int index) void setElementAt(Object obj,int index) void removeElement(Object obj) void removeAllElements() Set接口概述 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 Set 实现类之一：HashSet 概述： HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。 特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等 对于存放在Set容器中的对象， 对应的类一定要重写equals() 和hashCode(Objectobj) 方法，以实现对象相等规则 。即： “相等的对象必须具有相等的散列码” 向HashSet中添加元素的过程： 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功 扩容：底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等） 重写hashCode()方法的原则 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 重写equals()方法的基本原则 复写equals方法的时候一般都需要同时复写hashCode方法。通 通算 常参与计算hashCode 的对象的属性也应该参与到equals() 中进行计算 demo 12345678910111213141516171819class User &#123; private String name; private int age; //省略构造方法，get、set方法 public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return age == user.age &amp;&amp; name.equals(user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; Set 实现类之二：LinkedHashSet 概述： LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能 LinkedHashSet 不允许集合元素重复 Set 实现类之三：TreeSet 概述： TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。 TreeSet底层使用红黑树结构存储数据 新增的方法如下： (了解) 12345678Comparator comparator()Object first()Object last()Object lower(Object e)Object higher(Object e)SortedSet subSet(fromElement, toElement)SortedSet headSet(toElement)SortedSet tailSet(fromElement) TreeSet 两种排序方法： 自然排序和定制排序。默认情况下，TreeSet 采用自然排序 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。 前面讲过了Comparable 的典型实现，像String，Date，BigDecimal等 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解 定制排序：定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0 Map接口概述 Map与Collection并列存在。用于保存具有映射关系的数据:key-value Map 中的 key 和 value 都可以是任何引用类型的数据 Map 中的 key 用Set来存放， 不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法 常用String类作为Map的“键” key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value 实现类 Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类 常用方法 添加 、删除、修改操作 ： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m): 将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 Map 实现类之一：HashMap 概述： HashMap是 Map 接口 使用频率最高的实现类 允许使用null键和null值，与HashSet一样，不保证映射的顺序 所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode() 所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals() 一个key-value构成一个entry 所有的entry构成的集合是Set:无序的、不可重复的 HashMap 判断两个key相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等 HashMap 判断两个 value 相等的标准是：两个 value 通过 equals() 方法返回 true HashMap源码中的重要常量说明 123456789101112131415DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30DEFAULT_LOAD_FACTOR ：HashMap的默认加载因子TREEIFY_THRESHOLD ：Bucket中链表长度大于该默认值，转化为红黑树UNTREEIFY_THRESHOLD ：Bucket中红黑树存储的Node小于该默认值，转化为链表MIN_TREEIFY_CAPACITY ：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。）table ：存储元素的数组，总是2的n次幂entrySet：存储具体元素的集size ：HashMap中存储的键值对的数量modCount ：HashMap扩容和结构改变的次数。threshold ：扩容的临界值，= 容量*填充因子loadFactor：填充因子 HashMap的存储结构 JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) 说明： HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。、 每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head 向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值相同，继续比较二者是否equals。如果返回值为true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素 HashMap的扩容（jdk7-） 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过160.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 JDK 8版本发布以后：HashMap是数组+链表+红黑树实现 说明： HashMap的内部存储结构其实是 数组+ 链表+ 树 的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素 每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点 HashMap的扩容和树形化（jdk8+） 当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过160.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能 当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。 总结 jdk1.8相较于之前的变化 HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组 当首次调用map.put()时，再创建长度为16的数组 数组为Node类型，在jdk7中称为Entry类型 形成链表结构时，新添加的key-value对在链表的尾部（七上八下） 当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置上的所有key-value对使用红黑树进行存储 Map 实现类之二：LinkedHashMap 概述： LinkedHashMap 是 HashMap 的子类 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 Map 实现类之三：TreeMap 概述: TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于 有序状态 TreeMap底层使用红黑树结构存储数据 TreeMap 的 Key 的排序: 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口 TreeMap判断 两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0 Map 实现类之四：Hashtable 概述： Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 Map 实现类之五：Properties 概述： Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 1234Properties pros = new Properties();pros.load(new FileInputStream("jdbc.properties"));String user = pros.getProperty("user");System.out.println(user); Collections工具类概述 Collections 是一个操作 Set、List 和 Map 等集合的工具类（操作数组的工具类：Arrays） Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 排序操作（均为static方法） reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值 Collections常用方法：同步控制 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型(generics)概述 在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参） 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List&lt;String&gt;，这表明该List只能保存字符串类型的对象 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参 为什么要有泛型？ 解决元素存储的安全性问题，好比商品、药品标签，不会弄错 解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。 demo 12345678910111213Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put("Tom1",34); map.put("Tom2",44); map.put("Tom3",33); map.put("Tom4",32); //添加失败 //map.put(33, "Tom"); Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator(); while(iterator.hasNext())&#123; Entry&lt;String,Integer&gt; entry = iterator.next(); System.out.println(entry.getKey() + "---&gt;" + entry.getValue()); &#125; 自定义泛型结构 泛型的声明 interface List 和 class GenTest&lt;K,V&gt;其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写 泛型的实例化 一定要在类名后面指定类型参数的值（类型）。如： 12List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator(); T只能是类，不能用基本数据类型填充。但可以使用包装类填充 jdk1.5前后对比 1.5之前 12Comparable c = new Date();System.out.println(c.compareTo("red")); 1.5之后 12Comparable&lt;Date&gt; c = new Date();System.out.println(c.compareTo(&quot;red&quot;)); 体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误 补充说明 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致 泛型不同的引用不能相互赋值 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象 jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList&lt;&gt;() 泛型的指定中不能使用基本数据类型，可以使用包装类替换 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型 code 123456789101112131415161718class GenericTest &#123; public static void main(String[] args) &#123; // 1、使用时：类似于Object，不等同于Object ArrayList list = new ArrayList(); // list.add(new Date());//有风险 list.add("hello"); test(list);// 泛型擦除，编译不会类型检查 // ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;(); // test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理 &#125; public static void test(ArrayList&lt;String&gt; list) &#123; String str = ""; for (String s : list) &#123; str += s + ","; &#125; System.out.println("元素:" + str); &#125; &#125; 123456789101112//static的方法中不能声明泛型public static void show(T t) &#123;&#125;//不能在try-catch中使用泛型定义public void test() &#123; try &#123; &#125; catch (MyException&lt;T&gt; ex) &#123; &#125;&#125; 泛型方法 方法，也可以被泛型化，不管此时定义在其中的类是不是 泛型类。 在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类 格式：[ 访问权限] &lt; 泛型&gt; 型 返回类型 名 方法名([ 泛型标识 称 参数名称]) 抛出的异常 123456public class DAO &#123; public &lt;T&gt; E get(int id, T e) &#123; T result = null; return result; &#125;&#125; 泛型在继承上的体现 如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G并不是G的子类型 比如：String是Object的子类，但是List并不是List的子类 1234567891011public void testGenericAndSubClass() &#123; Person[] persons = null; Man[] mans = null; // 而 Person[] 是 Man[] 的父类. persons = mans; Person p = mans[0]; // 在泛型的集合上 List&lt;Person&gt; personList = null; List&lt;Man&gt; manList = null; // personList = manList;(报错)&#125; 通配符的使用 使用类型通配符：？比如：List&lt;?&gt; ，Map&lt;?,?&gt;List&lt;?&gt;是List、List等各种泛型List的父类。 读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。 写入元素： 写入list中的元素时，因为我们不知道c的元素类型，我们不能向其中添加对象 唯一的例外是null，它是所有类型的成员 12List&lt;?&gt; list2 = new ArrayList&lt;&gt;(10);list2.add("sss"); //编译时错误 说明 注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用? 注意点2：编译错误：不能用在泛型类的声明上 注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象 有限制的通配符 &lt;?&gt;允许所有泛型的引用调用 通配符指定上限：上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 通配符指定下限：下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例：(理解这两个范围即可) &lt;? extends Number&gt; ( 无穷小 , Number]只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt; [Number , 无穷大)只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt;只允许泛型为实现Comparable接口的实现类的引用调用 123456List&lt;? extends User&gt; list1 = null; List&lt;? super User&gt; list2 = null; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); list1 = studentList; Student s = list1.get(0); //此处编译不通过 理解为不能将父类的对象赋给子类 万一 ? 代表的类型比student大呢]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流]]></title>
    <url>%2F2020%2F02%2F23%2FIO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[File类的使用概述 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关 File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录 File对象可以作为参数传递给流的构造器 常用构造器 public File(String pathname)：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 绝对路径：是一个固定的路径,从盘符开始 相对路径：是相对于某个位置开始 public File(String parent,String child)：以parent为父路径，child为子路径创建File对象 public File(File parent,String child)：根据一个父File对象和子文件路径创建File对象 路径分隔符 路径中的每级目录之间用一个路径分隔符隔开 路径分隔符和系统有关： windows和DOS系统默认使用“\”来表示 UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用 为了解决这个隐患，File类提供了一个常量：public static final String separator。根据操作系统，动态的提供分隔符。 123File file1 = new File("d:\\atguigu\\info.txt");File file2 = new File("d:" + File.separator + "atguigu" + File.separator + "info.txt");File file3 = new File("d:/atguigu"); File类常用方法 File类的获取功能： public String getAbsolutePath()：获取绝对路径 public String getPath() ：获取路径 public String getName() ：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 public long lastModified() ：获取最后一次的修改时间，毫秒值 public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组 public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组 File类的获取功能： public boolean renameTo(File dest):把文件重命名为指定的文件路径 File类的判断功能： public boolean isDirectory()：判断是否是文件目录 public boolean isFile() ：判断是否是文件 public boolean exists() ：判断是否存在 public boolean canRead() ：判断是否可读 public boolean canWrite() ：判断是否可写 public boolean isHidden() ：判断是否隐藏 File类的创建功能： public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建 如果你创建文件或者 文件 目录没有 盘符路径 ， 那么 ， 默认在项目路径下 File类的删除功能 public boolean delete()：删除文件或者文件夹，删除注意事项：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 File内存解析 IO流原理及流的分类概述 I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等 Java程序中，对于数据的输入/输出操作以 “流(stream)” 的方式进行 java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 Java IO原理 流的分类 按操作数据单位不同分为：字节流(8 bit) ，字符流(16 bit) 按数据流的流向不同分为： 输入流，输出流 按流的角色的不同分为： 节点流，处理流 Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 IO流体系： 节点流：直接从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能 InputStream &amp; Reader概述 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该件 显式关闭文件 IO 资源 InputStream 和 Reader 是所有输入流的基类。 InputStream（典型实现：FileInputStream） int read()：从此输入流中读取下一个数据字节。返回一个 0 到 255 范围内的 int 字节值。如果因为到达流末尾而没有可用的字节，则返回值 -1。 int read(byte[] b)：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。以整数形式返回实际读取的字节数。 int read(byte[] b, int off, int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。 Reader（典型实现：FileReader） int read() int read(char [] c) int read(char [] c, int off, int len) InputStream 概述：FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader 方法： int read()：从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 int read(byte[] b)：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len)：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源。 Reader 方法： int read()：读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 int read(char[] cbuf)：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len)：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 public void close() throws IOException：关闭此输入流并释放与该流关联的所有系统资源。 OutputStream &amp; Writer概述 OutputStream 和 Writer 也非常相似： void write(int b/int c); void write(byte[] b/char[] cbuf); void write(byte[] b/char[] buff, int off, int len); void flush(); void close(); 需要先刷新，再关闭此流 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数 void write(String str); void write(String str, int off, int len); OutputStream FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter 方法 void write(int b):将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。 void write(byte[] b):将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 void write(byte[] b,int off,int len):将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException: 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException:关闭此输出流并释放与该流关联的所有系统资源。 Writer 方法： void write(int c)：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 void write(char[] cbuf)：写入字符数组。 void write(char[] cbuf,int off,int len)：写入字符数组的某一部分。从off开始，写入len个字符 void write(String str)：写入字符串。 void write(String str,int off,int len)：写入字符串的某一部分。 void flush()刷新该流的缓冲，则立即将它们写入预期目标。 public void close() throws IOException：关闭此输出流并释放与该流关联的所有系统资源。 节点流（或文件流）说明 定义文件路径时，注意：可以用“/”或者“\”。 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容 在读取文件时，必须保证该文件已存在，否则报异常 字节流操作字节，比如：.mp3，.avi，.rmvb，.mp4，.jpg，.doc，.ppt 字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件 Demo 读取文件： 123456781.建立一个流对象，将已存在的一个文件加载进流。FileReader fr = new FileReader(new File(“Test.txt”));2.创建一个临时存放数据的数组。char[] ch = new char[1024];3.调用流对象的读取方法将流中的数据读入到数组中。fr.read(ch);4. 关闭资源。fr.close(); 写入文件： 1234561.创建流对象，建立数据存放文件FileWriter fw = new FileWriter(new File(“Test.txt”));2.调用流对象的写入方法，将数据写入流fw.write(“atguigu-songhongkang”);3.关闭流资源，并将流中的数据清空到文件中。fw.close(); 缓冲流概述 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为： BufferedInputStream 和 BufferedOutputStream BufferedReader 和 BufferedWriter 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 flush()方法的使用：手动将buffer中内容写入文件 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 示意图 转换流概述 转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流 InputStreamReader ：将InputStream 转换为Reader OutputStreamWriter ：将Writer 转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能 InputStreamReader 实现将字节的输入流按指定字符集转换为字符的输入流 需要和InputStream“套接” 构造器： public InputStreamReader(InputStream in) public InputSreamReader(InputStream in,String charsetName) 1Reader isr = new InputStreamReader(System.in,”gbk”); //指定编码字符集 OutputStreamWriter 实现将字符的输出流按指定字符集转换为字节的输出流。 需要和OutputStream“套接” 构造器： public OutputStreamWriter(OutputStream out) public OutputSreamWriter(OutputStream out,String charsetName) 字符编码分类 ASCII：美国标准信息交换码。用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表。 用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16 标准输入、输出流概述 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变 public static void setIn(InputStream in) public static void setOut(PrintStream out) 打印流概述 实现将基本数据类型的数据格式转化为字符串输出 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 数据流概述 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类：(用于读取和写出基本数据类型、String类的数据） DataInputStream 和 DataOutputStream 在 分别“套接”在 InputStream 和 和 OutputStream 子类的流上 DataInputStream 中的方法 12345boolean readBoolean() byte readByte()char readChar() float readFloat()double readDouble() short readShort()long readLong() int readInt()String readUTF() void readFully(byte[] b) DataOutputStream 中的方法:将上述的方法的read改为相应的write即可 对象流概述 ObjectInputStream 和OjbectOutputSteam 用于存储和读取 基本数据类型数据或 对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来 序列化 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原 序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础 序列化：用ObjectOutputStream类 保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类 读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 如何序列化 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常 Serializable Externalizable 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID; serialVersionUID用来表明类的不同版本间的兼容性。 简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException) 使用对象流序列化对象 若某个类实现了 Serializable 接口，该类的对象就是可序列化的： 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject( 对象) 方法输出可序列化对象 注意写出一次，操作flush() 一次 反序列化 创建一个 ObjectInputStream 用 调用 readObject() 方法读取流中的对象 如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化 Demo 12345678//序列化：将对象写入到磁盘或者进行网络传输//要求对象必须实现序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“data.txt"));Person p = new Person("韩梅梅", 18, "中华大街", new Pet());oos.writeObject(p);oos.flush();oos.close(); 12345//反序列化：将磁盘中的对象数据源读出。ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“data.txt"));Person p1 = (Person)ois.readObject();System.out.println(p1.toString());ois.close(); 随机存储文件流RandomAccessFile 类 RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写 RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来 读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到 pos 位置 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式 r: 以只读方式打开 rw ：打开以便读取和写入 rwd: 打开以便读取和 写入；同步文件内容的更新 rws: 打开以便读取和 写入； 同步文件内容和元数据 的 更新 如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建 好记 节点流是直接操作文件的，处理流是操作流的 由上面的理解可知，很明显节点流只需记住4个：FileInputStream、FileOutputStream、FileReader、FileWriter。 其他常用的那些都是处理流，比如Buffer系列 关于缓冲的问题https://blog.csdn.net/yeyinfei321/article/details/18451015]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解（Annotation） 概述：从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)。Annotation 可以像修饰符一样被使用, 可用于修饰包, 类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation的 “name=value” 对中。注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 使用：使用 Annotation 时要在其前面增加 @ 符号, 并 把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 生成文档相关的注解1234567@author 标明开发该类模块的作者，多个作者之间使用,分割@version 标明该类模块的版本@see 参考转向，也就是相关主题@since 从哪个版本开始增加的@param 对方法中某参数的说明，如果没有参数就不能写@return 对方法返回值的说明，如果方法的返回值类型是void就不能写@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写 @param @return 和 @exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名 形参类型 形参说明 @return 的格式要求：@return 返回值类型 返回值说明 @exception的格式要求：@exception 异常类型 异常说明 @param和@exception可以并列多个 示例： 12345678910111213141516171819202122package com.annotation.javadoc;/** * @author shkstart * @version 1.0 * @see Math.java */public class JavadocTest &#123; /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) &#123; &#125; /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius)&#123; return Math.PI * radius * radius; &#125;&#125; 在编译时进行格式检查（JDK 内置的三个基本注解）123456@Override: 限定重写父类方法, 该注解只能用于方法@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择@SuppressWarnings: 抑制编译器警告 demo: 123456789101112131415package com.annotation.javadoc;public class AnnotationTest&#123; public static void main(String[] args) &#123; @SuppressWarnings("unused") int a = 10; &#125; @Deprecated public void print()&#123; System.out.println("过时的方法"); &#125; @Override public String toString() &#123; return "重写的toString方法()"; &#125;&#125;]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举类]]></title>
    <url>%2F2020%2F02%2F23%2F%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[枚举类 特点：类的对象只有有限个，确定的。例如，星期：Monday(星期一)、……、Sunday(星期天)。当需要定义一组常量时，强烈建议使用枚举类 枚举类的属性： 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 枚举类的实现 JDK1.5之前需要自定义枚举类 JDK 1.5 新增的 enum 关键字用于定义枚举类 自定义枚举类 要求： 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final 对象如果有实例变量，应该声明为private final，并在构造器中初始化 demo: 123456789101112131415class Season &#123; private final String SEASONNAME;//季节的名称 private final String SEASONDESC;//季节的描述 private Season(String seasonName, String seasonDesc) &#123; this.SEASONNAME = seasonName; this.SEASONDESC = seasonDesc; &#125; public static final Season SPRING = new Season("春天", "春暖花开"); public static final Season SUMMER = new Season("夏天", "夏日炎炎"); public static final Season AUTUMN = new Season("秋天", "秋高气爽"); public static final Season WINTER = new Season("冬天", "白雪皑皑");&#125; 使用enum定义枚举类 demo: 123456789101112131415161718public enum SeasonEnum &#123; SPRING("春天","春风又绿江南岸"), SUMMER("夏天","映日荷花别样红"), AUTUMN("秋天","秋水共长天一色"), WINTER("冬天","窗含西岭千秋雪"); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) &#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125; Enum类的主要方法 values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException toString()：返回当前枚举类对象常量的名称 说明 和普通 Java 类一样，枚举类可以实现一个或多个接口 调用：SeasonEnum.SPRING]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常用类]]></title>
    <url>%2F2020%2F02%2F23%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[字符串相关的类 String介绍 String类：： 代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现 String是一个final类，代表不可变的字符序列 字符串是常量，用双引号引起来表示。他们的值在创建之后不能更改 String对象的字符内容是存储在一个字符数组value[]中的 内存解析 问题：String str1 = “abc”; 与String str2 = new String(“abc”);的区别 练习 String与基本数据类型转换 字符串 -&gt; 基本数据类型、包装类 Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型 类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型 基本数据类型、包装类 -&gt; 字符串 调用String类的public String valueOf(int n)可将int型转换为字符串 相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(doubled)、valueOf(boolean b)可由参数的相应类型到字符串的转换 字符数组 -&gt; 字符串 String 类的构造器：String(char[]) 和 和 String(char[] ，int offset ，intlength) 分别用字符数组中的全部字符和部分字符创建字符串对象 字符串 -&gt; 字符数组 public char[] toCharArray() ：将字符串中的全部字符存放在一个字符数组中的方法 public void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法 字节数组 -&gt; 字符串 String(byte[]) ：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String String(byte[] ，int offset ，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象 字符串 -&gt; 字节数组 public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中 public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组 StringBuffer 类 介绍：StringBuffer 类不同于String ，其对象必须使用构造器生成。有三个构造器： StringBuffer() ：初始容量为16的字符串缓冲区 StringBuffer(int size) ：构造指定容量的字符串缓冲区 StringBuffer(String str) ：将内容初始化为指定字符串内容 StringBuffer和String的区别 常用方法： 12345StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接StringBuffer delete(int start,int end)：删除指定位置的内容StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为strStringBuffer insert(int offset, xxx)：在指定位置插入xxxStringBuffer reverse() ：把当前字符序列逆转 StringBuilder 类 简介：StringBuilder 和 和 StringBuffer 非常类似，均代表可变的字符序列 ， 而且提供相关功能的方法也一样 对比String 、StringBuffer 、StringBuilder String(JDK1.0)：不可变字符序列 StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全 StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全 经典题1234567String str = null;StringBuffer sb = new StringBuffer();sb.append(str);System.out.println(sb.length());//4 看源码 会将 "null"这个字符串appendSystem.out.println(sb);//nullStringBuffer sb1 = new StringBuffer(str);System.out.println(sb1);//报异常 JDK8之前日期时间APIjava.lang.System类 System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 java.util.Date 类 含义：表示特定的瞬间，精确到毫秒 构造器： Date()：使用无参构造器创建的对象可以获取本地当前时间 Date(long date) 常用方法： getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数 toString():把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue,Wed, Thu, Fri, Sat)，zzz是时间标准 （Sun Apr 05 10:04:51 CST 2020） java.text.SimpleDateFormat 类 说明： Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 格式化： SimpleDateFormat() ：默认的模式和语言环境创建对象 public SimpleDateFormat(String pattern) ：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用 public String format(Date date) ：方法格式化时间对象date 解析： public Date parse(String source)： ：从给定字符串的开始解析文本，以生成一个日期 时间格式参照图 Demo: 123456789101112131415161718Date date = new Date(); //产生一个formater格式化的对象 SimpleDateFormat formater = new SimpleDateFormat(); //打印默认输出的格式 System.out.println(formater.format(date)); //20-4-5 上午10:19 //指定格式 SimpleDateFormat formater2 = new SimpleDateFormat("yyyy年MM月dd日 EEE HH:mm:ss"); System.out.println(formater2.format(date)); //2020年04月05日 星期日 10:19:27 // 实例化一个指定的格式对象 Date date2 = null; try &#123; date2 = formater2.parse("2008年08月08日 星期一 08:08:08"); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; // 将指定的日期解析后格式化按指定的格式输出 System.out.println(date2.toString()); //Fri Aug 08 08:08:08 CST 2008 java.util.Calendar 类 简介: Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能 获取Calender实例： 使用Calendar.getInstance()方法 调用它的子类GregorianCalendar的构造器 说明：一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2 ， 。。。。周六是7 几个方法： public void set(int field,int value) public void add(int field,int amount) public final Date getTime() public final void setTime(Date date) Demo: 12345678910Date date = new Date(); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); System.out.println(calendar.getTime()); //Sun Apr 05 10:41:45 CST 2020 calendar.set(Calendar.DAY_OF_MONTH, 8); System.out.println("当前时间日设置为8后,时间是:" + calendar.getTime()); //Wed Apr 08 10:41:45 CST 2020 calendar.add(Calendar.HOUR, 2); System.out.println("当前时间加2小时后,时间是:" + calendar.getTime()); //Wed Apr 08 12:41:45 CST 2020 calendar.add(Calendar.MONTH, -2); System.out.println("当前日期减2个月后,时间是:" + calendar.getTime()); //Sat Feb 08 12:41:45 CST 2020 JDK8中新日期时间API之前日期类的问题 如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的 偏移性：Date中的年份是从1900开始的，而月份都从0开始 格式化：格式化只对Date有用，Calendar则不行 安全性：不是线程安全的 新时间日期API–java.time API 简介：Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理 包： java.time – 包含值对象的基础包 java.time.format – 格式化和解析时间和日期 java.time.chrono – 提供对不同的日历系统的访问 java.time.temporal – 包括底层框架和扩展特性 java.time.zone – 包含时区支持的类 大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一 类： LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期 LocalTime表示一个时间，而不是日期 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一 ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历 方法： Demo: 123456789101112//now()方法 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate); //2020-04-05 System.out.println(localTime); //16:15:55.181 System.out.println(localDateTime); //2020-04-05T16:15:55.181 //of() T表示分隔符，Z表示的是UTC(世界标准时间)。 LocalDateTime localDateTime1 = LocalDateTime.of(2020,4,4,16,18,55); System.out.println(localDateTime1); 时间戳？ 时间戳是指格林威治时间1970 年01 月01 日00 时00 分00 秒( 北京时间1970 年01 月01日 日08 时00 分00 秒) 起至现在的总秒数 瞬时 Instant 概念：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。 (1 ns = 10^ -9 s) 1秒 = 1000毫秒 =10^6微秒=10 ^9 纳秒 方法： Demo: 1234567891011121314151617181920Instant instant = Instant.now(); System.out.println(instant); //2020-04-05T08:27:02.626Z 世界标准时间 北京时间要在基础上+8h //偏移8h得到北京时间 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime); //2020-04-05T16:27:02.626Z //获取对应毫秒数 自**1970年1月1日0时0分0秒开始 long l = instant.toEpochMilli(); System.out.println(l); //1586075486287 Date date = new Date(l); System.out.println(date); //Sun Apr 05 16:37:06 CST 2020 SimpleDateFormat format = new SimpleDateFormat(); String format1 = format.format(date); System.out.println(format1); //默认输出格式 20-4-5 下午4:37 SimpleDateFormat format2 = new SimpleDateFormat("yyyy年MM月dd日 EEE HH:mm:ss"); System.out.println(format2.format(date)); //2020年04月05日 星期日 16:37:06 格式化与解析日期或时间 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) Demo: 123456789101112131415161718192021222324252627LocalDateTime localDateTime = LocalDateTime.now(); //DateTimeFormatter 格式化或解析日期时间 //方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; String str1 = formatter.format(localDateTime); System.out.println(localDateTime); //2020-04-05T16:47:38.470 System.out.println(str1); //2020-04-05T16:47:38.47 //方式二：本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) // 还有 FormatStyle.SHORT FormatStyle.MEDIUM DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM); System.out.println(formatter1.format(localDateTime)); //short: 20-4-5 下午4:56 //long: 2020年4月5日 下午04时58分11秒 //medium: 2020-4-5 16:58:40 //方式三： 自定义格式 如：ofPattern("yyyy-MM-dd hh:mm:ss") DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss"); System.out.println(formatter2.format(localDateTime)); //2020-04-05 05:03:32 //解析 TemporalAccessor accessor = formatter2.parse("2020-04-05 05:03:32"); System.out.println(accessor); //输出：&#123;MilliOfSecond=0, HourOfAmPm=5, MicroOfSecond=0, NanoOfSecond=0, MinuteOfHour=3, SecondOfMinute=32&#125;,ISO resolved to 2020-04-05 Java比较器自然排序：java.lang.Comparable 概念： Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序 用法：实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零， 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序 Comparable 的典型实现：(默认都是从小到大排列的) String：按照字符串中字符的Unicode值进行比较 Character：按照字符的Unicode值来进行比较 数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大 Demo： 123456789101112131415161718192021222324252627282930313233343536373839class Goods implements Comparable&#123; private String name; private double price; //省略构造方法 、getter()、setter()、toString()方法 @Override public int compareTo(Object o) &#123; if(o instanceof Goods) &#123; Goods other = (Goods)o; if(this.price &gt; other.price) &#123; return 1; &#125;else if(this.price &lt; other.price) &#123; return -1; &#125;else&#123; return 0; &#125; &#125; throw new RuntimeException("传入的数据类型不符合要求"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Goods[] all = new Goods[4]; all[0] = new Goods("《红楼梦》", 100); all[1] = new Goods("《西游记》", 80); all[2] = new Goods("《三国演义》", 140); all[3] = new Goods("《水浒传》", 120); Arrays.sort(all); System.out.println(Arrays.toString(all)); &#125;&#125;/*输出结果： [Goods&#123;name='《西游记》', price=80.0&#125;, Goods&#123;name='《红楼梦》', price=100.0&#125;, Goods&#123;name='《水浒传》', price=120.0&#125;, Goods&#123;name='《三国演义》', price=140.0&#125;]*/ 定制排序：java.util.Comparator 简介：当元素的类型没有实现java.lang.Comparable 接口而又不方便修改代码，了 或者实现了java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序 用法：需要重写compare(Object o1,Object o2)方法，比较o1和o2的大小,可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制 Demo: 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Goods[] all = new Goods[4]; all[0] = new Goods("《红楼梦》", 100); all[1] = new Goods("《西游记》", 80); all[2] = new Goods("《三国演义》", 140); all[3] = new Goods("《水浒传》", 120); //将 Comparator 传递给 sort 方法 Arrays.sort(all, new Comparator&lt;Goods&gt;() &#123; @Override public int compare(Goods o1, Goods o2) &#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; return Double.compare(g1.getPrice(),g2.getPrice()); &#125; &#125;); System.out.println(Arrays.toString(all)); &#125;&#125; System类 介绍：System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包，由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用 成员变量：System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器) 成员方法： native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数 void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。 使用该方法可以在图形界面编程中实现程序的退出功能等 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况 String getProperty(String key)：方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： Math 类 介绍：java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double 方法： 123456789101112abs 绝对值acos,asin,atan,cos,sin,tan 三角函数sqrt 平方根pow(double a,doble b) a 的b 次幂log 自然对数exp e 为底指数max(double a,double b)min(double a,double b)random() 返回0.0 到1.0 的随机数long round(double a) double 型数据a 转换为long 型（四舍五入）toDegrees(double angrad) 弧度—&gt; 角度toRadians(double angdeg) 角度—&gt; 弧度]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一些基础概念 程序（program）：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象 进程（process）：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程（thread）:进程可进一步细化为线程，是一个程序内部的一条执行路径.若一个进程同一时间 并行执行多个线程，就是支持多线程的. 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc) 并行与并发 并行：多个CPU同时执行多个任务 并发：一个CPU（采用时间片）同时执行多个任务 Thread类构造器 Thread() ：创建新的Thread对象 Thread(String threadname)： 创建线程并指定线程实例名 Thread(Runnable target) ：指定创建线程的目标对象，它实现了Runnable接口中的run方法 Thread(Runnable target, String name) ：创建新的Thread对象 特性 1.每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为 线程体 通过该Thread对象的start()方法来启动这个线程，而非直接调用run() 有关方法 void start(): 启动线程，并执行对象的run()方法 run(): 线程在被调度时执行的操作 String getName(): 返回线程的名称 void setName(String name):设置该线程名称 static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 static void yield()： 线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程，若队列中没有同优先级的线程，忽略此方法 join() ： 当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，低优先级的线程也可以获得执行 static void sleep(long millis) ：(指定时间:毫秒)，令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。抛出InterruptedException异常 stop(): 强制线程生命期结束，不推荐使用 boolean isAlive()： 返回boolean，判断线程是否还活着 创建线程的两种方式继承Thread类 用法： 1.定义子类继承Thread类 2.子类中重写Thread类中的run方法 3.创建Thread子类对象，即创建了线程对象 4.调用线程对象start方法：启动线程，调用run方法 说明： 1.如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式 2.run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定 3.想要启动多线程，必须调用start方法 4.一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常IllegalThreadStateException 实现Runnable接口 用法： 1.定义子类，实现Runnable接口 2.子类中重写Runnable接口中的run方法 3.通过Thread类含参构造器创建线程对象 4.将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中 5.调用Thread类的start方法：开启线程，调用Runnable子类的run方法 好处 1.避免了单继承的局限性 2.多个线程可以共享同一个接口实现类的对象，非常适合多个相同的线程来处理同一份资源 线程的调度调度策略 时间片 抢占式：高优先级的线程抢占CPU Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级线程的优先级等级 MAX_PRIORITY ：10 MIN _PRIORITY ：1 NORM_PRIORITY ：5 涉及方法 getPriority() ：返回线程优先值 setPriority(int newPriority) ： 改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 线程分类 Java中的线程分为两类：一种是 守护线程，一种是 用户线程 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程 Java垃圾回收就是一个典型的守护线程 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开 若JVM中都是守护线程，当前JVM将退出 线程的生命周期概述JDK 中用Thread.State 类定义了 线程的几种状态 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 看图 线程的同步出现的安全问题 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误 解决方案：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行 同步机制 Synchronized Java 对于多线程的安全问题提供了专业的解决 方式 ： 同步 机制 用法： 12345678910//同步代码块 ：synchronized ( 对象 )&#123; // 需要被同步的代码；&#125;// synchronized 还可以放在方法声明中，表示整个方法为同步方法public synchronized void show (String name)&#123; ….&#125; Synchronized锁123456789/**在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了*/ 哪些操作会释放锁？ 1.当前线程的同步方法、同步代码块执行结束 2.当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行 3.当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束 4.当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁 哪些操作不会释放锁？ 1.线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread. Yield()方法暂停当前线程的执行 2.线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器），应尽量避免使用suspend()和resume()来控制线程 死锁 含义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 Lock(锁) 含义： 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 1234567java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁 如图 123456789101112class A&#123; private final ReentrantLock lock = new ReenTrantLock(); public void m()&#123; lock.lock(); try&#123; // 保证线程安全的代码; &#125; finally&#123; lock.unlock(); &#125; &#125;&#125; synchronized 与 Lock 的对比 1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 2.Lock只有代码块锁，synchronized有代码块锁和方法锁 3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 进程的通信wait() 与 notify() 和 notifyAll() wait():令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行 notify(): 唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll ()：唤醒正在排队等待资源的所有线程结束等待 说明：这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[看个图 异常分类运行时异常 定义：是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响 编译时异常 定义：是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。对于这类异常，如果程序不处理，可能会带来意想不到的结果。 异常处理机制try-catch-finally语句 用法 123456789101112try&#123; ...... //可能产生异常的代码&#125;catch( ExceptionName1 e )&#123; ...... //当产生ExceptionName1型异常时的处置措施&#125;catch( ExceptionName2 e )&#123; ...... //当产生ExceptionName2型异常时的处置措施&#125;finally&#123; ...... //无论是否发生异常， 都无条件执行的语句&#125; 说明：如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。比如可 以 用 ArithmeticException 类 作 为 参 数 的 地 方 ， 就 可 以 用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException（catch中的语句将不会执行） 捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法 getMessage()获取异常信息，返回字符串 printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void 示意图: finally : 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理.不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行 finally语句和catch语句是任选的 如图： 前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过( 但运行时会发生异常使得程序运行终止 ) 如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 处理异常的第二种方式—声明抛出异常 throws 含义：如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理 用法：在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 如图： 重写方法不能抛出比被重写方法范围更大的异常类型 手动抛出异常 含义：Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要 使用人工 创建并抛出 用法： 首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境 12IOException e = new IOException();throw e; 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误 1throw new String(&quot;want to throw&quot;); 自定义异常类 用法： 选择一个合适的父类，提供一个 serialVersionUID 如图：]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类、属性和方法]]></title>
    <url>%2F2020%2F02%2F23%2F%E7%B1%BB%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注意点 1.当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型 2.方法的调用过程 Java的实参值如何传入方法? java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参 概念加深重载 在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可 特点：与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或参数类型，不同类型参数的顺序），调用时，只根据方法参数的不同来区别 示例： 可变参数1234//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[] books);//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String…books); 说明： 声明格式：方法名(参数的类型名 …参数名) 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个 可变个数形参的方法与同名的方法之间，彼此构成重载 可变参数方法的使用与方法参数部分使用数组是一致的 方法的参数部分有可变形参，需要放在形参声明的最后 在一个方法的形参位置，最多只能声明一个可变个数形参 封装和隐藏 Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx() 和setXxx()实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作 便于修改，增强代码的可维护性 四种访问权限修饰符 对于class的权限修饰只可以用public和default(缺省) public类可以在任意地方被访问 default类只可以被同一个包内部的类访问 构造器 特征 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值 注意 Java 语言中，每个类都至少有一个 构造器 默认构造器的修饰符与所属类的修饰符一致 一旦 显式定义了 构造器， 则系统 不再 提供默认 构造 器 一个类可以创建多个 重载 的构造器 父 类的构造器不可被子类继承 当父类中没有空参数的构造器时，子类的构造器必须通过this(参 数列表)或者super( 参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能二选一，且必须放在构造器的首行 说明 子类默认继承父类的属性和方法，但不会继承父类的构造器，而是在子类被实例化时会默认调用父类的空构造器（子类在创建的时候会调用自己的空构造器，并在空构造器会隐式调用super()，即父类的空构造器）。如果父类的构造器被重载，那么子类中的构造器也必须初始化父类的构造器，否则会报编译错误。当然，只要父类中显式定义了空构造器，子类中就不必初始化父类的构造器。 JavaBean 所谓JavaBean，是指符合如下标准的Java类: 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 UML类图 this 关键字 作用 它在方法内部使用，即这个方法所属对象的引用 它在构造器内部使用，表示该构造器正在初始化的对象 注意 1.在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this 2.当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量 3.使用this访问属性和方法时，如果在本类中未找到，会从父类中查找 4.this可以作为一个类中构造器相互调用(不能调用自身)的特殊格式,但不能通过this(形参列表)的方式调用自身构造器 12345678910111213public Person()&#123; // 无参构造器 System.out.println("新对象实例化") ;&#125;public Person(String name)&#123; this(); // 调用本类中的无参构造器 this.name = name ;&#125;public Person(String name,int age)&#123; this(name) ; // 调用有一个参数的构造器 this.age = age;&#125; 5.this(形参列表)”必须声明在类的构造器的首行 6.在类的一个构造器中，最多只能声明一个“this(形参列表)” 方法的重写 要求 1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 2.子类重写的方法的返回值类型要和父类被重写的方法的返回值类型相同或更小 3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 4.子类不能重写父类中声明为private权限的方法 5.子类方法抛出的异常不能大于父类被重写方法的异常 6.子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法 == 和 equals() ==: 基本类型比较值:只要两个变量的值相等，即为true。 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true 用“==”进行比较时，符号两边的 数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 equals(): 所有类都继承了Object, 也就获得了equals()方法 只能比较引用类型 ， 其作用与 “==” 相同, 比较是否指向同一个对象，格式:obj1.equals(obj2) 特例：当用equals()方法进行比较时 , 对类File 、String 、Date 及包装类 （ Wrapper Class ）来说 ， 是比较类型及内容而不考虑引用的是否是同一个对像，原因：在这些类中重写了Object 类的equals() 方法 toString()方法 要点： 1.toString() 方法在Object 类中定义 ， 其返回值是String 类型 ， 返回类名和它的引用地址 在进行String 与其它类型数据的连接操作时 ， 自动调用toString() 方法 123Date now=new Date();System.out.println(“now=”+now); 相当于System.out.println(“now=”+now.toString()); 可以根据需要在用户自定义类型中重写toString() 基本类型数据转换为String 类型时 ，的 调用了对应包装类的toString() 方法 12int a=10;System.out.println(“a=”+a); 几个典型实例 12345678char[] arr = new char[] &#123; 'a', 'b', 'c' &#125;; System.out.println(arr); // abc System.out.println("arr = "+arr); // arr = [C@12a3a380 int[] arr1 = new int[] &#123; 1, 2, 3 &#125;; System.out.println(arr1); // [I@12a3a380 double[] arr2 = new double[] &#123; 1.1, 2.2, 3.3 &#125;; System.out.println(arr2); // [D@29453f44 包装类 拆箱： 获得 包装类对象中包装的基本类型变量 装箱：基本 数据类型包装成包装类的实例 在JDK1.5以前的版本中，表达式1和表达式2都要求是相同的类型，比如都是String或者char之类的，在JDK1.5以后，有了自动拆箱和装箱的原因，两者只要其中一种或者两者都能被拆箱即 例题 123456789101112 Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1); // 1.0 /**三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为Object，输出时使用多态调用重写的toString();即Double包装类的toString();*/ Object o2; if (true) o2 = new Integer(1); else o2 = new Double(2.0); System.out.println(o2);// 1 static 使用：在Java类中，可用static修饰属性、方法、代码块、内部类 被修饰后的成员具备以下特点： 1.随着类的加载而加载 2.优先于对象存在 3.修饰的成员，被所有对象所共享 4.访问权限允许时，可不创建对象，直接被类调用 内存解析 注意点： 1.没有对象的实例时，可以用 类名. 方法名()的形式访问由static修饰的类方法 2.在static 方法内部只能访问类的 static 修饰的属性或方法， 不能访问类的非 非static 的结构 3.因为不需要实例就可以访问static 方法，因此static 方法内部不能有this（也不能有super） 4.static修饰的方法不能被重写 4的解释： 1首先明确一点，在子类中重写父类的static方法，是不会报错的，编译也可以通过，但是在通过一个声明为父类，实际类型为子类的引用变量调用该方法时，发现被调用的仍是父类中原本以为会被覆盖的方法，不具有“多态”特性。 代码块 静态代码块：用static修饰的代码块 1.可以有输出语句 2.可以对类的属性、类的声明进行初始化操作 3.不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法 4.若有多个静态的代码块，那么按照从上到下的顺序依次执行 5.静态代码块的执行要先于非静态代码块 6.静态代码块随着类的加载而加载，且只执行一次 非静态代码块：没有static修饰顶的代码块 1.可以有输出语句 2.可以对类的属性、类的声明进行初始化操作 3.除了调用非静态的结构外，还可以调用静态的变量或方法 4.若有多个非静态的代码块，那么按照从上到下的顺序依次执行 5.每次创建对象的时候，都会执行一次。且先于构造器执行 示例： 1234567class Person &#123; public static int total; static &#123; total = 100; System.out.println("in static block!"); &#125;&#125; 程序中成员变量赋值的执行顺序 1.声明成员变量的默认初始化 2.显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行） 3.构造器再对成员进行初始化操作 4.通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值 final 特点 1.final标记的类不能被继承 2.final标记的方法不能被子类重写 3.final标记的变量（成员变量或局部变量）即称为常量。名称大写，且只能被赋值1次 4.final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用 5.常量名要大写，内容不可修改 6.static final：全局常量 抽象类与抽象方法 注意点： 1.用abstract关键字来修饰一个类，这个类叫做抽象类 2.用abstract来修饰一个方法，该方法叫做抽象方法 3.抽象方法：只有方法的声明，没有方法的实现。以分号结束：比如：public abstract void talk(); 4.含有抽象方法的类必须被声明为抽象类 5.抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。 6.不能用abstract修饰变量、代码块、构造器 7.不能用abstract修饰私有方法、静态方法、final的方法、final的类 接口 定义：接口(interface)是抽象方法和常量值定义的集合，（接口都是public abstract 修饰的，默认省略） 特点： 1.用interface来定义 2.接口中的所有成员变量都默认是由public static final修饰的,(public static final默认省略不写) 3.接口中的所有抽象方法都默认是由public abstract修饰的 4.接口中没有构造器 5.接口采用多继承机制 示例 123456public interface Runner &#123; public static final int ID = 1; public abstract void start(); public abstract void run(); public abstract void stop();&#125; 问题处理 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突 解决：实现类必须覆盖接口中同名同参数的方法，来解决冲突 12345678class Man implements Filial, Spoony &#123; @Override public void help() &#123; System.out.println("我该怎么办呢？"); Filial.super.help(); //这两句 Spoony.super.help(); // &#125;&#125; 2.若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守： 类优先原则。接口中具有相同名称和参数的默认方法会被忽略。 内部类 定义：在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类 Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称,Inner class的名字不能与包含它的外部类类名相同； 分类： 成员 内部类（static成员内部类和非static成员内部类）、局部内部类（不谈修饰符）、匿名内部类 成员内部类 作为类的成员的角色：和外部类不同，Inner class还可以声明为private或protected； 可以调用外部类的结构，Inner class可以声明为static的，但此时就不能再使用外层类的非static的成员变量 作为类的角色： 可以在内部定义属性、方法、构造器等结构，可以声明为abstract类 ，因此可以被其它的内部类继承，可以声明为final的，编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类） 注意： 1.非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员 2.外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 3.成员内部类可以直接使用外部类的所有成员，包括私有的数据 4.当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的 局部内部类 如何声明局部内部类 1234567891011class 外部类&#123; 方法()&#123; class 局部内部类&#123; &#125; &#125; &#123; class 局部内部类&#123; &#125; &#125;&#125; 如何使用？ 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型 局部内部类可以使用外部类的成员，包括私有的 局部内部类可以使用外部方法的局部变量，但是必须是final的 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private 局部内部类不能使用static修饰，因此也不能包含静态成员 匿名内部类 定义：匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类 格式: 123new 父类构造器（实参列表）| 实现接口()&#123;// 匿名内部类的类体部分&#125; 特点 匿名内部类必须继承父类或实现接口 匿名内部类只能有一个对象 匿名内部类对象只能使用多态形式引用]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays工具类]]></title>
    <url>%2F2020%2F02%2F23%2FArrays%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[几个常用方法 boolean equals(int[] a,int[] b)：判断两个数组是否相等（比较内容） String toString(int[] a)：输出数组信息 void fill(int[] a,int val)：将指定值填充到数组之中 void sort(int[] a)：对数组进行排序 int binarySearch(int[] a,int key)：对排序后的数组进行二分检索指定的值,返回索引位置,找不到的话返回值比较麻烦，要判断 [1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [3] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。 123456 int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;; int x1 = Arrays.binarySearch(a, 5); int x2 = Arrays.binarySearch(a, 4); int x3 = Arrays.binarySearch(a, 0); int x4 = Arrays.binarySearch(a, 10);//结果为：x1=-4 x2=2 x3=-1 x4=-7 根据数组创建ArrayList 1234String[] stringArray = &#123; "a", "b", "c", "d", "e" &#125;;ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));// [a, b, c, d, e]System.out.println(arrayList); 检查数组是否包含某个值 1234String[] stringArray = &#123; "a", "b", "c", "d", "e" &#125;;boolean b = Arrays.asList(stringArray).contains("a");// trueSystem.out.println(b); 将ArrayList转换为数组 123456String[] stringArray = &#123; "a", "b", "c", "d", "e" &#125;;ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));String[] stringArr = new String[arrayList.size()];arrayList.toArray(stringArr);for (String s : stringArr) System.out.println(s); 将数组转换为Set 123Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(stringArray));//[d, e, b, c, a]System.out.println(set);]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单位运算]]></title>
    <url>%2F2020%2F02%2F23%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算符 1.位运算符操作的都是整形的数据 2.类型： 左移运算符 &lt;&lt; ：在一定范围内，每向左移动一位，相当于 * 2 右移运算符 &gt;&gt; ：在一定范围内，每向右移一位，相当于 / 2 3.举例： 21 &lt;&lt; 2 = 82 3 &gt;&gt; 1 = 1 4.说明 左移运算符，空位补0，被移除的最高位丢弃，空缺位补0 右移运算符，被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1 无符号右移 &gt;&gt;&gt; ，被移位二进制最高位无论是0或者是1，空缺位都用0补]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存解析]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简单了解大致分为3部分栈用来存放局部变量 堆存放new出来的结构：类对象、数组 方法区分为常量池和静态域 方法区在堆空间内，用于存放： ①类的代码信息； ②静态变量和方法； ③常量池（字符串常量等，具有共享机制）。 一维数组内存简单解析 二维数组内存简单解析 实例分析注意点 Java中除了基本数据类型，其他的均是引用类型，包括类、数组等等。 数据类型的默认值，基本数据类型默认值： 数值型：0 浮点型：0.0 布尔型：false 字符型：\u0000 引用类型：null 变量初始化： 成员变量可不初始化，系统会自动初始化； 局部变量必须由程序员显式初始化，系统不会自动初始化。 实例：分别是Student类、Computer类、Test类，代码如下： 12345678910111213public class Student &#123; int score; int age; String name; Computer computer; public void study() &#123; System.out.println("studying..."); &#125;&#125; 1234public class Computer &#123; int price; String brand;&#125; 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.name = "xiaoming"; stu.age = 10; stu.study(); Computer c = new Computer(); c.brand = "Hasse"; System.out.println(c.brand); stu.computer = c; System.out.println(stu.computer.brand);// System.out.println("----------------------------------------");//// c.brand = "Dell";//// System.out.println(c.brand);// System.out.println(stu.computer.brand);//// System.out.println(stu.computer.brand == c.brand); &#125;&#125; 分析： 程序的入口是main()，因而从main方法从上到下、从左到右进行分析。 Student stu = new Student(); ①首先，Java虚拟机（JVM）去方法区寻找是否有Test类的代码信息，如果存在，直接调用。如果没有，通过类加 载器（ClassLoader）把.class字节码加载到内存中，并把静态变量和方法、常量池加载（“xiaoming”、“Hasse”）。 ②走到Student，以同样的逻辑对Student类进行加载；静态成员；常量池（“studying”）。 ③走到stu，stu在main方法内部，因而是局部变量，存放在栈空间中。 ④走到new Student，new出的对象（实例），存放在堆空间中，以方法区的类信息为模板创建实例。 ⑤‘’=‘’赋值操作，把new Student的地址告诉stu变量，stu通过四字节的地址（十六进制），引用该实例。 stu.name = “xiaoming”; ⑥stu通过引用new Student实例的name属性，该name属性通过地址指向常量池的”xiaoming”敞亮。 stu.age = 10; ⑦s实例的age属性是基本数据类型，基本数据类型直接赋值。 stu.study(); ⑧调用实例的方法时，并不会在实例对象中生成一个新的方法，而是通过地址指向方法区中类信息的方法。 Computer c = new Computer(); 同stu变量的生成过程。 c.brand = “Hasse”; 同stu.name = “xiaoming”过程。 stu.computer = c; ⑨把c对象对Computer实例的引用赋值给Student实例的computer属性。亦即：该Student实例的computer属性指向该Computer类的实例。 如下图： 为进一步理解，我们把注释内容去掉：⑨重新将Computer实例的brand属性指向”Dell”常量，那stu.computer.brand指向谁呢？Dell还是Hasse？ 1c.brand = "Dell"; 根据刚才的分析可知：stu通过地址引用Student实例，而该实例的computer的指向和c的指向是同一个Computer实例，因而改变该Computer实例的brand属性的指向，两者都会改变。 理解字符串常量及常量池下面我们添加新的代码，如下： 12String str = "Dell";System.out.println(c.brand == str); 结果会如何呢？根据常量池具有共享性，可知并不会生成新的常量”Dell”，而是会把str通过地址指向原来的”Dell”，因而结果是true。]]></content>
      <categories>
        <category>Java基础复习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2019%2F10%2F29%2F2019-10-29-git%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[GIt基础创建版本库 通过git init命令把一个目录变成Git可以管理的仓库 1git init 执行完后当前目录下会多一个.git的文件夹，默认情况下该文件夹是隐藏的，可以选择查看隐藏文件来显示 把文件添加到版本库1git add &lt;filename&gt; 把添加的文件提交到仓库1git commit -m &quot;本次提交说明&quot; GIt版本控制查看仓库当前状态1git status 查看某个文件的改动12345678910git diff &lt;filename&gt;$ git diff demo.txtdiff --git a/demo.txt b/demo.txtindex 66b666f..e10e664 100644--- a/demo.txt+++ b/demo.txt@@ -1 +1,2 @@ Creating a new branch is quick ccccc.+ssssssssssssssssssssss. 查看提交日志 git log命令显示从最近到最远的提交日志 ， 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1git log --pretty=oneline 版本回退 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 1git reset --hard HEAD^ 回退到上一个版本 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ git提供了一个命令git reflog用来记录你的每一次命令,找到对应的commit id即可 1git reflog 放弃修改 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD，就回到了场景1，第二步按场景1操作。 远程仓库本地库关联远程库123$ git remote add origin git@github.com:自己的Github用户名/远程仓库名.giteg: 我要关联我的远程仓库learngit$ git remote add origin git@github.com:Commandercc/learngit.git 把本地库内容推到远程库123git push -u origin master由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1git push origin master 克隆远程库123git clone &lt;远程仓库地址&gt;eg:git clone https://github.com/Commandercc/gitskills.git 分支管理创建与合并分支查看分支1git branch 创建分支123创建分支用 git branch &lt;name&gt; 2.23版本之前创建并切换到新的分支 git checkout -b &lt;name&gt; ==&gt; 相当于 git branch dev + git checkout dev 两条命令（先创建再跳转）2.23版本之后创建并切换到新的分支可以用 git switch -c &lt;name&gt; 切换分支12git checkout &lt;name&gt; 或 git switch &lt;name&gt;2.23版本后更推荐新的 switch 命令 合并某个分支到当前分支1git merge &lt;name&gt; 删除某个分支1git branch -d &lt;name&gt; 查看分支合并图123git log --graph (详细)git log --graph --pretty=oneline --abbrev-commit 现场保存1234567891011修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；查看保存的工作现场： git stash list恢复工作现场:一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了：你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：$ git stash apply stash@&#123;0&#125;(apply 后加要恢复的编号)在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 删除未合并的分支1git branch -D &lt;name&gt; 强行删除 多人协作查看远程库的信息 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 1git remote 或者用 git remote -v 显示更详细的信息： 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1git push origin master 如果要推送其他分支，比如dev，就改成 1git push origin dev 抓取分支当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送 ，推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 指定本地dev分支与远程origin/dev分支的链接 1git branch --set-upstream-to=origin/dev dev 标签管理 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 创建标签1git tag &lt;name&gt; 查看所有标签1git tag 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了： 1$ git tag v0.9 f52c633 查看某个标签信息1git show &lt;tagname&gt; 创建带有说明的标签123用-a指定标签名，-m指定说明文字$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb用命令git show &lt;tagname&gt;可以看到说明文字 删除标签1git tag -d v1.0 推送标签 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin： 123git push origin v1.0或一次性推送全部尚未推送到远程的本地标签git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 学习记录(二)]]></title>
    <url>%2F2019%2F10%2F26%2F2019-10-26-Dart-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[运算符除法、整除、取模运算1234var num = 7;print(num / 3); // 除法操作, 结果2.3333..print(num ~/ 3); // 整除操作, 结果2;print(num % 3); // 取模操作, 结果1; ??= 赋值操作dart有一个很多语言都不具备的赋值运算符： 当变量为null时，使用后面的内容进行赋值。 当变量有值时，使用自己原来的值。 12345678main(List&lt;String&gt; args) &#123; var name1 = 'coderwhy'; print(name1); // var name2 = 'kobe'; var name2 = null; name2 ??= 'james'; print(name2); // 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james&#125; ?? 条件运算符Dart中包含一直比较特殊的条件运算符：expr1 ?? expr2 如果expr1是null，则返回expr2的结果; 如果expr1不是null，直接使用expr1的结果。 1234var temp = 'why';temp = null;var name = temp ?? 'kobe';print(name); //输出： Kobe .. 级联语法1234567891011121314151617181920212223242526272829class Person &#123; String name; void run() &#123; print("$&#123;name&#125; is running"); &#125; void eat() &#123; print("$&#123;name&#125; is eating"); &#125; void swim() &#123; print("$&#123;name&#125; is swimming"); &#125;&#125;main(List&lt;String&gt; args) &#123; final p1 = Person(); p1.name = 'sss'; p1.run(); p1.eat(); p1.swim(); //使用级联语法 .. final p2 = Person() ..name = "ccc" ..run() ..eat() ..swim();&#125; 流程控制if和else 参考其他语言的用法但要注意： 不支持非空即真或者非0即真，必须有明确的bool类型 循环操作 基本for循环 123for (var i = 0; i &lt; 5; i++) &#123; print(i);&#125; for in 遍历List和Set类型 1234var names = ['why', 'kobe', 'curry'];for (var name in names) &#123; print(name);&#125; while和do-while 和其他语言一致 break和continue用法也和其他语言一致 switch-case普通的switch使用 注意：每一个case语句，默认情况下必须以一个break结尾 12345678910111213141516171819main(List&lt;String&gt; args) &#123; var direction = 'east'; switch (direction) &#123; case 'east': print('东面'); break; case 'south': print('南面'); break; case 'west': print('西面'); break; case 'north': print('北面'); break; default: print('其他方向'); &#125;&#125; 类和对象类的定义在Dart中，定义类用class关键字。 和Java一样， 类通常有两部分组成：成员（member）和方法（method） 。 123456class 类名 &#123; 类型 成员名; 返回值类型 方法名(参数列表) &#123; 方法体 &#125;&#125; 编写一个简单的Person类 这里有一个注意点: 我们在方法中使用属性(成员/实例变量)时，并没有加this； Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略； 1234567class Person &#123; String name; eat() &#123; print('$name在吃东西'); &#125;&#125; 我们来使用这个类，创建对应的对象： 注意：从Dart2开始，new关键字可以省略。 12345678910main(List&lt;String&gt; args) &#123; // 1.创建类的对象 var p = new Person(); // 直接使用Person()也可以创建 // 2.给对象的属性赋值 p.name = 'why'; // 3.调用对象的方法 p.eat();&#125; 构造方法普通构造方法参考Java， 当通过类创建一个对象时，会调用这个类的构造方法。 当类中没有明确指定构造方法时，将默认拥有一个无参的构造方法 当有了自己的构造方法时，默认打的构造方法将会失效，不能使用 当然， 你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突； 这是因为Dart本身不支持函数的重载（名称相同, 参数不同的方式）。 1234567891011121314class Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @override String toString() &#123; return 'name=$name age=$age'; &#125;&#125; 另外，在实现构造方法时，通常做的事情就是通过参数给属性赋值 为了简化这一过程, Dart提供了一种更加简洁的语法糖形式. 上面的构造方法可以优化成下面的写法： 123456Person(String name, int age) &#123; this.name = name; this.age = age;&#125;// 等同于Person(this.name, this.age); 命名构造方法在开发中，我们确实 希望实现更多的构造方法，怎么办呢？ 因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法 。 我们需要使用命名构造方法： 12345678910111213141516171819202122232425class Person &#123; String name; int age; Person() &#123; name = ''; age = 0; &#125; // 命名构造方法 自己起一个名 这里名字叫做withArgments Person.withArgments(String name, int age) &#123; this.name = name; this.age = age; &#125; @override String toString() &#123; return 'name=$name age=$age'; &#125;&#125;// 创建对象var p1 = new Person();print(p1);var p2 = new Person.withArgments('why', 18);print(p2); 在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式: 比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法 123456789 // 新的构造方法Person.fromMap(Map&lt;String, Object&gt; map) &#123; this.name = map['name']; this.age = map['age']; &#125; // 通过上面的构造方法创建对象 var p3 = new Person.fromMap(&#123;'name': 'kobe', 'age': 30&#125;); print(p3); 初始化列表 初始化实例参数，用逗号分隔 我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance: 1234567891011121314class Point &#123; num x; num y; Point(this.x, this.y); // Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map jsonMap) : x = jsonMap['x'], y = jsonMap['y'] &#123; print('In Point.fromJson(): ($x, $y)'); &#125;&#125; 初始化列表非常适合用来设置 final 变量的值 12345678import 'dart:math';class Point &#123; final num x; final num y; final num distance; Point(this.x, this.y) : distance = sqrt(x * x + y * y);&#125; 重定向构造方法 在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法： 1234567class Person &#123; String name; int age; Person(this.name, this.age); Person.fromName(String name) : this(name, 0);&#125; 常量构造方法在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法. 默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码: 这里我们使用identical(对象1, 对象2)函数来判断两个对象是否是同一个对象: 1234567891011main(List&lt;String&gt; args) &#123; var p1 = Person('why'); var p2 = Person('why'); print(identical(p1, p2)); //输出结果为 false&#125;class Person &#123; String name; Person(this.name);&#125; 但是, 如果将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的 这样的构造方法就称之为常量构造方法 1234567891011main(List&lt;String&gt; args) &#123; var p1 = const Person('why'); var p2 = const Person('why'); print(identical(p1, p2)); // true&#125;class Person &#123; final String name; const Person(this.name);&#125; 常量构造方法有一些注意点: 注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的. 注意二：为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字 工厂构造方法 Dart提供了factory关键字, 用于通过工厂去获取对象 1234567891011121314151617181920212223main(List&lt;String&gt; args) &#123; var p1 = Person('why'); var p2 = Person('why'); print(identical(p1, p2)); // true&#125;class Person &#123; String name; static final Map&lt;String, Person&gt; _cache = &lt;String, Person&gt;&#123;&#125;; factory Person(String name) &#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125; else &#123; final p = Person._internal(name); _cache[name] = p; return p; &#125; &#125; Person._internal(this.name);&#125; setter和getter 参考java 默认情况下，Dart中类定义的属性是可以直接被外界访问的。 但是某些情况下，我们希望监控这个类的属性被访问的过程，这个时候就可以使用setter和getter了 123456789101112131415161718main(List&lt;String&gt; args) &#123; final d = Dog("黄色"); d.setColor = "黑色"; print(d.getColor);&#125;class Dog &#123; String color; String get getColor &#123; return color; &#125; set setColor(String color) &#123; this.color = color; &#125; Dog(this.color);&#125; 类的继承 关键字： extends 子类中用 super 来访问父类 父类中的所有成员变量和方法都会被继承，但是构造方法除外 12345678910111213141516171819main(List&lt;String&gt; args) &#123; var p = new Person(); p.age = 18; p.run(); print(p.age);&#125;class Animal &#123; int age; run() &#123; print('在奔跑ing'); &#125;&#125;//Person类继承了Animal 类class Person extends Animal &#123;&#125; 子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写： 12345678class Person extends Animal &#123; String name; @override run() &#123; print('$name在奔跑ing'); &#125;&#125; 子类中可以调用父类的构造方法，对某些属性进行初始化： 子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。 注意：！！！如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。 12345678910111213141516171819202122232425class Animal &#123; int age; Animal(this.age); run() &#123; print('在奔跑ing'); &#125;&#125;class Person extends Animal &#123; String name; Person(String name, int age) : name=name, super(age); @override run() &#123; print('$name在奔跑ing'); &#125; @override String toString() &#123; return 'name=$name, age=$age'; &#125;&#125; 抽象类 参考java 抽象类使用 abstract 声明的类 抽象类中的抽象方法，不需要在抽象类中实现，只需声明即可 抽象类不能被实例化 即不能new一个抽象类 抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写. 1234567891011121314151617181920212223242526abstract class Shape &#123; getArea();&#125;class Circle extends Shape &#123; double r; Circle(this.r); @override getArea() &#123; return r * r * 3.14; &#125;&#125;class Reactangle extends Shape &#123; double w; double h; Reactangle(this.w, this.h); @override getArea() &#123; return w * h; &#125;&#125; 隐式接口Dart中的接口比较特殊, 没有一个专门的关键字来声明接口. 默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承) 在开发中，我们通常将用于给别人实现的类声明为抽象类: 实现接口用 implements 通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。 12345678910111213141516171819abstract class Runner &#123; run();&#125;abstract class Flyer &#123; fly();&#125;class SuperMan implements Runner, Flyer &#123; @override run() &#123; print('超人在奔跑'); &#125; @override fly() &#123; print('超人在飞'); &#125;&#125; Mixin 混入在上面我们了解了， 在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。 Dart提供了另外一种方案: Mixin混入的方式 除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。 只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。 123456789101112131415161718192021222324main(List&lt;String&gt; args) &#123; var superMan = SuperMain(); superMan.run(); superMan.fly();&#125;mixin Runner &#123; run() &#123; print('在奔跑'); &#125;&#125;mixin Flyer &#123; fly() &#123; print('在飞翔'); &#125;&#125;// implements的方式要求必须对其中的方法进行重新实现// class SuperMan implements Runner, Flyer &#123;&#125;class SuperMain with Runner, Flyer &#123;&#125; 类成员和方法 前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法 在Dart中我们使用 static 关键字来定义: 1234567891011121314151617181920212223242526main(List&lt;String&gt; args) &#123; var stu = Student(); stu.name = 'why'; stu.sno = 110; stu.study(); Student.time = '早上8点'; // stu.time = '早上9点'; 错误做法, 实例对象不能访问类成员 Student.attendClass(); // stu.attendClass(); 错误做法, 实现对象补鞥呢访问类方法&#125;class Student &#123; String name; int sno; static String time; study() &#123; print('$name在学习'); &#125; static attendClass() &#123; print('去上课'); &#125;&#125; 枚举类型枚举的定义 参考java 用关键字 enum 定义 不能子类化、混合或实现枚举 不能显式实例化一个枚举 123456789main(List&lt;String&gt; args) &#123; print(Colors.red);&#125;enum Colors &#123; red, green, blue&#125; 枚举的属性枚举类型中有两个常见的属性： index: 用于表示每个枚举常量的索引，从0开始。 values: 包含每个枚举值的List。 12345678910111213main(List&lt;String&gt; args) &#123; print(Colors.red.index); print(Colors.green.index); print(Colors.blue.index); print(Colors.values);&#125;enum Colors &#123; red, green, blue&#125; 泛型 参考Java List和Map的泛型List使用时的泛型写法： 1234567// 创建List的方式var names1 = ['why', 'kobe', 'james', 111];print(names1.runtimeType); // List&lt;Object&gt;// 限制类型var names2 = &lt;String&gt;['why', 'kobe', 'james', 111]; // 最后一个报错List&lt;String&gt; names3 = ['why', 'kobe', 'james', 111]; // 最后一个报错 Map使用时的泛型写法： 1234567// 创建Map的方式var infos1 = &#123;1: 'one', 'name': 'why', 'age': 18&#125;; print(infos1.runtimeType); // _InternalLinkedHashMap&lt;Object, Object&gt;// 对类型进行显示Map&lt;String, String&gt; infos2 = &#123;'name': 'why', 'age': 18&#125;; // 18不能放在value中var infos3 = &lt;String, String&gt;&#123;'name': 'why', 'age': 18&#125;; // 18不能放在value中 类定义的泛型如果我们需要定义一个类, 用于存储位置信息Location, 但是并不确定使用者希望使用的是int类型,还是double类型, 甚至是一个字符串, 这个时候我们就可以使用泛型。 123456789101112131415main(List&lt;String&gt; args) &#123; Location l2 = Location&lt;int&gt;(10, 20); print(l2.x.runtimeType); // int Location l3 = Location&lt;String&gt;('aaa', 'bbb'); print(l3.x.runtimeType); // String&#125;&#125;class Location&lt;T&gt; &#123; T x; T y; Location(this.x, this.y);&#125; 如果希望类型只能是num类型： 123456789101112131415main(List&lt;String&gt; args) &#123; Location l2 = Location&lt;int&gt;(10, 20); print(l2.x.runtimeType); // 错误的写法, 类型必须继承自num Location l3 = Location&lt;String&gt;('aaa', 'bbb'); print(l3.x.runtimeType);&#125;class Location&lt;T extends num&gt; &#123; T x; T y; Location(this.x, this.y);&#125; 泛型方法的定义123456789main(List&lt;String&gt; args) &#123; var names = ['why', 'kobe']; var first = getFirst(names); print('$first $&#123;first.runtimeType&#125;'); // why String&#125;//一定要注意写法T getFirst&lt;T&gt;(List&lt;T&gt; ts) &#123; return ts[0];&#125; 库的使用 在Dart中，你可以导入一个库来使用它所提供的功能。 库的使用可以使代码的重用性得到提高，并且可以更好的组合代码。 Dart中任何一个dart文件都是一个库，即使你没有用关键字library声明 导入库1import '库所在的uri'; 常见的库URI有三种不同的形式 来自dart标准版，比如dart:io、dart:html、dart:math、dart:core(但是这个可以省略) 12//dart:前缀表示Dart的标准库，如dart:io、dart:html、dart:mathimport 'dart:io'; 使用相对路径导入的库，通常指自己项目中定义的其他dart文件 12//当然，你也可以用相对路径或绝对路径的dart文件来引用import 'lib/student/student.dart'; Pub包管理工具管理的一些库，包括自己的配置以及一些第三方的库，通常使用前缀package 12//Pub包管理系统中有很多功能强大、实用的库，可以使用前缀 package:import 'package:flutter/material.dart'; 库文件中内容的显示和隐藏 如果希望只导入库中某些内容，或者刻意隐藏库里面某些内容，可以使用show和hide关键字 show 关键字，可以显示某个成员（屏蔽其他） hide 关键字，可以隐藏某个成员（显示其他） 123import 'lib/student/student.dart' show Student, Person;import 'lib/student/student.dart' hide Person; 库中内容和当前文件中的名字冲突 当各个库有命名冲突的时候，可以使用as关键字来使用命名空间 123import 'lib/student/student.dart' as Stu;Stu.Student s = new Stu.Student(); 库的定义 library 关键字 通常在定义库时，我们可以使用library关键字给库起一个名字。 但库的名字并不影响导入，因为import语句用的是字符串Uri 1library math; 库的管理和组织 如果库非常大，如何进行管理呢？ 将每一个dart文件作为库文件，使用export关键字在某个库文件中单独导入 mathUtils.dart文件 （分） 123int sum(int num1, int num2) &#123; return num1 + num2;&#125; dateUtils.dart文件 ？（分） 123String dateFormat(DateTime date) &#123; return "2020-12-12";&#125; utils.dart文件 (合) 1234library utils;export "mathUtils.dart";export "dateUtils.dart"; test_libary.dart文件 (用) 123456import "lib/utils.dart";main(List&lt;String&gt; args) &#123; print(sum(10, 20)); print(dateFormat(DateTime.now()));&#125;]]></content>
      <categories>
        <category>dart</category>
      </categories>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 学习记录(-)]]></title>
    <url>%2F2019%2F10%2F24%2F2019-10-24-Dart-%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[参考文章hello world1234//dart 语言的入口是main函数，并且没有返回值main(List&lt;String&gt; args) &#123; print('Hello World');&#125; 定义变量1var /dynamic /const /final 变量名=变量值 var 的使用1234567var name = 'coderwhy';name = 'kobe';print(name.runtimeType); // String runtimeType用于获取当前变量的类型//错误用法var age = 18;age = 'why'; // 不可以将String赋值给一个int类型 dynamic 的使用123456//dynamic 动态的意思 上面var赋值的那种错误做法，可以用dynamic来解决，但在开发中，通常情况下不会使用dynamic，因为类型的变量会带来潜在的危险。dynamic name = 'coderwhy';print(name.runtimeType); // Stringname = 18;print(name.runtimeType); // int final 和 const 的使用1234567891011121314151617181920//final 和 const 都是用于定义常量的，也就是定义之后值都不可以修改final name = 'coderwhy';name = 'kobe'; // 错误做法const age = 18;age = 20; // 错误做法//final和const的区别//const在赋值时, 赋值的内容必须是在编译期间就确定下来的//final在赋值时, 可以动态获取, 比如赋值一个函数String getName() &#123; return 'coderwhy';&#125;main(List&lt;String&gt; args) &#123; const name = getName(); // 错误的做法, 因为要执行函数才能获取到值 final name = getName(); // 正确的做法&#125; 数据类型数字类型1整数用 int ， 浮点数用 double 布尔类型1234567891011121314//dart中提供了一个bool的类型，取值为 true或false// 布尔类型var isFlag = true;print('$isFlag $&#123;isFlag.runtimeType&#125;');//控制台输出结果： true bool//注意：dart中不能判断非0即真，或者非空即真，Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。 var message = 'Hello Dart'; // 错误的写法 if (message) &#123; print(message) &#125; 字符串类型12345678910111213141516171819202122//dart字符串是UTF-16编码单元的序列，可以使用单引号或双引号创建一个字符串// 1.定义字符串的方式var s1 = 'Hello World';var s2 = "Hello Dart";var s3 = 'Hello\'Fullter';var s4 = "Hello'Fullter";//可以使用三个单引号或者双引号表示多行字符串// 2.表示多行字符串的方式var message1 = '''哈哈哈呵呵呵嘿嘿嘿''';//控制台输出会保持原格式//字符串和其他变量或表达式拼接，使用 $&#123;expression&#125;,如果表达式是一个标识符，那么&#123;&#125;可以省略// 3.拼接其他变量var name = 'coderwhy';var age = 18;var height = 1.88;print('my name is $&#123;name&#125;, age is $age, height is $height'); 集合类型123456789101112131415161718192021222324252627282930//对于集合类型，dart则内置了最常用的三种： List / Set /Map ,用法类比Java啥的即可// List定义 用 []// 1.使用类型推导定义var letters = ['a', 'b', 'c', 'd'];print('$letters $&#123;letters.runtimeType&#125;');// 2.明确指定类型List&lt;int&gt; numbers = [1, 2, 3, 4];print('$numbers $&#123;numbers.runtimeType&#125;');// Set的定义 用 &#123;&#125;// 1.使用类型推导定义var lettersSet = &#123;'a', 'b', 'c', 'd'&#125;;print('$lettersSet $&#123;lettersSet.runtimeType&#125;');// 2.明确指定类型Set&lt;int&gt; numbersSet = &#123;1, 2, 3, 4&#125;;print('$numbersSet $&#123;numbersSet.runtimeType&#125;');//Set是无序的，并且元素是不重复的，这都知道// Map的定义// 1.使用类型推导定义var infoMap1 = &#123;'name': 'why', 'age': 18&#125;;print('$infoMap1 $&#123;infoMap1.runtimeType&#125;');// 2.明确指定类型Map&lt;String, Object&gt; infoMap2 = &#123;'height': 1.88, 'address': '北京市'&#125;;print('$infoMap2 $&#123;infoMap2.runtimeType&#125;'); 集合常见操作123456789101112131415161718192021222324252627282930313233343536373839404142434445//1.所有集合都支持的获取长度的属性 length// 获取集合的长度print(letters.length);print(lettersSet.length);print(infoMap1.length);//2.添加/删除/包含 操作// 添加/删除/包含元素numbers.add(5);numbersSet.add(5);print('$numbers $numbersSet');numbers.remove(1);numbersSet.remove(1);print('$numbers $numbersSet');print(numbers.contains(2));print(numbersSet.contains(2));// List根据index删除元素numbers.removeAt(3);print('$numbers');//3.Map的操作//由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value键值对的。// Map的操作// 1.根据key获取valueprint(infoMap1['name']); // why// 2.获取所有的entriesprint('$&#123;infoMap1.entries&#125; $&#123;infoMap1.entries.runtimeType&#125;'); // (MapEntry(name: why), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;// 3.获取所有的keysprint('$&#123;infoMap1.keys&#125; $&#123;infoMap1.keys.runtimeType&#125;'); // (name, age) _CompactIterable&lt;String&gt;// 4.获取所有的valuesprint('$&#123;infoMap1.values&#125; $&#123;infoMap1.values.runtimeType&#125;'); // (why, 18) _CompactIterable&lt;Object&gt;// 5.判断是否包含某个key或者valueprint('$&#123;infoMap1.containsKey('age')&#125; $&#123;infoMap1.containsValue(18)&#125;'); // true true// 6.根据key删除元素infoMap1.remove('age');print('$&#123;infoMap1&#125;'); // &#123;name: why&#125; 函数12Dart是一种真正的面向对象语言，所以即使函数也是对象，所有也有类型, 类型就是Function。这也就意味着函数可以作为变量定义或者作为其他函数的参数或者返回值. 函数的定义方式12345678910111213//1.函数的定义方式返回值 函数的名称(参数列表) &#123; 函数体 return 返回值&#125;//eg: 定义一个求和函数int sum(num num1, num num2) &#123; return num1 + num2;&#125;//另外, 如果函数中只有一个表达式, 那么可以使用箭头语法(arrow syntax)sum(num1, num2) =&gt; num1 + num2; 函数的参数问题1234567891011121314151617181920212223242526272829303132////可选参数可以分为 命名可选参数 和 位置可选参数//定义方式命名可选参数: &#123;param1, param2, ...&#125;位置可选参数: [param1, param2, ...]//命名可选参数的演示// 定义命名可选参数printInfo1(String name, &#123;int age, double height&#125;) &#123; print('name=$name age=$age height=$height');&#125;// 调用printInfo1函数printInfo1('why'); // name=why age=null height=nullprintInfo1('why', age: 18); // name=why age=18 height=nullprintInfo1('why', age: 18, height: 1.88); // name=why age=18 height=1.88printInfo1('why', height: 1.88); // name=why age=null height=1.88//位置可选参数的演示// 定义位置可选参数printInfo2(String name, [int age, double height]) &#123; print('name=$name age=$age height=$height');&#125;// 调用printInfo2函数printInfo2('why'); // name=why age=null height=nullprintInfo2('why', 18); // name=why age=18 height=nullprintInfo2('why', 18, 1.88); // name=why age=18 height=1.88//参数的默认值，可选参数才能设置默认值，必选参数不可以printInfo4(String name, &#123;int age = 18, double height=1.88&#125;) &#123; print('name=$name age=$age height=$height');&#125; 函数是一等公民1234567891011121314151617181920212223242526272829//这就意味着你可以将函数赋值给一个变量, 也可以将函数作为另外一个函数的参数或者返回值来使用.main(List&lt;String&gt; args) &#123; // 1.将函数赋值给一个变量 var bar = foo; print(bar); // 2.将函数作为另一个函数的参数 test(foo); // 3.将函数作为另一个函数的返回值 var func =getFunc(); func('kobe');&#125;// 1.定义一个函数foo(String name) &#123; print('传入的name:$name');&#125;// 2.将函数作为另外一个函数的参数test(Function func) &#123; func('coderwhy');&#125;// 3.将函数作为另一个函数的返回值getFunc() &#123; return foo;&#125; 匿名函数的使用1234567891011121314151617//匿名函数( anonymous function)，也可以叫lambda或者closure。main(List&lt;String&gt; args) &#123; // 1.定义数组 var movies = ['盗梦空间', '星际穿越', '少年派', '大话西游']; // 2.使用forEach遍历: 有名字的函数 printElement(item) &#123; print(item); &#125; movies.forEach(printElement); // 3.使用forEach遍历: 匿名函数 movies.forEach((item) &#123; print(item); &#125;); movies.forEach((item) =&gt; print(item));&#125; 词法的作用域123456789101112//dart中的词法有自己明确的作用域范围，它是根据代码的结构(&#123;&#125;)来决定作用域范围的,优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。var name = 'global';main(List&lt;String&gt; args) &#123; // var name = 'main'; void foo() &#123; // var name = 'foo'; print(name); &#125; foo();&#125; 词法闭包12345678910111213141516//闭包可以访问其词法范围内的变量，即使函数在其他地方被使用，也可以正常的访问。main(List&lt;String&gt; args) &#123; makeAdder(num addBy) &#123; return (num i) &#123; return i + addBy; &#125;; &#125; var adder2 = makeAdder(2); print(adder2(10)); // 12 print(adder2(6)); // 8 var adder5 = makeAdder(5); print(adder5(10)); // 15 print(adder5(6)); // 11&#125; 返回值问题12345678//所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。main(List&lt;String&gt; args) &#123; print(foo()); // null&#125;foo() &#123; print('foo function');&#125;]]></content>
      <categories>
        <category>dart</category>
      </categories>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父子组件之间的通信]]></title>
    <url>%2F2019%2F10%2F22%2F2019-10-22-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父组件向子组件传递信息 通过props属性eg: 父组件的data属性里有message和movies两个属性，现在要实现将这两个属性的内容传递给子组件，并在子组件中进行显示。 方法：在子组件中定义props属性，在父组件中引入子组件时，将props中的属性和父组件中的message和movies做一个绑定即可 子组件向父组件传递信息 通过 this.$emit(‘event’,[args])eg: 子组件里有一个简单的三个button按钮的导航栏，点击不同的按钮时，会将次按钮的信息传递给父组件，并在父组件中进行显示 方法： 在父组件中进行方法绑定 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;父子组件通信&lt;/title&gt; &lt;script src="vue.min.js"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 父组件 --&gt; &lt;div id="app"&gt; &lt;cpn :cmovies="movies" :cmessage="message" @itemclick="cpnclick"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;!-- 子组件 --&gt; &lt;template id="cpn"&gt; &lt;div&gt; &lt;button v-for="item in categories" @click="itemclick(item)"&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt; &#123;&#123;cmovies&#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //子组件 const cpn = &#123; template: '#cpn', props: &#123; cmovies: Array, cmessage: String &#125;, data() &#123; return &#123; categories: [ &#123; id: 1, name: '热门推荐' &#125;, &#123; id: 2, name: '手机数码' &#125;, &#123; id: 3, name: '家用办公' &#125; ] &#125; &#125;, methods: &#123; itemclick(item) &#123; this.$emit('itemclick', item) &#125; &#125; &#125; //父组件 将父组件中的message和movies传递给子组件来显示 const app = new Vue(&#123; el: '#app', data: &#123; message: '你好啊', movies: ['海王', '海尔兄弟', "加勒比海盗"] &#125;, components: &#123; cpn //注册子组件 &#125;, methods: &#123; cpnclick(item) &#123; console.log(item) //打印子组件传递的按钮信息 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element 导航菜单 NavMenu 根据当前路由路径设置相应菜单项被选中]]></title>
    <url>%2F2019%2F10%2F20%2FElement%20%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95%20NavMenu%20%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8D%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%BA%94%E8%8F%9C%E5%8D%95%E9%A1%B9%E8%A2%AB%E9%80%89%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[Element 导航菜单 NavMenu 根据当前路由路径设置相应菜单项被选中思路 NavMenu菜单有个属性为 default-active ，是当前激活菜单的Index，因此只需要通过 $route.path 获取路由路径，在加以判断，重新给default-active 指定值即可。 12345678910111213141516171819202122&lt;div&gt; &lt;el-menu :default-active=&quot;activeIndex($route.path)&quot; :router=&quot;true&quot; class=&quot;el-menu-demo&quot; mode=&quot;horizontal&quot; @select=&quot;handleSelect&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; &gt; &lt;el-menu-item index=&quot;/home/index&quot;&gt; &lt;i class=&quot;fa fa-wa fa-cny&quot;&gt;&lt;/i&gt;首页 &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/home/myorder&quot;&gt; &lt;i class=&quot;fa fa-wa fa-users&quot;&gt;&lt;/i&gt; 我的订单 &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/home/tobuy&quot;&gt; &lt;i class=&quot;fa fa-wa fa-pencil&quot;&gt;&lt;/i&gt; 我要订购 &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt; 123456789101112131415 methods: &#123; activeIndex(path) &#123; console.log(path); if (path.indexOf("/index") != -1) &#123; console.log("111111"); return "/home/index"; &#125; else if (path.indexOf("/myorder") != -1) &#123; console.log("22222"); return "/home/myorder"; &#125; else if (path.indexOf("/tobuy") != -1) &#123; console.log("33333"); return "/home/tobuy"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 服务]]></title>
    <url>%2F2019%2F10%2F08%2F33-%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[服务 服务是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。 服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程，当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行 服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况 创建一个服务创建 默认代码12345678910public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125;&#125; 这个服务类是继承于Service类的，其中必须实现抽象方法onBind()服务中最常见的三个重写方法: onCreate()：创建时调用 onStartCommand()：启动时调用 onDestroy()：销毁时调用 注册服务（按照上图创建会自动注册）12345&lt;service android:name=".MyService" android:enabled="true" android:exported="true"&gt;&lt;/service&gt; Exported表示是否允许其他程序访问此服务 Enabled表示是否启用此服务 启动和停止服务布局12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/start" android:text="启动服务"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/stop" android:text="关闭服务"/&gt;&lt;/LinearLayout&gt; 活动123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button start; private Button stop; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); start = findViewById(R.id.start); stop = findViewById(R.id.stop); start.setOnClickListener(this); stop.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.start: Intent intent_start = new Intent(MainActivity.this, MyService.class); startService(intent_start); //开启服务 break; case R.id.stop: Intent intent_stop = new Intent(MainActivity.this, MyService.class); stopService(intent_stop); //停止服务 break; &#125; &#125;&#125; 修改服务1234567891011121314151617181920212223242526272829public class MyService extends Service &#123; private static final String TAG = "MyService"; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: 创建服务"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: 启动服务"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: 销毁服务"); &#125;&#125; 服务和活动通信通信需要在服务中借助onBind()方法，一般需要创建一个专门的Binder对象管理。 模拟下载功能： 服务类1234567891011121314151617181920public class MyService extends Service &#123; private static final String TAG = "MyService"; private DownloadBinder mBinder = new DownloadBinder(); @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;...... class DownloadBinder extends Binder &#123; public void startDownload()&#123; Log.d(TAG, "startDownload: 开始下载"); &#125; public int getProgress()&#123; Log.d(TAG, "getProgress: 获取进度"); return 0; &#125; &#125;&#125; 布局123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt;...... &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/bind_service" android:text="绑定服务"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/unbind_service" android:text="解绑服务"/&gt; &lt;/LinearLayout&gt; 活动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button_start = findViewById(R.id.start); Button button_stop = findViewById(R.id.stop); button_start.setOnClickListener(this); button_stop.setOnClickListener(this); Button button_bind = findViewById(R.id.bind_service); Button button_unbind = findViewById(R.id.unbind_service); button_bind.setOnClickListener(this); button_unbind.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.start: Intent intent_start = new Intent(this, MyService.class); startService(intent_start); break; case R.id.stop: Intent intent_stop = new Intent(this, MyService.class); stopService(intent_stop); break; case R.id.bind_service: Intent intent_bind = new Intent(this, MyService.class); bindService(intent_bind, connection, BIND_AUTO_CREATE); // 绑定服务 break; case R.id.unbind_service: unbindService(connection); // 解绑服务 break; default: break; &#125; &#125;&#125; 分析 创建了ServiceConnected匿名类，重写了里面的onServiceConnected()和onServiceDisconnected()方法，这两个方法会在绑定成功和连接断开时调用 在onServiceConnected()将Service向下转型为自定义的DownloadBinder实例，然后用这个实例就能调用在DownloadBinder中的任何方法【必须先绑定】 bindService()可以将活动和服务绑定，第一个参数是Intent对象【和服务联系起来】,第二个参数是创建好的ServiceConnection实例【指定要绑定的服务】,第三个参数是一个标志位，传入BIND_AUTO_CREATE表示绑定后自动创建服务【onCreate()执行，onStartCommand()不执行【即创建而不启动】】 解绑unBindService()，参数就是绑定好的ServiceConnection实例 一个服务可以与不同的活动绑定，绑定后会获取到相同的实例 服务的声明周期 调用Context.startService()服务就会启动并回调onStartCommand()方法，若服务还未创建过，就会先执行onCreate() 服务启动后一直处于运行状态，直到Context.stopService()或stopSelf()被调用 每个服务都只会存在一个实例，不管调用多少次startService()，都只会存在一个实例，关闭只需一次 通过Context.bindService()获取服务的持久连接，就会回调服务的onBind()方法，onBind()返回一个IBinder对象实例，就能实现自由通信了 调用Context.stopService()服务就会被销毁并回调onDestroy()方法 类似的，被绑定的服务执行unbindService()也会被销毁，而且回调onDestroy() 如果一个服务既执行了startService()，也执行了bindService()，那么，销毁这个服务就必须都执行stopService()和unbindService()才能被销毁，onDestroy()才能被执行 前台服务 前台服务和普通服务最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果（像天气类app就要用到前台服务）。 前台服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收 Demo code 添加权限 1&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt; 代码 12345678910111213141516171819202122public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: 创建服务"); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "channelId") .setContentTitle("这是标题") .setContentText("这是内容") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi); // 大于Android 8.0的版本适配 if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; NotificationChannel notificationChannel = null; NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); notificationChannel = new NotificationChannel("channelId", "name", NotificationManager.IMPORTANCE_HIGH);// 注意此处channelId要和前面一样 notificationManager.createNotificationChannel(notificationChannel); &#125; startForeground(1, builder.build());&#125; 运行 使用IntentService 主线程处理耗时任务很容易出现ANR（Application Not Responding），所以推荐在每个服务的具体方法里开启子线程，即以下形式： 123456789101112131415public class MyService extends Service&#123;...... @Override public int onStartCommand(Intent intent, int flags, int startId)&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; //具体逻辑 // stopSelf(); //自动停止 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; &#125; 但是有时总是忘记开多线程或者自动停止。为了解决这个问题，Android提供了IntentService类解决这个问题。 Demo 新建一个MyIntentService类继承自IntentService: 123456789101112131415161718public class MyIntentService extends IntentService &#123; private static final String TAG = "MyIntentService"; public MyIntentService()&#123; super("MyIntentService"); // 调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; // 打印当前线程的id Log.d(TAG, "当前线程id是 "+Thread.currentThread().getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: 服务已销毁"); &#125;&#125; 注册活动 1&lt;service android:name=".MyIntentService"/&gt; 布局中添加一个按钮 123456&lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/intent_service" android:text="启动 IntentService"/&gt; 点击事件 12345678910111213141516171819202122@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);...... Button button_IntentService = findViewById(R.id.intent_service); button_IntentService.setOnClickListener(this);&#125;@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123;...... case R.id.intent_service: Log.d("MainActivity", "主线程id是 "+Thread.currentThread().getId()); Intent intentService = new Intent(this, MyIntentService.class); startService(intentService); break;...... &#125;&#125; 运行 可以看到MyIntentService这个服务是在子线程中运行的]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android GSON解析]]></title>
    <url>%2F2019%2F10%2F08%2F32-GSON%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[GSONGson 是谷歌官方推出的支持JSON--JavaObject相互转换的Java序列化/反序列化库 使用(解析一段JSON数据)使用的json数据1&#123;"name":"Tom","age":20&#125; 解析12Gson gson = new Gson();Person person = gson.from(jsonData,Person.class); 使用(解析一段JSON数组 )添加依赖1implementation 'com.google.code.gson:gson:2.8.6' 使用的json数据 建一个User类12345678910111213141516171819202122232425262728293031package com.ccc.networktest;public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 逻辑处理12345678910111213141516171819202122232425262728293031private void sendRequestWithOkhttp() &#123; //开启线程来发起网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://192.168.2.150:8080/test.json") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); //showResponse(responseData); parseJsonWithGSON(responseData); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void parseJsonWithGSON(String responseData) &#123; Gson gson = new Gson(); List&lt;User&gt; userList = gson.fromJson(responseData, new TypeToken&lt;List&lt;User&gt;&gt;() &#123;&#125;.getType()); for (User user : userList) &#123; Log.d("test", "---------------------------------"); Log.d("test", "id is " + user.getId()); Log.d("test", "username is " + user.getUsername()); Log.d("test", "password is " + user.getPassword()); &#125; &#125; 运行结果 可能遇到的错误由于这个json文件是我在本地放在Tomcat上的，用的是http 运行时会报错如下 1communication to 192.168.2.150 not permitted by network security policy 原因从Android P(9)开始，限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉，如果当前应用的请求是 http 请求，而非https ,这样就会导系统禁止当前应用进行该请求，如果 WebView 的 url 用 http 协议，同样会出现加载失败，https不受影响。为此，OkHttp3 做了检查，所以如果使用了明文流量，默认情况下，在 Android P 版本OkHttp3就抛出异常:CLEARTEXT communication to ” + host + ” not permitted by network security policy 解决在AndroidMainfest.xml中Application下添加一句android:usesCleartextTraffic=&quot;true&quot;即可解决]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络技术]]></title>
    <url>%2F2019%2F10%2F08%2F31-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[WebViewwebView应用内嵌浏览器 布局12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".Webview"&gt; &lt;WebView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/web"/&gt;&lt;/LinearLayout&gt; 活动1234567891011121314public class Webview extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); webView=findViewById(R.id.web); webView.getSettings().setJavaScriptEnabled(true); //支持JS脚本 webView.setWebViewClient(new WebViewClient()); //网页跳转时在本控件内进行，而不是打开系统浏览器 webView.loadUrl("https://bilibili.com"); //传入网址 &#125;&#125; 权限1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 使用Http协议访问网络HttpURLConnectionAndroid团队推荐使用HttpURLConnection发送HTTP请求，其步骤如下： 1.获取HttpURLConnection实例：new一个URL对象，调用openConnection()即可 2.用实例设置请求所使用的方法，GET或POST，调用setRequestMethod() 3.自由定制，设置连接超时setConnectTimeout()、读取的毫秒数setReadTimeout()、消息头等等 4.获取输入流，getInputStream() 5.最后关闭连接，disconnect() Demo 布局12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/send_request" android:text="发送请求"/&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/response_text"/&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; Demo 活动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Http extends AppCompatActivity implements View.OnClickListener &#123; private TextView textView; private Button sendRequest; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_http); sendRequest = findViewById(R.id.send_request); textView = findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_request: sendRequestWithHttpURLConnection(); break; &#125; &#125; private void sendRequestWithHttpURLConnection() &#123; //开启线程来发起网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; BufferedReader reader = null; try &#123; URL url = new URL("https://www.baidu.com"); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream in = connection.getInputStream(); //对获取到的输入流读取 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; Log.d("test", response.toString()); showResponse(response.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response) &#123; runOnUiThread(new Runnable() &#123; //切换到主线程 @Override public void run() &#123; textView.setText(response); &#125; &#125;); &#125;&#125; 权限1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 运行 使用Okhttp地址1https://square.github.io/okhttp/ 添加依赖12//okhttpimplementation "com.squareup.okhttp3:okhttp:4.3.1" 用法 Request用法： 创建OkHttpClient实例：new OkHttpClient() 创建Request对象：new Request.Builder().url(&quot;&quot;).build() 调用实例的newCall()创建Call对象，调用execute()发送请求获取数据：Response response = client.newCall(request).execute() 获取返回的内容：response.body().String() Post用法： 12345678910111213//先构造出一个RequestBody对象来存放待提交的参数RequestBody requestBody = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .build();//在Request.Build中调用post()方法，并将RequestBody对象传入Request request = new Request.Builder() .url("") .post(requestBody) .build()//接下来的操作和GET用法一样 项目Code在前面Http例子的基础上改一下这个方法: 123456789101112131415161718private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("https://baidu.com") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); showResponse(responseData); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 播放视频]]></title>
    <url>%2F2019%2F10%2F08%2F30-%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[思路播放视频一般使用VideoView类实现： setVideoPath：选择要播放的视频文件 start()：开始或继续播放视频 pause()：暂停播放 resume()：重头播放 seekTo()：跳转到指定时间 isPlaying()：判断当前播放状态 getDuration()：获取视频时长 Demo Code:主布局：1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;Button android:id="@+id/play" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="播放" /&gt; &lt;Button android:id="@+id/pause" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="暂停" /&gt; &lt;Button android:id="@+id/replay" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="重播" /&gt; &lt;/LinearLayout&gt; &lt;VideoView android:id="@+id/video_view" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 主活动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private VideoView videoView; private Button play; private Button pause; private Button replay; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); videoView = findViewById(R.id.video_view); play = findViewById(R.id.play); pause = findViewById(R.id.pause); replay = findViewById(R.id.replay); play.setOnClickListener(this); pause.setOnClickListener(this); replay.setOnClickListener(this); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1); &#125; else &#123; initVideoPath(); &#125; &#125; private void initVideoPath() &#123; File file = new File(Environment.getExternalStorageDirectory() + "/Download/", "qinshi.mp4"); Log.d("test", file.getPath()); videoView.setVideoPath(file.getPath()); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.play: if (!videoView.isPlaying()) &#123; videoView.start(); &#125; break; case R.id.pause: if (videoView.isPlaying()) &#123; videoView.pause(); &#125; break; case R.id.replay: videoView.resume(); break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; initVideoPath(); &#125; else &#123; Toast.makeText(this, "没有权限", Toast.LENGTH_SHORT).show(); finish(); &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (videoView != null) &#123; videoView.suspend(); &#125; &#125;&#125; 添加权限1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 播放音频]]></title>
    <url>%2F2019%2F10%2F08%2F29-%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%2F</url>
    <content type="text"><![CDATA[思路播放音频一般使用MediaPlayer类实现： setDataSource()：选择要播放的音频文件 prepare()：开始播放前调用这个完成准备工作 start()：开始或继续播放音频 pause()：暂停播放 setDataSource()：选择要播放的音频文件 prepare()：开始播放前调用这个完成准备工作 start()：开始或继续播放音频 pause()：暂停播放 isPlaying()：判断当前播放状态 getDuration()：获取音频时长 Demo Code:主布局12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/play" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="播放" /&gt; &lt;Button android:id="@+id/pause" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="暂停" /&gt; &lt;Button android:id="@+id/stop" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="停止" /&gt;&lt;/LinearLayout&gt; 主活动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MediaPlayer mediaPlayer; private Button play; private Button pause; private Button stop; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mediaPlayer = new MediaPlayer(); play = findViewById(R.id.play); pause = findViewById(R.id.pause); stop = findViewById(R.id.stop); play.setOnClickListener(this); pause.setOnClickListener(this); stop.setOnClickListener(this); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1); &#125; else &#123; initMediaPlayer(); &#125; &#125; //初始化播放器 private void initMediaPlayer() &#123; File file = new File(Environment.getExternalStorageDirectory() + "/Download/", "园游会.mp3"); try &#123; mediaPlayer.setDataSource(file.getPath()); mediaPlayer.prepare(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.play: if (!mediaPlayer.isPlaying()) &#123; //如果没有在播放 mediaPlayer.start(); &#125; break; case R.id.pause: if (mediaPlayer.isPlaying()) &#123; //如果正在播放 mediaPlayer.pause(); &#125; break; case R.id.stop: mediaPlayer.reset(); initMediaPlayer(); break; &#125; &#125; //申请权限回调函数 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; initMediaPlayer(); &#125; else &#123; Toast.makeText(this, "没有权限", Toast.LENGTH_SHORT).show(); finish(); &#125; break; &#125; &#125; //结束时 释放资源 @Override protected void onDestroy() &#123; super.onDestroy(); if (mediaPlayer != null) &#123; mediaPlayer.stop(); mediaPlayer.release(); &#125; &#125;&#125; 添加权限1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 了解Uri]]></title>
    <url>%2F2019%2F10%2F08%2F28-%E4%BA%86%E8%A7%A3Uri%2F</url>
    <content type="text"><![CDATA[URI 和 Uri ？ URI位置在java.net.URI,显然是Java提供的一个类。而Uri位置在android.net.Uri,是由Android提供的一个类 Uri是Android开发的，扩展了Java中URI的一些功能来特定的适用于Android开发，所以大家在开发时，只使用Android 提供的Uri即可 Uri 结构1.基本形式1[scheme:]scheme-specific-part[#fragment] 这里分为三部分：scheme、scheme-specific-part、fragment 2.进一步划分是这样子1[scheme:][//authority][path][?query][#fragment] 3.规则 path可以有多个，每个用/连接，比如 1scheme://authority/path1/path2/path3?query#fragment query参数可以带有对应的值，也可以不带，如果带对应的值用=表示，如: 1scheme://authority/path1/path2/path3?id = 1#fragment，这里有一个参数id，它的值是1 query参数可以有多个，每个用&amp;连接 12345scheme://authority/path1/path2/path3?id = 1&amp;name = mingming&amp;old#fragment这里有三个参数：参数1：id，其值是:1参数2：name，其值是:mingming参数3：old，没有对它赋值，所以它的值是null 在android中，除了scheme、authority是必须要有的，其它的几个path、query、fragment，它们每一个可以选择性的要或不要，但顺序不能变 4.终极划分 其中authority,又可以分为host:port的形式，即再次划分后是这样的： 1[scheme:][//host:port][path][?query][#fragment] 5.示例1http://www.java2s.com:8080/yourpath/fileName.htm?stove=10&amp;path=32&amp;id=4#harvic scheme:匹对上面的两个Uri标准形式，很容易看出在：前的部分是scheme，所以这个Uri字符串的sheme是：http scheme-specific-part:很容易看出scheme-specific-part是包含在scheme和fragment之间的部分，也就是包括第二部分的[//authority][path][?query]这几个小部分，所在这个Uri字符串的scheme-specific-part是：//www.java2s.com:8080/yourpath/fileName.htm?stove=10&amp;path=32&amp;id=4 ，注意要带上//，因为除了[scheme:]和[#fragment]部分全部都是scheme-specific-part，当然包括最前面的//； fragment:这个是更容易看出的，因为在最后用#分隔的部分就是fragment，所以这个Uri的fragment是：harvic下面就是对scheme-specific-part进行拆分了；在scheme-specific-part中，最前端的部分就是authority，？后面的部分是query，中间的部分就是path authority：很容易看出scheme-specific-part最新端的部分是：www.java2s.com:8080 query:在scheme-specific-part中，？后的部分为：stove=10&amp;path=32&amp;id=4 path:在query:在scheme-specific-part中，除了authority和query其余都是path的部分:/yourpath/fileName.htm又由于authority又一步可以划分为host:port形式，其中host:port用冒号分隔，冒号前的是host，冒号后的是port，所以： host:www.java2s.com port:8080 代码提取（方法）1http://www.java2s.com:8080/yourpath/fileName.htm?stove=10&amp;path=32&amp;id=4#harvic getScheme() :获取Uri中的scheme字符串部分，在这里即，http getSchemeSpecificPart():获取Uri中的scheme-specific-part:部分，这里是：//www.java2s.com:8080/yourpath/fileName.htm? getFragment():获取Uri中的Fragment部分，即harvic getAuthority():获取Uri中Authority部分，即www.java2s.com:8080 getPath():获取Uri中path部分，即/yourpath/fileName.htm getQuery():获取Uri中的query部分，即stove=10&amp;path=32&amp;id=4 getHost():获取Authority中的Host字符串，即www.java2s.com getPost():获取Authority中的Port字符串，即8080 另外还有两个常用的：getPathSegments()、getQueryParameter(String key) List&lt; String&gt; getPathSegments():上面我们的getPath()是把path部分整个获取下来：/yourpath/fileName.htm，getPathSegments()的作用就是依次提取出Path的各个部分的字符串，以字符串数组的形式输出。 getQueryParameter(String key):在上面我们通过getQuery()获取整个query字段：stove=10&amp;path=32&amp;id=4，getQueryParameter(String key)作用就是通过传进去path中某个Key的字符串，返回他对应的值。在path中，即使针对某一个KEY不对它赋值是允许的，但在利用getQueryParameter()获取该KEY对应的值时，获取到的是null; 扩展绝对Uri和相对Uri 绝对URI：以scheme组件起始的完整格式，如http://fsjohnhuang.cnblogs.com。表示以对标识出现的环境无依赖的方式引用资源。 相对URI：不以scheme组件起始的非完整格式，如fsjohnhuang.cnblogs.com。表示以对依赖标识出现的环境有依赖的方式引用资源。 不透明URI和分层URI 不透明URI：scheme-specific-part组件不是以正斜杠(/)起始的，如mailto:fsjohnhuang@xxx.com。由于不透明URI无需进行分解操作，因此不会对scheme-specific-part组件进行有效性验证 分层URI：scheme-specific-part组件是以正斜杠(/)起始的，如http://fsjohnhuang.com schema常见类型 HTTP(&quot;http&quot;) HTTPS(&quot;https&quot;) FILE(&quot;file&quot;) CONTENT(&quot;content&quot;) ASSETS(&quot;assets&quot;) DRAWABLE(&quot;drawable&quot;) UNKNOWN(&quot;&quot;)]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 相册选择图片]]></title>
    <url>%2F2019%2F10%2F08%2F27-%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[如何实现从相册中选取图片 1.运行时权限处理，申请WRITE_EXTERNAL_STORAGE这个危险权限，需要读写SD卡的能力 2.申请成功则继续构建Intent对象，指定action：android.intent.action.GET_CONTENT。用setType()设置返回类型为图片 3.调用startActivityForResult()隐式启动intent 4.回调onActivityResult()判断图片是否成功返回，如果成功，对4.4以上系统采用handleImageOnKitkat()，对4.4以下系统采用handleImageBeforeKitkat() 5.handleImageOnKitkat(): 返回的uri 如果是document类型，取出document id处理获取路径图片 如果Uri的authority是media格式的话，document id 还要再一步处理才能获取路径图片 不是的话则普通方式处理，直接获得路径图片 本项目在 26节调用摄像头项目的基础上修改修改布局 增加选照片按钮123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/take_photo&quot; android:text=&quot;拍照&quot;/&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/choose_photo&quot; android:text=&quot;选照片&quot;/&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/picture&quot; android:layout_gravity=&quot;center_horizontal&quot;/&gt;&lt;/LinearLayout&gt; 活动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private ImageView imageView; private Button takePhoto; private Button choosePhoto; private Uri imageUri; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.picture); takePhoto = findViewById(R.id.take_photo); choosePhoto = findViewById(R.id.choose_photo); takePhoto.setOnClickListener(this); choosePhoto.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.take_photo: File outputImage = new File(getExternalCacheDir(), "output_image.jpg"); if (outputImage.exists()) &#123; outputImage.delete(); &#125; try &#123; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (Build.VERSION.SDK_INT &gt;= 24) &#123; imageUri = FileProvider.getUriForFile(MainActivity.this, getPackageName() + ".fileprovider", outputImage); &#125; else &#123; imageUri = Uri.fromFile(outputImage); &#125; Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, TAKE_PHOTO); break; case R.id.choose_photo: if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1); &#125; else &#123; openAlbum(); //打开相册 &#125; break; &#125; &#125; private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); Log.d("test", "选择照片"); startActivityForResult(intent, CHOOSE_PHOTO); &#125; //申请权限回调函数 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openAlbum(); &#125; else &#123; Toast.makeText(MainActivity.this, "申请权限被拒绝", Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; //活动跳转回调函数 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case TAKE_PHOTO: //拍照 if (resultCode == RESULT_OK) &#123; try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); imageView.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; Toast.makeText(MainActivity.this, "取消拍照", Toast.LENGTH_SHORT).show(); &#125; break; case CHOOSE_PHOTO: //选照片 if (resultCode == RESULT_OK) &#123; if (Build.VERSION.SDK_INT &gt;= 19) &#123; handleImageOnKitkat(data); &#125; else &#123; handleImageBeforeKitkat(data); &#125; &#125; else &#123; Toast.makeText(this, "未选择图片", Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; //android4.4以下使用 private void handleImageBeforeKitkat(Intent data) &#123; Uri uri = data.getData(); String imagePath = getImagePath(uri, null); Log.d("test", "before" + imagePath); displayImage(imagePath); &#125; private String getImagePath(Uri externalContentUri, String selection) &#123; String path = null; Cursor cursor = getContentResolver().query(externalContentUri, null, selection, null, null); if (cursor != null) &#123; if (cursor.moveToFirst()) &#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; //Android4.4以上使用 @RequiresApi(api = Build.VERSION_CODES.KITKAT) private void handleImageOnKitkat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); if (DocumentsContract.isDocumentUri(MainActivity.this, uri)) &#123; String docId = DocumentsContract.getDocumentId(uri); if ("com.android.providers.media.documents".equals(uri.getAuthority())) &#123; String id = docId.split(":")[1]; String selection = MediaStore.Images.Media._ID + "=" + id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection); &#125; else if ("com.android.providers.downloads.documents".equals(uri.getAuthority())) &#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(docId)); imagePath = getImagePath(contentUri, null); &#125; &#125; else if ("content".equalsIgnoreCase(uri.getScheme())) &#123; imagePath = getImagePath(uri, null); &#125; else if ("file".equalsIgnoreCase(uri.getScheme())) &#123; imagePath = uri.getPath(); &#125; Log.d("test", imagePath); displayImage(imagePath); &#125; private void displayImage(String imagePath) &#123; if (imagePath != null) &#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); imageView.setImageBitmap(bitmap); &#125; else &#123; Toast.makeText(this, "图片加载错误！", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 调用摄像头]]></title>
    <url>%2F2019%2F10%2F08%2F26-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[使用摄像头拍摄Demo 如何实现调用摄像头 1.创建一个File对象，存放摄像头拍下的图片 2.调用getExternalCacheDir()获取缓存目录，存放图片 3.接下来解决版本适配问题，如果Android版本低于7.0，直接用Uri.fromFile将图片转化为Uri对象；否则调用FileProvider的getUriForFile()转化为封装后的Uri对象【用内容提供器】，参数一：context，参数二：任意的唯一字符串，参数三：File对象 构建Intent对象，将其action指定为android.media.action.IMAGE_CAPTURE。用putExtra()指定图片输出地址为Uri对象 最后调用startActivityForResult()隐式启动intent，这样返回的图片会输出为图片文件 onActivityResult()判断图片是否成功返回，如果成功，调用BitmapFactory.decodeStream()将图片解析为Bitmap对象，再显示出来 布局12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/take_photo" android:text="拍照"/&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/picture" android:layout_gravity="center_horizontal"/&gt;&lt;/LinearLayout&gt; 对应活动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private ImageView imageView; private Button takePhoto; private Uri imageUri; public static final int TAKE_PHOTO = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.picture); takePhoto = findViewById(R.id.take_photo); takePhoto.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.take_photo: File outputImage = new File(getExternalCacheDir(), "output_image.jpg"); if (outputImage.exists()) &#123; outputImage.delete(); &#125; try &#123; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (Build.VERSION.SDK_INT &gt;= 24) &#123; imageUri = FileProvider.getUriForFile(MainActivity.this, getPackageName() + ".fileprovider", outputImage); //这里第二个参数就是下面的anthorities &#125; else &#123; imageUri = Uri.fromFile(outputImage); &#125; Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, TAKE_PHOTO); break; &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case TAKE_PHOTO: if (resultCode == RESULT_OK) &#123; try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); imageView.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; Toast.makeText(MainActivity.this, "取消拍照", Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125;&#125; 将上面用到的内容提供器添加注册android:name属性值固定，android:authorities和第二个参数一致，指定Uri的共享路径，并引用了一个@xml/filepaths资源 authorities：一个标识，在当前系统内必须是唯一值，一般用包名。 exported：表示该 FileProvider是否需要公开出去。 granUriPermissions：是否允许授权文件的临时访问权限。这里需要，所以是 true。 123456789&lt;provider android:name="androidx.core.content.FileProvider" android:authorities="com.ccc.cameraalbumtest.fileprovider" &lt;!-- 和前面保持一致--&gt; android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;!--该文件下一步创建--&gt; &lt;/provider&gt; 创建上一步需要的文件在res目录新建一个xml目录，下面新建file_path.xml文件，然后修改其中内容，name随便填，path表示要共享的目录： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="." /&gt;&lt;/paths&gt; 适配旧版本为了适配Android 4.4之前的手机，还要声明访问SD卡的权限： 1&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 运行]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 通知]]></title>
    <url>%2F2019%2F10%2F08%2F25-%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[通知(Notification)通知是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏可以看到通知的详细内容。 基本用法 1.用Context.getSystemService(Context.NOTIFICATION_SERVICE)获取到NotificationManager对通知管理 1NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE) 2.大于android8.0版本的适配问题 1234567891011 // 大于Android 8.0的版本适配if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; NotificationChannel notificationChannel = null; //注意，这里创建了渠道，三个参数分别为 渠道ID、渠道名称和重要等级，这里的渠道ID就是我们下面 //创建builder对象时要对应一致的ID。 notificationChannel = new NotificationChannel("unique", "TEST", NotificationManager.IMPORTANCE_HIGH); notificationChannel.enableLights(true); //LED灯 notificationChannel.setLightColor(Color.YELLOW); manager.createNotificationChannel(notificationChannel); &#125; 3.用Builder构造器创建Notification对象，channelId用来表示消息通道的ID，需要和上面创建的渠道ID相同，如果传入了一个不存在的渠道ID，通知是无法显示出来的。 1NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "unique"); 4.基本设置 123456789builder.setContentTitle("这是标题") .setAutoCancel(true) .setContentText("这是文本") .setContentInfo("这是内容") .setSubText("这是小字") .setTicker("滚动消息......") .setWhen(System.currentTimeMillis()) // 出现时间 .setSmallIcon(R.mipmap.ic_launcher) //小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); // 大图标 5.显示通知，第一个参数是自定义id(要保证每个通知的id都不同)，第二个参数是notification对象 12Notification notification = builder.build();manager.notify(1, notification); 通知的响应 通知的相应依赖于PendingIntent, 在某个合适的时机去执行某个动作（Intent更倾向于立刻执行某个动作） PendingIntent提供了几个静态方法用于获取PendingIntent的实例，可以根据需求来选择是使用getActivity()方法、getBroadcast()方法还是getService()方法 1PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); PendingIntent的4个参数： 第一个参数：Context 第二个参数：一般用不到，传入0即可 第三个参数： Intent对象 第四个参数：用于确定PendingIntent的行为，有FLAG_ONE_SHOT，FLAG_NO_CREATE，FLAG_CANCEL_CURRENT，FLAG_UPDATE_CURRENT 4个值可以选。但通常写0 因此前面的NotificationCompat.Builder对象还有个方法：setContentIntent()方法，接收的参数正是一个PendingIntent对象 简单Demo activity_main.xml： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/send_notice" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="发起通知"/&gt;&lt;/LinearLayout&gt; MainActivity.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button button_sendNotice; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button_sendNotice=findViewById(R.id.send_notice); button_sendNotice.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notice: Intent intent = new Intent(this,NotificationActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); NotificationCompat.Builder builder = new NotificationCompat.Builder(this,"unique"); builder.setContentTitle("这是标题") .setAutoCancel(true) .setContentText("这是文本") .setContentInfo("这是内容") .setSubText("这是小字") .setTicker("滚动消息......") .setWhen(System.currentTimeMillis()) //出现时间 .setSmallIcon(R.mipmap.ic_launcher) //小图标 .setContentIntent(pi) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//大图标 // 大于Android 8.0的版本适配 if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; NotificationChannel notificationChannel = null; notificationChannel = new NotificationChannel("unique", "TEST", NotificationManager.IMPORTANCE_HIGH); notificationChannel.enableLights(true); //LED灯 notificationChannel.setLightColor(Color.YELLOW); manager.createNotificationChannel(notificationChannel); &#125; Notification notification = builder.build(); manager.notify(1,notification); break; &#125; &#125;&#125; activity_notification.xml: 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".NotificationActivity"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="这是一个通知页面"/&gt;&lt;/LinearLayout&gt; NotificationActivity.java 12345678public class NotificationActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification); &#125;&#125; 运行结果： 让通知消失的两种方法 1.在NotificationCompat.Builder中连缀一个setAutoCancel(true)方法，通知被点击后就会自动清除 1NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "001").setAutoCancel(true); 显式调用NotificationManger的cancel()将它取消,cancel()接收一个参数是通知的id 12NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);manager.cancel(1); //这个1是我们前面介绍通知时设的id 通知的进阶技巧设置通知的音效：1builder.setSound(Uri.fromFile(new File("铃声路径"))); 设置震动：（数组下标为偶数表示振动的毫秒数，奇数表示接着静止的毫秒数） 需先添加权限： 1&lt;uses-permission android:name="android.permission.VIBRATE"/&gt; 123builder.setVibrate(new long[]&#123;0, 1000, 1000, 1000&#125;);// 8.0 以上:channel.setVibrationPattern(new long[]&#123;0&#125;);//通道来控制震动 显式长文字1234567builder.setStyle(new NotificationCompat.BigTextStyle().bigText("唧唧复唧唧，木兰当户织。不闻机杼声，惟闻女叹息。\n" + "问女何所思，问女何所忆。女亦无所思，女亦无所忆。昨夜见军帖，可汗大点兵，军书十二卷，卷卷有爷名。阿爷无大儿，木兰无长兄，愿为市鞍马，从此替爷征。\n" + "东市买骏马，西市买鞍鞯，南市买辔头，北市买长鞭。旦辞爷娘去，暮宿黄河边，不闻爷娘唤女声，但闻黄河流水鸣溅溅。旦辞黄河去，暮至黑山头，不闻爷娘唤女声，但闻燕山胡骑鸣啾啾。\n" + "万里赴戎机，关山度若飞。朔气传金柝，寒光照铁衣。将军百战死，壮士十年归。\n" + "归来见天子，天子坐明堂。策勋十二转，赏赐百千强。可汗问所欲，木兰不用尚书郎，愿驰千里足，送儿还故乡。\n" + "爷娘闻女来，出郭相扶将；阿姊闻妹来，当户理红妆；小弟闻姊来，磨刀霍霍向猪羊。开我东阁门，坐我西阁床，脱我战时袍，著我旧时裳。当窗理云鬓，对镜帖花黄。出门看火伴，火伴皆惊忙：同行十二年，不知木兰是女郎。\n" + "雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？")) 显示图片1builder.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.cat))) 设置重要程度：1builder.setPriority(NotificationCompat.PRIORITY_MAX)]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 跨应用共享数据Demo]]></title>
    <url>%2F2019%2F10%2F08%2F24-%E8%B7%A8%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AEDemo%2F</url>
    <content type="text"><![CDATA[说明一下本项目有个问题需要说明一下，就是provider的onCreate()方法会先于Activity的onCreate()方法执行，所以DatabaseTest项目一运行，就会先执行provider的onCreate()方法，创建数据库 前提本项目在前面DatabaseTest项目的基础上进行更改，首先将MyDatabaseHelper中使用Toast弹出数据库创建成功的提示去掉，因为跨程序访问时我们不能直接使用Toast。然后创建一个内容提供器，在包上单机右键 New-&gt;Other-&gt;Content Provider 这样就能自动导入相关的&lt;provider&gt;进行注册 12345&lt;provider android:authorities="com.example.databasetest.provider" android:name=".DatabaseProvider" android:enabled="true" android:exported="true"/&gt; DatabaseProvider 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATAGORY_DIR = 2; public static final int CATAGORY_ITEM = 3; public static final String AUTHORITY = "com.example.databasetest.provider"; public static UriMatcher uriMatcher; private MyDatabaseHelper dbhelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, "book", BOOK_DIR); uriMatcher.addURI(AUTHORITY, "book/#", BOOK_ITEM); uriMatcher.addURI(AUTHORITY, "catagory", CATAGORY_DIR); uriMatcher.addURI(AUTHORITY, "catagory/#", CATAGORY_ITEM); &#125; public DatabaseProvider() &#123; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbhelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: deletedRows = db.delete("Book", selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete("Book", "id = ?", new String[]&#123;bookId&#125;); break; case CATAGORY_DIR: deletedRows = db.delete("Category", selection, selectionArgs); break; case CATAGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete("Category", "id = ?", new String[]&#123;categoryId&#125;); break; default: break; &#125; return deletedRows; &#125; @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: return "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book"; case BOOK_ITEM: return "vnd.android.cursor.item/vnd.com.example.databasetest.provider.book"; case CATAGORY_DIR: return "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category"; case CATAGORY_ITEM: return "vnd.android.cursor.item/vnd.com.example.databasetest.provider.categoty"; &#125; return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbhelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert("Book", null, values); uriReturn = Uri.parse("content://" + AUTHORITY + "/book/" + newBookId); break; case CATAGORY_DIR: case CATAGORY_ITEM: long newCategoryId = db.insert("Category", null, values); uriReturn = Uri.parse("content://" + AUTHORITY + "/book/" + newCategoryId); break; default: break; &#125; return uriReturn; &#125; //应用一运行 provider注册 会先执行该方法 来创建数据库 @Override public boolean onCreate() &#123; dbhelper = new MyDatabaseHelper(getContext(), "BookStore.db", null, 2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; SQLiteDatabase db = dbhelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query("Book", projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query("Book", projection, "id = ?", new String[]&#123;bookId&#125;, null, null, sortOrder); break; case CATAGORY_DIR: cursor = db.query("Category", projection, selection, selectionArgs, null, null, sortOrder); break; case CATAGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query("Category", projection, "id = ?", new String[]&#123;categoryId&#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; SQLiteDatabase db = dbhelper.getWritableDatabase(); int updateRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: updateRows = db.update("Book", values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updateRows = db.update("Book", values, "id = ?", new String[]&#123;bookId&#125;); break; case CATAGORY_DIR: updateRows = db.update("Category", values, selection, selectionArgs); break; case CATAGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updateRows = db.update("Categoty", values, "id = ?", new String[]&#123;categoryId&#125;); break; default: break; &#125; return updateRows; &#125;&#125; 几个注意点 onCreate()中借用MyDataBaseHelper完成数据库的创建或升级，并且provider的onCreate()方法会先于Activity的onCreate()方法执行 query()返回cursor insert()返回能够表示这条新增数据的URI update()和delete()返回受影响的行数 getPathSegments()会将内容URI权限之后的部分用/分割，并把结果放到字符串列表当中，其第0个位置放的是路径，第1个位置就是id了。 跨应用访问数据接着在模拟器卸载重装当前应用，再创建一个新项目：ProviderTest 1.布局12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="向 Book 表添加数据" android:id="@+id/insert"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="查询 Book 表中的数据" android:id="@+id/query"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/update" android:text="修改 Book 表中的数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/delete" android:text="删除 Book 表中的数据"/&gt;&lt;/LinearLayout&gt; 2.主活动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; private String newId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button_insert = findViewById(R.id.insert); button_insert.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri = Uri.parse("content://com.example.databasetest.provider/book"); ContentValues values = new ContentValues(); values.put("name","老人与海"); values.put("author", "海明威"); values.put("pages",345); values.put("price",10.88); Uri newUri = getContentResolver().insert(uri, values); newId = newUri.getPathSegments().get(1); &#125; &#125;); Button button_delete = findViewById(R.id.delete); button_delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri = Uri.parse("content://com.example.databasetest.provider/book/"+newId); getContentResolver().delete(uri, null, null); &#125; &#125;); Button button_update = findViewById(R.id.update); button_update.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri = Uri.parse("content://com.example.databasetest.provider/book/"+newId); ContentValues values = new ContentValues(); values.put("name", "绿野仙踪"); values.put("pages", 666); values.put("price", 88.88); getContentResolver().update(uri, values, null, null); &#125; &#125;); Button button_query = findViewById(R.id.query); button_query.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri = Uri.parse("content://com.example.databasetest.provider/book"); Cursor cursor = getContentResolver().query(uri, null, null, null,null); if(cursor != null)&#123; while (cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d(TAG, "书名："+name); Log.d(TAG, "作者："+author); Log.d(TAG, "页数："+pages); Log.d(TAG, "价格："+price); &#125; &#125; &#125; &#125;); &#125;&#125; 运行：]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义内容提供器]]></title>
    <url>%2F2019%2F10%2F08%2F23-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[创建内容提供器 1.继承ContentProvider类 自定义内容提供器可以通过新建一个类去继承ContentProvider来创建自己的内容提供器，该类一共有6个抽象方法，需要我们来重写。 1234567891011121314151617181920212223242526272829303132333435363738public class MyProvider extends ContentProvider &#123; // 初始化内容提供器的时候调用，通常在这里完成数据库创建和升级，返回true代表成功 @Override public boolean onCreate() &#123; return false; &#125; // uri:表名 projection:列名 selection(args):约束查询哪些行 sortOrder:排序 查询的结果在Cursor中返回 @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; return null; &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123; return null; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123; return 0; &#125; // 根据传入的uri返回相应的MIME【后面解释】 @Nullable @Override public String getType(@NonNull Uri uri) &#123; return null; &#125;&#125; 2.URI 参数解析 内容URI的格式主要有两种 1.以路径结尾 content://com.example.app.provider/table1，表示期望访问该表中的所有的数据 2.以id结尾content://com.example.app.provider/table1/1`，表示期望访问该表中拥有相应id的数据 我们可以用通配符的方式来分别匹配这两种格式的内容URI,规则如下： *：表示匹配任意长度的任意字符 #：表示匹配任意长度的数字 举例： 一个能够匹配任意表的内容URI格式可以写成：content://com.example.app.provider/* 一个能够匹配table表中任意一行数据的内容URI格式就可以写成：content://com.example.app.provider/table/# 借助UriMatcher类实现匹配内容URI的功能 UriMatcher类提供了一个addURI()方法，该方法接收3个参数，authority、path和自定义代码 当调用UriMatcher的match()方法时，将一个Uri对象传入，返回值就是某个能够匹配这个Uri对象所对应的自定义代码,利用这个代码，就可以判断出调用方期望访问的是哪张表中的数据了。 query() 示例： 12345678910111213141516171819202122232425262728293031323334353637public class MyProvider extends ContentProvider &#123; //创建4个常量，代表调用方期望访问的不同内容 public static final int TABLE1_DIR = 0; //期望访问table1所有数据 public static final int TABLE1_ITEM = 1; //期望访问table1某一条数据 public static final int TABLE2_DIR = 2; //期望访问table2所有数据 public static final int TABLE2_ITEM = 3; //期望访问table2某一条数据 private static UriMatcher uriMatcher; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); //创建UriMatcher实例 uriMatcher.addURI("com.example.app.provider", "tabke1", TABLE1_DIR); uriMatcher.addURI("com.example.app.provider", "tabke1/#", TABLE1_ITEM); uriMatcher.addURI("com.example.app.provider", "tabke2", TABLE2_DIR); uriMatcher.addURI("com.example.app.provider", "tabke2/#", TABLE2_ITEM); &#125; // uri:表名 projection:列名 selection(args):约束 sortOrder:排序 查询的结果在Cursor中返回 @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; switch (uriMatcher.match(uri)) &#123; case TABLE1_DIR: // 查询表一所有数据 break; case TABLE1_ITEM: // 查询表一单条数据 break; case TABLE2_DIR: break; case TABLE2_ITEM: break; default: &#125; return null; &#125;&#125; getType()方法 getType()方法，是所有内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型 MIME由三部分组成： 必须以vnd开头 如果URI以路径结尾，则在vnd后接android.cursor.dir/ ；如果URI以ID结尾，则后接android.cursor.item/ 最后接上 vnd.&lt;authority&gt;.&lt;path&gt; 例如： 123content://com.example.app.provider/table1则为：vnd.android.cursor.dir/vnd.com.example.app.provider/table1 所以getType(): 123456789101112131415public String getType(@NonNull Uri uri) &#123; switch (uriMatcher.match(uri)) &#123; case TABLE1_DIR: return "vnd.android.cursor.dir/vnd.com.example.app.provider.table1"; case TABLE1_ITEM: return "vnd.android.cursor.item/vnd.com.example.app.provider.table1"; case TABLE2_DIR: return "vnd.android.cursor.dir/vnd.com.example.app.provider.table2"; case TABLE2_ITEM: return "vnd.android.cursor.item/vnd.com.example.app.provider.table2"; default: break; &#125; return null;&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内容提供器]]></title>
    <url>%2F2019%2F10%2F08%2F22-%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内容提供器内容提供器(Content Provider)是Android跨程序共享数据的标准方式，内容提供器可以选择对哪一部分数据共享，从而不会有泄露的风险。 用法内容提供器的用法一般有两种： 一种是使用现有的内容提供其读取操作相应应用程序的数据【比如系统电话簿，短信等】 另一种是创建自己的内容提供器提供外部访问接口 对每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。 ContentResolver中提供了一系列的方法用于对数据进行CURD操作： insert()方法用于添加数据 update()方法用于更新数据 delete()方法用于删除数据 query()方法用于查询数据 内容URI: 内容URI 给内容提供器中的数据建立了唯一标识符，如context://com.example.app.provider/table1 ContentResolver的增删改查方法都接收一个内容URI作为第一个参数 Uri URI，每一个Content Provider 都对外提供一个 能够唯一标识自己 数据集(data set)的公开URI, 如果一个Content Provider管理多个数据集，其将会为每个数据集分配一个独立的URI。所有的Content Provider的URI 都以&quot;content://&quot; 开头，其中&quot;content:&quot;是用来标识数据是由Content Provider管理的 schema 基本用法1、查例如，查询table表的数据： 123456789101112131415Uri uri = Uri.parse("content://包名.provider/table")Cursor cursor = getContentResolver().query( uri, 列名, where 约束条件, 占位参数, 排序方式)if(cursor != null)&#123; while (cursor.moveToNext())&#123; String 列1 = cursor.getString(cursor.getColumnIndex(列名1)); int 列2 = cursor.getInt(cursor.getColumnIndex(列名2)); &#125; cursor.close();&#125; 2.增1234ContentValues values = new ContentValues();values.put(列名1, 值1);values.put(列名2, 值2);getContentResolver().insert(uri, values); 3.其他的都类似于前面的数据库操作Demo code下面实现一个读取手机联系人的demo： 在manifest中添加读取联系人权限 1&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 布局（简单的一个listview） 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ListView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/contacts_view"/&gt;&lt;/LinearLayout&gt; 主活动（这里query()的内容URI对象已经被解析出来了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactList = new ArrayList&lt;&gt;(); @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; readContacts(); &#125; else &#123; Toast.makeText(this, "权限被拒绝，无法显示通讯录", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView listView_contacts = findViewById(R.id.contacts_view); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, contactList); listView_contacts.setAdapter(adapter); //先申请读取系统联系人的权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, 1); &#125;else&#123; readContacts(); &#125; &#125; private void readContacts() &#123; Cursor cursor = null; try&#123; // 查询联系人数据 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if(cursor != null)&#123; while (cursor.moveToNext())&#123; // 获取联系人姓名 String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); // 获取手机号 String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contactList.add(displayName+"\n"+number); &#125; // 刷新并显示 adapter.notifyDataSetChanged(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if (cursor != null)&#123; cursor.close(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 权限机制]]></title>
    <url>%2F2019%2F10%2F08%2F21-%E6%9D%83%E9%99%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[权限机制Android的权限分为两类： 普通权限：不会威胁到安全和隐私的权限，系统会自动授权，普通权限需要在AndroidManifest.xml中声明即可 危险权限：触及用户隐私或设备安全性的权限，这部分权限必须用户手动点击授权，危险权限一般涉及地理位置，联系人信息，日程，短信，存储等。危险权限在使用时需要运行时权限处理 运行时申请权限步骤如下： 一、判断用户是否已经给予权限 ContextCompat.checkSelfPermission() 两个参数： 参数一：Context 参数二：权限名，比如拨打电话的权限名 Manifest.permission.CALL_PHONE 将返回值和 PackageManger.PERMISSION_GRANTED 比较，相等则授权成功 二、若授权成功，则继续执行逻辑，若授权失败，需要申请授权 ActivityCompat.requestPermissions() 三个参数： 参数一：Activity实例 参数二：String数组，把要申请的权限名写入数组 参数三：请求码，是个唯一值即可，与后面的onRequestPermissionsResult()回调方法一致 三、申请授权后会回调到onRequestPermissionsResult()方法，授权的结果封装在grantResults参数里。Demo code:下面实现一个demo，申请打电话的权限 CALL_PHONE,点击拨打电话按钮，弹出申请权限。 12345678910111213141516171819202122232425262728293031323334353637383940414243 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button_makecall = findViewById(R.id.make_call); button_makecall.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //进行判断，若没有权限则先申请 否则直接拨打电话 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 1); &#125;else &#123; call(); &#125; &#125; &#125;); &#125; //回调方法 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; call(); &#125;else&#123; Toast.makeText(this, "申请权限被拒绝", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; private void call() &#123; try&#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch (SecurityException e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据存储（四）]]></title>
    <url>%2F2019%2F10%2F08%2F20-Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8(%E5%9B%9B)%20%2F</url>
    <content type="text"><![CDATA[LitePal操作SQLiteLitePal 是一款开源Android数据库框架，它采用了ORM的模式，将平时用到的一些数据库功能进行了封装 【项目地址】:https://github.com/LitePalFramework/LitePal 1.配置LitePal引入依赖库 1implementation 'org.litepal.android:java:3.0.0' 在app/src/main目录下新建一个文件夹assets，在该目录下建一个litepal.xml文件： 数据库名 版本号 指定映射模型 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" /&gt; &lt;version value="1" /&gt; &lt;list&gt;&lt;/list&gt;&lt;/litepal&gt; 最后给AndroidManifest.xml文件加一行： 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.day12_litepaltest"&gt; &lt;application android:name="org.litepal.LitePalApplication" ...... &gt; &lt;/application&gt;&lt;/manifest&gt; 2.创建和升级数据库布局还是承接上一遍文章的布局，包括创建和增删改查5个按钮 1.准备12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="创建数据库" android:id="@+id/create_database"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="增" android:id="@+id/insert"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="改" android:id="@+id/update"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="删" android:id="@+id/delete"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="查" android:id="@+id/query"/&gt;&lt;/LinearLayout&gt; 2.对象关系映射ORM在LitePal中，一个表对应一个类，表的每一列对应类中的一个字段 定义一个Book类，快速生成其Getter 和 Setter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Book &#123; private int id; private String author; private double price; private int pages; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 将Book类添加带映射模型表中，修改litepal.xml: 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class = "com.example.day12_litepaltest.Book"/&gt; &lt;!--在此添加映射--&gt; &lt;/list&gt;&lt;/litepal&gt; 3.创建数据库LitePal.getDatabase()：只需要这一句就够了 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button_create = findViewById(R.id.create_database); button_create.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); //创建数据库 &#125; &#125;); &#125;&#125; 运行adb程序，查看 \20-1.png) 4.升级数据库现在我们想要做如下操作： 要在Book表中增加一列press： 123456789101112public class Book &#123;...... private String press; public String getPress() &#123; return press; &#125; public void setPress(String press) &#123; this.press = press; &#125;&#125; 建立一张新表category 12345678910111213141516171819202122232425public class Category &#123; private int id; private String category; private int categoryCode; public void setId(int id) &#123; this.id = id; &#125; public String getCategory() &#123; return category; &#125; public void setCategory(String category) &#123; this.category = category; &#125; public int getCategoryCode() &#123; return categoryCode; &#125; public void setCategoryCode(int categoryCode) &#123; this.categoryCode = categoryCode; &#125;&#125; 修改映射关系，版本号必须+1： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" /&gt; &lt;version value="2" /&gt; &lt;list&gt; &lt;mapping class = "com.example.day12_litepaltest.Book"/&gt; &lt;mapping class = "com.example.day12_litepaltest.Category"/&gt; &lt;!--添加新的category的行摄关系--&gt; &lt;/list&gt;&lt;/litepal&gt; 再次运行adb程序查看： \20-2.png) 增首先需要让表类继承自LitePalSupport： 123public class Book extends LitePalSupport &#123;......&#125; 然后用实例.save()即可 12345678910111213Button button_insert = findViewById(R.id.insert);button_insert.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); //创建Book类对象 book.setName("老人与海"); book.setAuthor("海明威"); book.setPages(456); book.setPress("呼吸出版社"); book.setPrice(18.88); book.save(); //保存到表内 &#125;&#125;); 改实例.updateAll(语句条件，占位值...) 改为默认值：实例.setToDefault(列名) 12345678910Button button_update = findViewById(R.id.update);button_update.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); book.setPrice(12.00); book.setPress("大头出版社"); book.updateAll("name = ? and author = ?", "老人与海", "海明威"); &#125;&#125;); 删方法一：实例.delete() public static int delete(Class&lt;?&gt; modelClass, long id) id表示要删除哪一行的数据方法二：LitePal.deleteAll(表名.class, 约束, 占位值等) 1234567Button button_delete = findViewById(R.id.delete);button_delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.deleteAll(Book.class, "price &lt; ?", "15"); &#125;&#125;); 查LitePal.findAll(表名.class)，会返回List 12345678910111213141516Button button_query = findViewById(R.id.quary);button_query.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;Book&gt; books = LitePal.findAll(Book.class); for (Book book : books)&#123; Log.d(TAG, "--------------------"); Log.d(TAG, "书名："+book.getName()); Log.d(TAG, "作者："+book.getAuthor()); Log.d(TAG, "出版社："+book.getPress()); Log.d(TAG, "价格："+book.getPrice()); Log.d(TAG, "页数："+book.getPages()); Log.d(TAG, "--------------------"); &#125; &#125;&#125;); 补充 只要任意进行一次数据库的操作，数据库就会自动创建出来 查询第一条数据：LitePal.findFirst(Book.class) 查询最后一条数据：LitePal.findLast(Book.class) select查询几列： 1LitePal.select("name", "author").find(Book.class); where指定约束条件： 1LitePal.where("pages &gt; ?", "400").find(Book.class); order指定排序方式：[desc降序， asc升序] 1LitePal.order("price desc").find(Book.class); litmit指定数量： 1LitePal.litmit(3).find(Book.class); offset指定偏移量： 1LitPal.offset(2).find(Book.class); 原生查询 1LitePal.findBySQL("select * from Book where pages &gt; ?", "400");]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据存储（三）]]></title>
    <url>%2F2019%2F10%2F08%2F19-Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8(%E4%B8%89)%20%2F</url>
    <content type="text"><![CDATA[SQLite数据库SQLite是Android系统内置的一款轻量级关系型数据库，运算速度快并且占用资源少。前面我们所学的文件存储和SharedPreferences存储只适合用于保存一些简单的数据和键值对，而存储大量复杂的关系型数据的时候，SQLite就登场了 创建数据库 Android提供了 SQLiteOpenHelper 这个抽象类来帮助对数据库的创建和升级，新建类继承它，必须复写两个方法onCreate()和onUpgrade() 这个类有两个重要实例方法，getReadableDatabase()和getWritableDatabase()，两者都能打开数据库【存在则打开，否则创建后打开】，并返回一个可供读写操作的对象。当数据库不可被写入(如磁盘已满)的时候，getReadableDatabase()会以只读的方式打开数据库，getWritableDatabase()则抛出异常 数据库文件默认存储位置： /data/data/&lt;package name&gt;/databases/ Demo Code: 实现建一个BookStore.db的数据库，其中有一张Book表，SQL语句如下： 12345678create table Book( id integer primary key autoincrement, author text, price real, pages integer, name text)// real 表示浮点型 blob表示二进制型 在代码中执行这段语句，需要新建MyDatabaseHelper类继承自SQLiteOpenHelper 123456789101112131415161718192021ublic class MyDatabaseHelper extends SQLiteOpenHelper &#123; private Context mContext; public static final String CREATE_BOOK = "create table Book( id integer primary key autoincrement, author text, price real, pages integer, name text)"; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, "创建完成！", Toast.LENGTH_SHORT).show(); &#125;&#125; 主活动： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 1); //创建对象 Button createDatabase = findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); //创建并数据库 &#125; &#125;); &#125;&#125; 查看数据库表查看数据表需要adb工具，adb工具能够连接到当前正在运行的Android模拟器，并对其进行操作.adb工具在Android SDK目录下的platform-tools目录下，为了便于使用它，想把它的路径添加到环境变量： 打开命令行，输入adb shell就能进入控制台，输入su切换超级管理员： \19-2.png) 接下来cd到数据库目录下,去找我们的应用包名: 如上图，在我们的包下找到了我们创建的数据库 BookStore.db,输入 sqlite3 数据库名 就能打开数据库 查看有哪些表：.table查看建表语句：.schema android_metadata和sqlite_sequence是自动创建的表，不用管最后.exit退出 升级数据库 我们要实现功能：再添加一个Category表在数据库里,建表语句： 12345create table Category( id integer primary key autoincrement, category_name text, category_code integer) 注意点 1.原来的数据库已经存在了，那么再次点击创建,onCreate()也不会执行，那么新的表就无法创建了 2.因此，我们要定义onUpgrade()逻辑：当存在旧的表时，就删除旧的表，再执行onCreate()重新建表 3.如何让onUpgrade()执行呢，修改SQLiteOpenHelper的构造方法第四个参数，版本号改大就行 Demo Code: 12345678910111213141516171819202122232425public class MyDatabaseHelper extends SQLiteOpenHelper &#123; private Context mContext; public static final String CREATE_BOOK = "create table Book( id integer primary key autoincrement, author text, price real, pages integer, name text)"; public static final String CREATE_CATAGORY = "create table Category( id integer primary key autoincrement, category_name text, category_code integer)"; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("drop table if exists Book"); db.execSQL("drop table if exists Category"); onCreate(db); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATAGORY); Toast.makeText(mContext, "创建完成！", Toast.LENGTH_SHORT).show(); &#125;&#125; 主活动只需要改一下版本号 1dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2); 运行的的时候发现，也是点击一次有Toast，多次点击并没有Toast，这是因为版本号的限制,最后可以adb查看创建的表 增SQLiteOpenHelper.insert() 三个参数： 参数一：表名 参数二：传null 参数三：一个ContentValues对象,提供了一系列put()方法,传入列名和数据就行 123456789SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); //第一条数据 values.put("name","老人与海"); values.put("author","海明威"); values.put("pages","456"); values.put("price","18.88"); db.insert("Book",null,values); //添加 values.clear(); 删SQLiteOpenHelper.delete() 三个参数： 参数一：表名 参数二、参数三用于约束，限制某一行或某几行的数据，不指定则是删除所有相应行 12345678Button button_delete = findViewById(R.id.delete); button_delete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getReadableDatabase(); db.delete("Book", "pages &gt; ?", new String[]&#123;"400"&#125;); &#125; &#125;); 改SQLiteOpenHelper.update() 四个参数： 参数一：表名 参数二：ContentValues对象，提供了一系列的put()方法重载，传入列名和数据就行 参数三、参数四用于约束，限制某一行或某几行的数据，不指定则是更新所有行 1234SQLiteDatabase db = dbHelper.getReadableDatabase(); ContentValues values = new ContentValues(); values.put("price", 10.99); db.update("Book",values, "name = ?",new String[]&#123;"老人与海"&#125;); 查SQLiteOpenHelper.quary()七个参数： 参数一：table，表名 参数二：columns，列名 参数三：selection，where约束条件 参数四：selectionArgs，占位符提供值 参数五：groupBy，分组查询 参数六：having，进一步约束 参数七：orderBy，排序方式 会返回Cursor对象，查询到的数据从这个对象中取出 1234567891011121314151617//查询表中所有的数据 Cursor cursor=db.query("Book",null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("test", "--------------------"); Log.d("test", "书名："+name); Log.d("test", "作者："+author); Log.d("test", "页数："+pages); Log.d("test", "价格："+price); Log.d("test", "--------------------"); &#125;while (cursor.moveToNext()); &#125; cursor.close(); 使用SQL语句来操作数据库上面的增删改查都是SQLiteDatabase为我们提供的方法，用起来会比较麻烦,下面学习一下用SQL语句来进行操作 1.增1db.execSQL("insert into 表名(列1，列2，列3...) values (值1，值2，值3...)") 2.删1db.execSQL("delete from 表名 wherr 列名 &gt; ?", new String[]&#123;值&#125;) 3.改1db.execSQL("update 表名 set 列名 = ? where 列名 &gt; ?", new String[]&#123;值1，值2&#125;) 4.查1db.rawQuery("select * from Book", null); 除了查询操作，其他都用db.execSQL()来执行SQl语句]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据存储（二）]]></title>
    <url>%2F2019%2F10%2F08%2F18-Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8(%E4%BA%8C)%20%2F</url>
    <content type="text"><![CDATA[SharedPreferencesSharedPreferences是使用键值对的方式来存储数据的，支持多种不同的数据类型存储 如何将数据存起来 要用SharedPreferences存储数据，首先要获取到SharedPreferences对象，有三种方法： 1.Context.getSharedPreferences(),接收两个参数 第一个参数：指定文件名，不存在则会创建一个,存放目录：/data/data/&lt;package name&gt;/share_prefs 第二个参数：指定操作模式，填写MODE_PRIVATE或0，表示只有当前应用程序可以对文件读写 2.Activity.getPreferences()，接收一个参数 只接收一个参数，指定操作模式 会自动将文件名设置为当前活动的类名 3.PreferenceManager.getDefaultSharedPreferences()，接收一个参数 这是一个静态方法，接收一个context参数 自动使用当前应用的包名做前缀来命名文件 得到SharedPreferences对象以后就可以向文件中存储数据了，存储数据也分三步： 1.调用edit()获取SharedPreferences.Editor对象 2.往SharedPreferences.Editor对象中添加数据，比如添加字符串用putString()，添加布尔对象用putBoolean()等 3.调用apply()将添加的数据提交，从而完成数据存储 Demo Code： 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button saveData = findViewById(R.id.save_data); saveData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit(); //调用.edit()方法获对象 editor.putString("name", "breathy"); editor.putInt("age", 24); editor.putBoolean("married", true); editor.apply(); //提交数据 &#125; &#125;); &#125; &#125; 点击按钮后，会在/data/data/com.example.day11_sharedpreferencestest/shared_prefs/data.xml目录下找到文件： 保存并打开，能看到xml格式的数据文件： 将数据读出来 1.获取SharedPreferences对象 2.直接用对应类型的get()取出来，不需要Editor Demo code: 1234567891011thirdBinding.btn3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;// SharedPreferences.Editor editor=getSharedPreferences("data",MODE_PRIVATE).edit();// editor.putString("name","小明");// editor.putInt("age",18);// editor.apply(); SharedPreferences sharedPreferences=getSharedPreferences("data",0); Log.d("test",sharedPreferences.getString("name","")); //get方法有两个参数，一个是key值，第二个是默认值 &#125; &#125;);]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据存储（一）]]></title>
    <url>%2F2019%2F10%2F08%2F17-Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Android数据存储Android主要提供了三种数据存储的方式：文件存储、SharedPreferences和数据库存储 文件存储 Context类提供了一个方法openFileOutput():接收2个参数 第一个参数是文件名，文件名不包含路径，因为所有的文件都默认存储到/data/data/&lt;package name&gt;/files/目录下 第二个参数是操作模式，主要有两种: MODE_PRIVATE :默认操作模式，文件名相同时，会进行覆盖 MODE_APPEND :文件名相同时，会追加内容，不存在就自动创建 返回对象是FileOutputStream，可以通过Java流控制文件写入 Demo Code: 借助openFileOutput()得到FileOutputStream对象，再通过OutputStreamWriter()得到BufferWriter对象就能直接写入文件了 1234567891011121314151617181920public void save()&#123; String data = "要存储的数据"; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput("文件名", Context.MODE_PRIVATE); writer = new BufferWriter(new OutputStreamWriter(out)); writer.writer(data); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try&#123; if(writer != null)&#123; writer.close(); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 从文件中读取数据 Context类还提供了一个方法 openFileInput(): 接收一个参数 只有一个参数,文件名，件名不包含路径，因为所有的文件都默认存储到/data/data/&lt;package name&gt;/files/目录下 返回一个FileInputStream对象，通过java流读取数据 Demo code: 123456789101112131415161718192021222324public String load()&#123; public String in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try&#123; in = openFileInput("要读取的文件名"); reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while((line = reader.readLine() != null)&#123; content.append(line); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; if(reader != null)&#123; try&#123; reader.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义广播]]></title>
    <url>%2F2019%2F10%2F08%2F16-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[发送和接收定向广播 实现点击发送按钮，收到广播弹出Toast提示 1.新建一个广播MyBroadcastReceiver(直接用新建广播即可，自己创建java类的话不要忘记在manifest文件中进行注册) 1234567public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d("test", "收到消息"); Toast.makeText(context, "自定义广播接收器已经接收到消息", Toast.LENGTH_SHORT).show(); &#125;&#125; 自己创建的话，不要忘记注册 12345 &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; 2.主活动 实现点击事件 Android对广播的要求越来越严，现在构造了intent后必须调用setComponet()方法，并且现在建立intent时不需要添加action参数，在manifest中注册时，也可以不指定action 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("test", "已发送"); Intent intent = new Intent(); //调用setComponent()方法 intent.setComponent(new ComponentName(getPackageName(), "com.ccc.day09_mybroadcastreceiver.MyBroadcastReceiver")); sendBroadcast(intent); &#125; &#125;); &#125;&#125; 效果： 动态注册发送和接收不定向广播 1.新建一个项目程序，创建广播接收器 1234567public class AnotherBroadCastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "收到不定向广播消息", Toast.LENGTH_LONG).show(); &#125;&#125; 主活动动态注册广播 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; //设置为静态可以解决重复注册的问题 static AnotherBroadCastReceiver anotherBroadCastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("MyBroadcast"); if (anotherBroadCastReceiver == null) &#123; anotherBroadCastReceiver = new AnotherBroadCastReceiver(); registerReceiver(anotherBroadCastReceiver, intentFilter); //动态注册 &#125; &#125;&#125; 再去修改上面那个项目的主活动，让其发送不定向广播 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("MyBroadcast"); //发送不定向广播 sendBroadcast(intent); &#125; &#125;); &#125;&#125; 将上面两个项目程序安装在同一个模拟器上，然后依次启动项目2，项目1，项目1点击发送，项目2可以接收 关闭项目2.会发现无法接收项目1发送的广播了,由此可见，动态注册的广播接收器只能在活动启动时接收广播 发送有序广播 发送有序广播用sendOrderedBroadcast()方法，两个参数，第一个是intent,第二个是和权限相关的字符串，填写null就行了 12Intent intent = new Intent("MyBroadcast");sendOrderedBroadcast(intent,null); 设置优先级大小 动态用intentFilter.setPriority(1000); 静态使用android:priority=&quot;1000&quot;，优先级高的可以先收到广播 1234567//动态IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("MyBroadcast"); // setPriority()设置权限大小 intentFilter.setPriority(1000); anotherBroadCastReceiver = new AnotherBroadCastReceiver(); registerReceiver(anotherBroadCastReceiver, intentFilter); 123456789&lt;!--静态--&gt; &lt;receiver android:name=".util.BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="1000"&gt; &lt;!--在这里设置--&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 如果在onReceive()方法中调用了abortBroadcast()方法，那么广播有序广播传递到这里时会被截断，不再往下传 本地广播 前面我们发送和接收的广播都属于系统全局广播，容易引起安全性问题，因此Android引入了一套本地广播机制，使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收本应用程序发出的广播，这样来保证安全性 引入依赖库 1implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.0.0' 主活动修改 123456789101112131415161718192021222324252627282930313233343536373839404142 public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManger; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);// 获取实例 localBroadcastManger = localBroadcastManger.getInstance(this); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("LocalBroadcast"); // 发送广播 localBroadcastManger.sendBroadcast(intent); &#125; &#125;); // 注册广播 intentFilter = new IntentFilter(); intentFilter.addAction("LocalBroadcast"); localReceiver = new LocalReceiver(); localBroadcastManger.registerReceiver(localReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); localBroadcastManger.unregisterReceiver(localReceiver); &#125; private class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "已接收到本地广播！",Toast.LENGTH_LONG).show(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 广播]]></title>
    <url>%2F2019%2F10%2F08%2F15-%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[广播机制简介Android中的广播机制很灵活，Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样改程序就只会接收到自己所关心的广播内容。发送广播可以通过Intent,接收广播需要广播接收器(Broadcast Receiver) 标准广播：所有的广播接收器几乎都会在同一时刻接收到此广播消息，异步执行，没有任何先后顺序，效率比较高但无法被截断 有序广播：同步执行的广播，广播发出后，同一时刻只有一个广播接收器能够收到这条广播消息，当一个广播接收器的逻辑执行完毕后才会传递给下一个广播接收器，优先级高的广播接收器可以先收到消息，还可以截断广播消息 系统广播开机完成，电量变化，时区改变等活动发生时系统都会发送一条广播 创建广播接收器 1.新建一个类继承自BroadcastReceiver 2.重写onReceive()方法 动态注册一个监听网络变化的程序修改MainActivity: 123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; //需要一个InterFilter对象和一个BroadcastReceiver对象 private IntentFilter intentFilter; private NetWorkChangeReceiver netWorkChangeReceiver; public MainActivity() &#123; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(netWorkChangeReceiver); //动态注册的广播必须取消注册 &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //当网络发生变化时，系统发出的正是android.net.conn.CONNECTIVITY_CHANGE的广播 intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); netWorkChangeReceiver = new NetWorkChangeReceiver(); registerReceiver(netWorkChangeReceiver, intentFilter); &#125; //新建一个类，继承自BroadcastReceiver private class NetWorkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"网络环境发生变化", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 监听网络状态 声明网络访问权限 1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; 在API21后原来的NetWorkInfo类被判为过时，不再推荐使用，增加了一个类NetworkCapabilities,其中有很多对于网络性能的描述，可以通过ConnectivityManager获得描述当前网络的NetworkCapabilities 新的指示网络的连接方式包括如下状态 TRANSPORT_CELLULAR(蜂窝网络,即数据流量) TRANSPORT_WIFI(wifi) TRANSPORT_BLUETOOTH(蓝牙) TRANSPORT_ETHERNET(以太网) TRANSPORT_VPN(vpn) 12345678910111213141516171819202122ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE); //获取ConnectivityManager实例 if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; if (connectivityManager != null) &#123; Network activeNetwork = connectivityManager.getActiveNetwork(); NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(activeNetwork); //获取NetworkCapabilities对象 if (capabilities != null &amp;&amp; capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)) &#123; if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) &#123; Log.d("NET", "已连接wifi网络"); &#125; else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_BLUETOOTH)) &#123; Log.d("NET", "已连接蓝牙网络"); &#125; else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) &#123; Log.d("NET", "已连接以太网"); &#125; else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_VPN)) &#123; Log.d("NET", "已连接VPN"); &#125; else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) &#123; Log.d("NET", "正在使用数据流量"); &#125; &#125; else &#123; Log.d("NET", "网络未连接"); &#125; &#125; &#125; 静态注册实现开机启动Android系统开机后，会发送一个 BOOT_COMPLETED 的广播 接收BOOT_COMPLETED广播，需要权限，该权限：android.Manifest.permission#RECEIVE_BOOT_COMPLETED。 收到开机广播时在onReceive()中执行启动活动 Android Studio提供了快捷方式创建广播接收器，右键单击包名，新建-&gt;other-&gt;Broadcast Receiver Exported表示是否允许该广播接受去接收本程序之外的广播，Enabled表示是否启用这个广播接收器 修改刚创建的BootCompleteReceiver 1234567public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,"已经检测到开机了！",Toast.LENGTH_LONG).show(); &#125;&#125; 打开AndroidManifest.xml，发现AS自动帮我们完成了广播接收器的代码： 12345&lt;receiver android:name=".BootCompleteReceiver" android:enabled="true" android:exported="true"&gt;&lt;/receiver&gt; 不过这还不够，我们还要声明启动权限以及加入Boot_COMPLETED的权限： 12345678&lt;receiver android:name=".BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; &lt;!--action标签内容即为要接收的广播--&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 1&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; 运行重启模拟器：]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Fragment]]></title>
    <url>%2F2019%2F10%2F08%2F14-Fragment%2F</url>
    <content type="text"><![CDATA[碎片（Fragment）碎片是一种可以嵌入在活动中的UI碎片，可以理解为一个迷你型的活动，通常在平板开发中使用 动态添加/替换碎片 创建待添加的碎片实例 获取FragmentManager，在活动中通过getSupportFragmentManager()获得 开始一个事务，调用beginTransaction()开启 向容器添加add或替换replace()碎片 提交事务commit() 123456private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager=getSupportFragmentManager(); //获取FragmentManager实例 FragmentTransaction transaction=fragmentManager.beginTransaction(); //开启一个事务 transaction.replace(R.id.right_layout,fragment); transaction.commit(); //提交事务 &#125; 在碎片中模拟返回栈上面的实例中，我们点击按钮替换了新的碎片后，按下BACK键会直接退出，如何返回到上一个碎片？ addToBackStack()方法可以将一个事务添加到返回栈当中 1234567private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager=getSupportFragmentManager(); FragmentTransaction transaction=fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout,fragment); transaction.addToBackStack(null); //添加到返回栈 接收一个名字用于描述返回栈的状态，一般传入null即可 transaction.commit(); &#125; 碎片和活动之间的通信 为了方便碎片和活动之间进行通信，FragmentManager提供了一个findFragmentById()方法，用于从布局文件中获取碎片的实例 1RightFragMent rightFragment = (RightFragment) getSupportFragmentManger().findFragmentById(R.id.right_fragment); 碎片中调用活动 getActivity() 方法来获取相关的活动实例 1MainActivity activity = (MainActivity) getActivity(); 另外，在碎片中需要使用Context对象时，也可以使用getActivity()方法，因为获取到的活动本身就是一个Context对象 碎片的声明周期四种状态(碎片依附于活动) 运行态：碎片可见，所关联的活动处于运行态 暂停态：所关联的活动处于暂停态 停止态：所关联的活动处于停止态，或通过replace()和remove()等方法移除掉碎片。总之，碎片此时完全不可见，有可能被系统回收 销毁态：所关联的活动处于销毁态，或通过replace()和remove()等方法移除掉碎片。总之，碎片此时完全不可见，已经被系统回收 五个回调方法 onAttach(): 当碎片和活动建立关联时调用 onCreateView(): 为碎片加载布局时调用 onActivityCreated(): 确保与碎片相关联的活动一定已经创建完毕的时候调用 onDestroy(): 当与碎片关联的视图被移除的时候调用 onDetach(): 当碎片和活动解除关联的时候调用 动态加载布局使用限定符 主布局,只留下左侧碎片并充满整个父布局 activity_main.xml 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:layout_width="match_parent" android:layout_height="match_parent" android:name="com.example.day06_fragment.LeftFragment" android:id="@+id/left_fragment" /&gt;&lt;/LinearLayout&gt; 大布局 在res新建一个layout-large文件夹，在里面新建一个activity_main.xml布局，其中large就是一个限定符，屏幕被认为是large的设备会自动加载对应文件夹下的布局 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:layout_width="0dp" android:layout_height="match_parent" android:name="com.example.day06_fragment.LeftFragment" android:id="@+id/left_fragment" android:layout_weight="1"/&gt; &lt;fragment android:layout_width="0dp" android:layout_height="match_parent" android:name="com.example.day06_fragment.RightFragment" android:id="@+id/right_fragment" android:layout_weight="3"/&gt;&lt;/LinearLayout&gt; 运行效果： 常见限定符 大小：small，normal，large，xlarg 分辨率：ladpi(低分辨率)，mdpi，hdpi，xhdpi，xxhdpi(超超高分辨率) 方向：land(横屏)，port(竖屏) 最小宽度限定符 Smallest-width Qualifier允许我们对屏幕的宽度限定一个最小值，以这个最小值为临界点，大于这个值解加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局 新建布局：在res下新建一个layout-sw600dp文件夹，在里面新建一个activity_main.xml布局，这就意味着程序在屏幕宽度小于600dp的设备是layout/activity_main.xml布局，大于等于600dp用layout-sw600dp/activity_main.xml布局]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RecycleView]]></title>
    <url>%2F2019%2F10%2F08%2F13-RecyclerView%2F</url>
    <content type="text"><![CDATA[用法导入依赖库1implementation 'androidx.recyclerview:recyclerview:1.0.0' 主布局添加控件123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 子布局 fruit_item.xml123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="32dp" android:layout_height="32dp" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="32dp" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 实体类 Fruit123456789101112131415public class Fruit &#123; private String name; private int imageId; public Fruit(String name,int imageId)&#123; this.name = name; this.imageId = imageId; &#125; public String getName()&#123; return name; &#125; public int getImageId()&#123; return imageId; &#125;&#125; 新建类FruitAdapter继承自RecyclerView.Adapter，指定泛型为FruitAdapter.ViewHolder(在该adapter中新建ViewHolder类继承自RecyclerView.ViewHolder) 首先定义了内部类 ViewHolder，继承自RecyclerView.ViewHolder，其中传入了一个itemView参数，这个参数继承通常是RecycleView子项的最外层布局，通过它就能取到 ImageView 和 TextView 了 必须重写的三个方法 onCreateViewHolder()： 用来创建ViewHolder实例，在这个方法中，将 子布局 传入创建的ViewHolder实例，然后将其返回 onBindViewHolder()：对RecyclerView子项数据赋值，会在子项布局滚动到屏幕时执行 getItemCount()：返回数据源的长度，用来判断子布局的个数 123456789101112131415161718192021222324252627282930313233343536373839public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private List&lt;Fruit&gt; mFruitList; //需要传入一个数据集合来构建adapter public FruitAdapter(List&lt;Fruit&gt; mFruitList) &#123; this.mFruitList = mFruitList; &#125; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); //传入子项布局 fruit_item 构建view 进而构建viewholder ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); //list.size()直接得到数量 &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; ImageView fruitImage; TextView fruitName; public ViewHolder(@NonNull View itemView) &#123; super(itemView); fruitImage = (ImageView) itemView.findViewById(R.id.fruit_image); fruitName = (TextView) itemView.findViewById(R.id.fruit_name); &#125; &#125;&#125; 主活动修改 先通过initFruit()初始化水果数据，接着创建RecycleView实例，然后创建了一个LinearLayoutManger对象，并将它设置到RecycleView中，表示使用线性布局，最后创建FruitAdapter实例建立数据关联 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(fruitList); RecyclerView recyclerView = findViewById(R.id.recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); //记住 recyclerView需要设置两个东西，一个是布局，一个是adapter recyclerView.setLayoutManager(layoutManager); recyclerView.setAdapter(adapter); &#125; private void initFruits()&#123; for (int i = 0; i &lt; 2; i++)&#123; Fruit apple = new Fruit("苹果", R.drawable.apple); fruitList.add(apple); Fruit banana = new Fruit("香蕉", R.drawable.banana); fruitList.add(banana); Fruit orange = new Fruit("橙子", R.drawable.orange); fruitList.add(orange); Fruit watermelon = new Fruit("西瓜", R.drawable.watermelon); fruitList.add(watermelon); Fruit pear = new Fruit("梨", R.drawable.pear); fruitList.add(pear); Fruit grape = new Fruit("葡萄", R.drawable.grape); fruitList.add(grape); Fruit pineapple = new Fruit("菠萝", R.drawable.pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit("草莓", R.drawable.strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit("樱桃", R.drawable.cherry); fruitList.add(cherry); Fruit mango = new Fruit("芒果", R.drawable.mango); fruitList.add(mango); &#125; &#125;&#125; 横向滚动只修改调用的LineatLayout属性，修改为水平，加入一行代码即可 12345678910111213protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(fruitList); RecyclerView recyclerView = findViewById(R.id.recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); //这里修改为水平 recyclerView.setLayoutManager(layoutManager); recyclerView.setAdapter(adapter);&#125; 瀑布流效果使用StaggeredGridLayoutManger布局，仅修改一行代码： StaggeredGridLayoutManger的构造函数接收两个参数，第一个参数用来指定布局列数；第二个参数指定排列方向 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(fruitList); RecyclerView recyclerView = findViewById(R.id.recycler_view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); recyclerView.setAdapter(adapter);&#125; 点击事件简单实现 多种方式，可在onBindViewHolder()中实现 123456789101112@Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123; final Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("tag",fruit.getName()); &#125; &#125;); &#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android listview]]></title>
    <url>%2F2019%2F10%2F08%2F12-listview%2F</url>
    <content type="text"><![CDATA[记住需要的几个东西 一个实体类 一个子项的布局 一个自定义adapter类 简单listview 修改主布局，添加listview控件 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/list_view" android:layout_height="match_parent" android:layout_width="match_parent" /&gt;&lt;/LinearLayout&gt; 修改主活动 12345678910111213public class MainActivity extends AppCompatActivity &#123; private String[] Data = &#123;"苹果", "香蕉", "橙子", "西瓜", "梨", "葡萄", "菠萝", "草莓", "樱桃", "芒果", "苹果", "香蕉", "橙子", "西瓜", "梨", "葡萄", "菠萝", "草莓", "樱桃", "芒果"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, Data); //构造一个适配器 ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); //加载适配器 &#125;&#125; ArrayAdapter用泛型指定适配的数据类型，然后在构造函数中把要适配的数据传入：有3个参数 参数1：当前上下文 参数2：子项布局的ID，android.R.layout.simple_list_item_1是Android内置布局，里面只有一段TextView，用于简单地显示一段文本 参数3：要适配的数据 自定义listView界面 定义一个Fruit类 123456789101112131415public class Fruit &#123; private String name; private int imageId; public Fruit(String name,int imageId)&#123; this.name = name; this.imageId = imageId; &#125; public String getName()&#123; return name; &#125; public int getImageId()&#123; return imageId; &#125;&#125; 定义一个子项布局 fruit_item布局 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruite_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruite_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" /&gt;&lt;/LinearLayout&gt; 自定义一个适配器FruitAdapter,继承自ArrayAdpter&lt;Fruit&gt; 1234567891011121314151617181920public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects)&#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); ImageView fruitImage = view.findViewById(R.id.fruite_image); TextView fruitName = view.findViewById(R.id.fruite_name); fruitImage.setImageResource(fruit.getImageId()); //加载图片 fruitName.setText(fruit.getName());//加载名字 return view; &#125;&#125; 这里LayoutInflater的inflate方法接收三个参数，第三个参数指定False，表示只让我们在父布局中声明的layout属性生效。但不会为这个View添加父布局，因为一旦View有了父布局后，他就不能再添加到ListView中了 修改MainActivity: 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits()&#123; for (int i = 0; i &lt; 2; i++)&#123; Fruit apple = new Fruit("苹果", R.drawable.apple); fruitList.add(apple); Fruit banana = new Fruit("香蕉", R.drawable.banana); fruitList.add(banana); Fruit orange = new Fruit("橙子", R.drawable.orange); fruitList.add(orange); Fruit watermelon = new Fruit("西瓜", R.drawable.watermelon); fruitList.add(watermelon); Fruit pear = new Fruit("梨", R.drawable.pear); fruitList.add(pear); Fruit grape = new Fruit("葡萄", R.drawable.grape); fruitList.add(grape); Fruit pineapple = new Fruit("菠萝", R.drawable.pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit("草莓", R.drawable.strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit("樱桃", R.drawable.cherry); fruitList.add(cherry); Fruit mango = new Fruit("芒果", R.drawable.mango); fruitList.add(mango); &#125; &#125;&#125; 提升ListView运行效率convertView缓存 getView()方法有个convertView参数，用来将之前加载好的布局进行缓存，以便之后重用： 1234567891011121314151617@NonNull@Overridepublic View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; if (convertView == null)&#123; view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = view.findViewById(R.id.fruite_image); TextView fruitName = view.findViewById(R.id.fruite_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;java ViewHolder缓存 现在，虽然不会重复加载布局，但是每次还是会findViewById()来获取一次控件的实例，所以要借助ViewHolder来优化： 12345678910111213141516171819202122232425@Overridepublic View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruite_image); viewHolder.fruitName = (TextView) view.findViewById(R.id.fruite_name); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view;&#125;//定义一个ViewHolder类class ViewHolder &#123; ImageView fruitImage; TextView fruitName;&#125; 新增一个内部类ViewHolder，用于对实例进行缓存，将实例对象通过View.setTag()存在View中，这样就没必要每次都findViewById()了 listview点击事件通过setOnItemClickListener()方法注册监听器： 123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = findViewById(R.id.list_view); listView.setAdapter(adapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, "你点击了 "+fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义控件]]></title>
    <url>%2F2019%2F10%2F08%2F11-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[include 引入布局 实现简单的自定义标题栏 title.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/ic_launcher_background"&gt; &lt;Button android:id="@+id/title_back" android:layout_width="wrap_content" android:layout_height="70dp" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/back" android:text="返回" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/titile_text" android:layout_width="0dp" android:layout_height="70dp" android:layout_gravity="center" android:layout_weight="1" android:gravity="center" android:text="文字标题" android:textColor="#fff" android:textSize="24sp" /&gt; &lt;Button android:id="@+id/titile_edit" android:layout_width="wrap_content" android:layout_height="70dp" android:layout_gravity="center" android:layout_margin="5dp" android:background="@drawable/edit" android:text="编辑" android:textColor="#fff" /&gt;&lt;/LinearLayout&gt; 在别的地方引用这个title.xml绘制的标题栏只需 &lt;include layout=&quot;@layout/title&quot;/&gt; 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/title"/&gt; &lt;!-- 引用上面自定义标题栏title--&gt;&lt;/LinearLayout&gt; 然后将自带的标题栏隐藏掉： 123456789protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActionBar actionBar = getSupportActionBar(); if (actionBar!=null)&#123; actionBar.hide(); //隐藏Android系统自带的标题栏 &#125;&#125; 效果如图： 不隐藏的话，就会造成如下图情况： 创建自定义控件 问题引出：像上面的例子，自定义了标题栏，要给返回按钮添加点击事件，如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，因此我们可以使用自定义控件来解决 新建TitleLayout继承LinerLayout,让它成为我们自定义的标题栏控件，代码如下 123456public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title,this); &#125;&#125; 我们首先重写了LinearLayout中带有两个参数的构造函数，在布局中引入TitleLayout控件就会调用这个构造函数 接下来需要对标题栏布局进行动态加载，这就需要LayoutInflater了 其from()方法可以构建出一个LayoutInflater对象 其inflate()方法可以动态加载布局文件，需要两个参数：加载布局文件的ID和加载好的布局的父布局 引入自定义控件 添加自定义控件时，我们需要指明控件的完整类名，包名时不可省略的 123&lt;com.ccc.newlearn.util.TitleLayout android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 为自定义控件注册按钮点击事件,这样每当我们在一个布局中引入TitleLayout时，返回按钮和编辑按钮点击事件就已经自动实现好了，省去了很多重复的代码工作 12345678910111213141516171819202122public class TitleLayout extends LinearLayout implements View.OnClickListener &#123; public TitleLayout(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); Button titleBack = (Button) findViewById(R.id.title_back); Button titleEdit = (Button) findViewById(R.id.titile_edit); titleBack.setOnClickListener(this); titleEdit.setOnClickListener(this); &#125; //getContext()获取当前对象所在的Context @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.title_back: ((Activity) getContext()).finish(); break; case R.id.titile_edit: Toast.makeText(getContext(), "点击了编辑", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局]]></title>
    <url>%2F2019%2F10%2F08%2F10-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[LinearLayout 如果只是指定一部分的控件layout_weight值，别的自动调节,UI效果会更好 例如下面的效果就是：Button的宽度仍然按照wrap_content来计算，而EditText则会沾满屏幕所有的剩余空间。 123456789101112131415&lt;!-- 这里只指定了EditText的layout_weight，而让Button自动适应--&gt;&lt;EditText android:id="@+id/input_message" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:hint="在这里输入消息" /&gt;&lt;Button android:id="@+id/send_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送" /&gt; RelativeLayout 基于父控件定位 layout_alignParentLeft 位于父控件左边 layout_alignParentRight 右边 layout_alignParentTop 上边 layout_alignParentBottom 下边 layout_centerInParent 正中间 12345678910&lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="button 1" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" /&gt;&lt;!--该按钮位于父容器左上角--&gt; 基于其他控件定位 layout_toLeftOf 左 layout_toRightOf 右 layout_above 上 layout_below 下 12345678910 &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="button 1" android:layout_above="@+id/button3" android:layout_toLeftOf="@+id/button3" /&gt;&lt;!-- button1位于button3的左上角--&gt; FrameLayout 帧布局简单而且应用场景少，这种布局所有控件都会摆放在左上角 默认会重叠放置，后面添加的控件会遮住前面的 percentlayout 百分比布局是帧布局FrameLayout和相对布局RelativeLayout的扩展，提供了PercentFrameLayout 和 PercentRelativeLayout 两种新的布局方式。 添加依赖：implementation &#39;androidx.percentlayout:percentlayout:1.0.0&#39; 百分比布局不是内置的布局，所以使用时要写完整的包路径 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.percentlayout.widget.PercentFrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;Button android:id="@+id/button1" android:text="Button 1" android:layout_gravity="left|top" app:layout_widthPercent="50%" app:layout_heightPercent="50%" /&gt; &lt;/androidx.percentlayout.widget.PercentFrameLayout&gt;&lt;!-- 实际上并不推荐使用 --&gt;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基本控件注意点]]></title>
    <url>%2F2019%2F10%2F08%2F9-Android%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[总结一些基本的注意点 wrap_content 表示由控件内容决定当前控件的大小 android:gravity 指定文字的对齐方式（表示当前View，即控件，内部的东西的，对齐方式） android:layout_gravity 可以指定控件的对齐方式（表示当前View，即控件本身，在父一级内的（即父一级控件所给当前子控件所分配的显示范围内）的对齐方式） center = center_vertical + center_horizontal 系统会对Button中的所有英文字母自动进行大写转换， 可通过 android:textAllCaps=&quot;false&quot; 来禁止这一默认特性 android:hint 属性指定了一段提示性的文本 android:maxLines 指定了EditText的最大行数，这样当输入内容超过指定行数时，文本就会向上滚动，而EditText则不会再继续拉伸 ImageView 在xml中通过 android:src 属性指定图片;在java中通过setImageResource()方法指定图片 Android控件的可见属性 android:visibilty 来指定，可选值有三种：visible、invisible和gone。visible表示控件是可见的，是默认值，invisible表示控件不可见，但是它仍然占据着原来的位置和大小，gone则表示控件不仅不可见，而且不再占用任何屏幕空间 在java中通过代码设置控件的可见性 setVisibility()方法，传入View.VISIBLE 、View.INVISIBLE、View.GONE AlertDialog 弹出对话框 1234567891011121314151617AlertDialog.Builder dialog = new AlertDialog.Builder(ThirdActivity.this); dialog.setTitle("this is a dialog"); dialog.setMessage("Something important"); dialog.setCancelable(false); //表示dialog不可通过BACK键来取消 dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.show(); ProgressDialog弹出一个对话框，并且对话框中显示一个进度条，一般用于表示当前操作比较耗时 Android在API27中废弃了ProgressDialog。 弃用的原因：ProgressDialog是浮现在Activity上的一层，它阻止了用户的交互，所以不友好。 12345ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("This is ProcessDialog"); progressDialog.setMessage("加载中..."); progressDialog.setCancelable(true); progressDialog.show(); 数据加载完成后要通过dismiss()来关闭]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android活动的使用技巧]]></title>
    <url>%2F2019%2F10%2F08%2F8-%E6%B4%BB%E5%8A%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[知晓当前在哪个活动 新建一个Java Class:BaseActivity，并让它继承AppCompatActivity 接下来重写onCreate()，可以看到通过getClass().getSimpleName()打印了当前实例的类名： 接下来只要分别让FirstActivity等不再继承AppCompatActivity，而是继承BaseActivity，那么就能知晓当前界面对应的是哪个活动了 12345678public class BaseActivity extends AppCompatActivity &#123; private static final String TAG="BaseActivity"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG,getClass().getSimpleName()); &#125;&#125; 随时随地的退出程序 有时候会发现退出程序需要按好多次Back键。按Home键也只是把程序挂起，并没有退出程序，因此我们需要一个随时随地都能退出程序的方案 思路：需要用一个专门的集合类对所有的活动进行管理 12345678910111213141516171819public class ActivityCollector &#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity) &#123; activities.add(activity); &#125; public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125; public static void finshAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125; 接下来修改BaseActivitiey的代码 12345678910111213141516public class BaseActivity extends AppCompatActivity &#123; private static final String TAG = "BaseActivity"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, getClass().getSimpleName()); ActivityCollector.addActivity(this); //使用 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125;&#125; 这样BaseActivity就会将活动添加或移除到活动管理器里，如果想要退出程序，只需要调用ActivityCollector.finishAll()即可。 例如前面的例子从Activity1跳转到Activity2，再从2跳到3，要退出程序需要返回3次，现在只需要在Activity3中重写onBackPressed()在里面调用刚才的finishAll() 12345@Override public void onBackPressed() &#123; super.onBackPressed(); ActivityCollector.finshAll(); &#125; 为了确保程序完全退出，还可以再加一句代码杀掉进程： 1android.os.Process.killProcess(android.os.Process.myPid());]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android活动的启动模式]]></title>
    <url>%2F2019%2F10%2F08%2F7-%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[启动模式在AndroidManifest.xml文件中给&lt;activity&gt;标签指定 android:launchMode 属性来设置启动模式 standard singleTop singleTask singleIntance standard 默认的启动模式 每启动一个新的活动，他就会从返回栈中入栈，并处于栈顶的位置 对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈汇总存在，每次启动都会创建该活动的一个新的实例 standard demo：我们在FirstActivity的基础上再启动FirstActivity，并两次点击按钮 123456789101112131415protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Log.d(TAG, this.toString()); Button button1 = (Button) findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, FirstActivity.class); //启动自身 startActivity(intent); &#125; &#125;);&#125; 发现需要点三次BACK才能返回桌面 singleTop当启动活动时发现返回栈的栈顶已经是该活动，则直接使用，不再创建新的活动。 还是上面的例子，这次将活动的启动模式设置为singleTop 12345678&lt;activity android:launchMode="singleTop" 设置为singleTop模式 android:name=".FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 连续点击3次会发现只打印了1次 不过当Activity并未处于栈顶位置时，这时再启动Activity，还是会创建新的实例 singleTask让某个活动在整个应用程序的上下文中只存在一个实例，每次启动该活动时，系统首先会在返回栈中检查是否存在该活动的实例，若发现已经存在，则直接使用该实例，并把该活动之上的所有活动统统出站，若没有发现，则会创建一个新的实例 下面将Activity1的启动模式设为singleTask,并在Activity1中复写onRestart()方法，在Activity2中复写onDestroy()方法，从Activity1跳转到Activity2并返回Activity1，观察log输出 12345678&lt;activity android:launchMode="singleTask" 设置为singleTask android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 会发现，一开始创建了一个MainActivity的实例，跳转到活动2并返回后，发现调用了Activity1的restart，和Activity2的onDestroy方法 singleInstance指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动 做一个简单demo,将Activity2的启动模式设置为singleInstance，activity1和Activity3为默认的启动模式，在每个活动中都用getTaskId()获取并打印出自己所在的返回栈的ID,首先启动Activity1，然后从Activity1跳转到Activity2，再从Activity2跳转到Activity3，再点击返回键BACK,观察log输出 通过日志可以发现，Activity2的确用了一个新的返回栈来处理，Activity1和Activity3的返回栈id是一样的，说明是同一个返回栈，并且在Activity3点击BACK返回时，会发现到了Activity1，在Activity1中点击返回，到了Activity2页面。也就是说，只有一个返回栈空了，才会转到另外一个栈]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android活动的生命周期]]></title>
    <url>%2F2019%2F10%2F08%2F6-%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[返回栈Android是使用任务(Task)来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack) 可见和不可见的含义 可见：当前活动在主屏能看到,比如当前活动界面打开一个Dialog样式的活动，那么此活动并没有被完全遮挡，仍然是可见状态， 不可见：当前活动被完全遮挡 活动状态 运行状态（当前处于栈顶的活动） 暂停状态（活动不再处于栈顶，但仍然可见） 停止状态（活动不再处于栈顶，并且完全不可见） 销毁状态（活动从返回栈中移除） 活动的生存期Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节 onCreate(): 会在活动第一次被创建时调用，完成一些初始化操作，如加载布局、绑定事件 onStart(): 在活动由不可见变为可见的时候调用 onResume(): 在活动准备好和用户进行交互的时候调用，此时活动一定处于返回栈的栈顶，并处于运行状态 onPause(): 在系统准备去启动或者恢复另一个活动的时候用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用 onStop(): 在活动完全不可见时调用。如果启动的新活动是一个对话框式的活动，那么只有onPause()会得到执行，而onStop()不会执行，因为对话框式的活动不会完全遮挡住上一个活动 onDestroy(): 在活动被销毁之前调用，之后活动的状态将变成销毁状态 onRestart(): 在活动由停止状态变为运行状态之前调用，即活动被重新启动 以上7个方法，除了onRestart()方法，其他都是两两相对的，从而将活动分为3中生存期： 完整生存期：活动在onCreate()方法和onDestroy()方法之间所经历的，即从初始化到释放内存 可见生存期：从onStart()到onStop(),活动对于用户来说都是可见的，即使无法进行交互，即从资源加载到资源释放 前台生存期：从onResume()到onPause()，此时的活动都是运行态，可以和用户交互的，我们平时看到和接触最多的就是出于这个状态下的活动 活动生存期图 简单demo实现从MainActivity分别跳转到activity2和activity3并返回，其中activity3是dialog主题，观察Mainactivity的声明周期 Mainactivity中复写了上面的那些生命周期方法 其中activity3在注册页面配置为对话框主题 1234 &lt;activity android:name=".activity.ThirdActivity" android:theme="@style/Theme.AppCompat.Dialog"&gt; &lt;!-- 使用Dialog主题--&gt;&lt;/activity&gt; 主活动布局 主活动启动 log输出： 从主活动跳转到activity2 log输出： 从activity2返回 log输出： 从主活动跳转到activity3 log输出： 可以清楚的看到 ，这里只调用了onPause ，而没有继续调用onStop,与上面圈出来的跳转到activity2的log不同，因为activity3 是对话框式，并没有完全遮挡主活动,所以没有调用onStop 从activity3返回 log打印： 结束主活动，返回桌面 log打印： 活动被回收了咋办？当活动进入停止态，即执行了onStop()，是可能被系统回收的。回收了之后，如果BACK到之前的活动，系统就会重新onCreate()-&gt;onStart()-&gt;onResume()，而不是onRestart()-&gt;onStart()-&gt;onResume()。 如果真的系统真的onCreate()了，那么原活动的临时数据就会丢失！ 所以Activity又提供了一个onSaveInstanceState()的回调方法来解决临时数据得不到保存的问题。 onSaveInstanceState()会携带一个Bundle类型的参数，Bundle提供了一系列的方法保存数据，比如putString()和putInt()等，其第一个参数是键值，第二个参数是数据。比如MainActivity要保存数据，可以重写这个： 123456@Overridepublic void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) &#123; super.onSaveInstanceState(outState, outPersistentState); String tempData = "这里是你刚刚输入的数据"; outState.putString("key", tempData);&#125; 取值的之后直接从onCreate()中的Bundle取值 12345678910protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState!=null)&#123; String tempData = savedInstanceState.getString("key"); Log.d(TAG, tempData); &#125; ...&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Intent简单的数据传递]]></title>
    <url>%2F2019%2F10%2F08%2F5-Intent%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[简单的数据传递 实现在activity1中启动activity2，并传递数据到activity2 123456789101112131415//activity1 发送数据:public void onClick(View v) &#123; String data = "我是FirstActivity传递过去的数据"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //使用putExtra()方法来传递数据，形式为常见的 key-value 形式 intent.putExtra("extra_data", data); startActivity(intent);&#125;//activity2 取出数据:public void onClick(View v) &#123; Intent intent = getIntent(); //getIntent()方法获取到用于启动activity2的Intent String Data = intent.getStringExtra("extra_data"); //getStringExtra()方法获取传过来的字符串内容 Toast.makeText(SecondActivity.this, Data, Toast.LENGTH_SHORT).show();&#125; 返回数据给上一个活动实现从activity1跳转到activity2，再返activity1，同时activity2向activity1返回数据，返回后activity1接收 activity2结束后返回activity1，会回调activity1的onActivityResult方法，因此需要在activity1中复写这个方法 123456789101112131415161718192021222324252627282930313233//activity1: binding.btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent,1); //接收2个参数 第二个为resquestCode 用于区分不同的activity来源 &#125;&#125;);//activity1 中复写 onActivityResult，接收三个参数 requestCode(对应activity1中startActivityForResult(intent,1)第二个参数), resultCode(对应activity2中的setResult(RESULT_OK,intent)的第一个参数), intent@Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; //根据requestCode来区分是哪一个activity返回来的数据 case 1: if (resultCode == RESULT_OK) &#123; String str = data.getStringExtra("key"); Toast.makeText(this, str, Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125;//activity2：secondBinding.btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(); intent.putExtra("key","我是页面2返回的数据"); setResult(RESULT_OK,intent); finish(); &#125;&#125;); requestCode: 请求码，对应你在startActivityForResult(Intent intent, int requestCode)中传入requestCode，该参数的作用是让你在有多个activity返回结果时，能判断是哪一个activity返回。 setResult()方法向上一个活动返回数据，第一个参数为resultCode,第二个为Intent resultCode一般取RESULT_OK(-1)或RESULT_CANCELED(0) 修改通过按back返回键并回传数据在activity2中复写onBackPressed()方法 1234567@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return", "通过按键返回SecondActivity的数据"); setResult(RESULT_OK, intent); finish();&#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Intent学习]]></title>
    <url>%2F2019%2F10%2F08%2F4-Intent%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概述Intent(意图，目的)，用于在活动(activity)之间穿梭，分为显式Intent和隐式Intent 显式Intent1234public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //比较简单，第二个参数为要跳转到的页面 startActivity(intent);&#125; 隐式Intent隐式Intent并未明确指出启动哪一个活动，而是通过action和category等信息，让系统分析出让哪个Intent启动 比如采用隐式的方式从activity1启动activity2 1234567//修改AndroidManifest.xml配置文件，在SecondActivity中添加&lt;intent-filter&gt;的两行内容：&lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.day01_empty.ACTION_START"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在&lt;action/&gt;标签指明了当前活动可以响应的action:&quot;com.example.day01_empty.ACTION_START&quot; 而&lt;category/&gt;包含了附加信息，指明当前活动能响应的Intent可能带有category 只有&lt;action/&gt;和&lt;category&gt;中的内容同时匹配Intent中指定的action和category时，该活动才能响应该Intent。x 在activity1中进行跳转 123456public void onClick(View v) &#123; // Intent intent = new Intent(FirstActivity.this, SecondActivity.class); //显式 Intent intent = new Intent("com.example.day01_empty.ACTION_START"); //隐式，与上面的action内容一致 startActivity(intent);&#125;//无需传递category的原因是，这里的category是默认的，会自动传 action和category每个Intent只能指定一个action，但却能指定多个category，使用addCategory()方法添加 12345678910111213public void onClick(View v) &#123; Intent intent = new Intent("com.example.day01_empty.ACTION_START"); intent.addCategory("com.example.day01_empty.my_category"); //添加category startActivity(intent);&#125;// 注意，添加了新的category后，要实现从页面1跳转到页面2，则需要对页面二的注册信息进行修改，新添加一个category标签，否则会报错，提示没有活动响应Intent//activity2的注册信息修改如下：&lt;intent-filter&gt; &lt;action android:name="com.example.day01_empty.ACTION_START"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="com.example.day01_empty.my_category"/&gt; //新添加的category&lt;/intent-filter&gt; 隐式Intent的更多用法用系统浏览器打开URL指定action是Intent.ACTION_VIEW,这是Android的一个内置动作。对应配置文件的常量值是android.intent.action.VIEW,然后通过Intent.setData()方法将Uri.parse()解析的Uri对象传递进去 12345public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("http://bilibili.com")); startActivity(intent);&#125; 系统拨号指定Intent的action是Intent.Action_DIAL，也是内置动作指定协议是tel，号码是10086，经过Uri.parse()解析后传入setData() 12345public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse("tel:10086")); startActivity(intent);&#125; 进阶用法可以在&lt;intetent-filter&gt;标签中再添加一个&lt;data&gt;标签，用来精确指定当前活动能响应的数据类型。配置下列内容： android:scheme：指定数据协议 android:host：指定主机名 android:port：指定端口号 android:path：指定之后的内容 android:mimeType：指定处理的数据类型，允许通配符 例如修改activity2的注册信息，使得activity2可以响应系统拨号 1234567 &lt;activity android:name=".activity.SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.DIAL"/&gt; &lt;!--在xml中用android.intent.action... 来使用系统内置的action--&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="tel"/&gt; &lt;!--添加一个data标签，指定协议为tel拨号协议--&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 这样的话，再次运行上面的拨号那个例子，系统拨号和页面2都会做出响应，供我们来选择，如下图]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 简单菜单]]></title>
    <url>%2F2019%2F10%2F08%2F3-%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[创建菜单首先在res目录下新建一个menu文件夹，再在menu下建立菜单资源文件，如下图 编写菜单内容用&lt;item&gt;&lt;/item&gt;项来创建菜单子项 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/add_item" android:title="添加"/&gt; &lt;item android:id="@+id/remove_item" android:title="移除"/&gt;&lt;/menu&gt; 在activity中添加并使用需要复写两个方法 : 1.onCreateOptionsMenu()方法 12345@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); //inflate方法接收两个参数，第一个是我们刚才创建的menu文件,第二个参数直接使用该方法的menu参数 return true; //返回true表示允许创建的菜单显示出来 &#125; 2.onOptionsItemSelected()方法 123456789101112@Override public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; //根据菜单子项的id来选择 case R.id.add_item: Toast.makeText(this,"点击了add",Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this,"点击了remove",Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125;]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android项目结构概述]]></title>
    <url>%2F2019%2F10%2F08%2FAndroid%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[项目结构示意图 结构简单分析 .gradle .idea 目录： 自动配置的文件 app 目录：代码、资源等内容都在这个文件夹下 build 目录：编译时自动生成 libs目录：存放第三方jar包 src目录：源码目录 androidTest目录：自动化测试用的 main目录：工作目录，通常只管这个目录下的文件 java目录：写代码的目录，activitivity.java文件就在里面 res目录：放资源的目录 drawable放图片 layout放布局 values放字符串 mipmap放应用图标(h，m,xh等对应不同分辨率) AndroidManifest.xml文件：整个项目的配置文件，四大组件都在这注册，添加权限声明等 test目录：Unit Test测试使用 .gitnore文件：版本控制使用 app.iml文件：AS自动生成的 build.gradle文件：gradle脚本构建文件 proguard-rules.pro文件：代码混淆用的，防止app被破解 gradle目录：包含gradle wrapper的配置文件 .gitgnore 文件：版本控制相关 build.gradle文件：构建gradle的全局脚本文件 gradle.properties文件：配置gradle的全局配置文件 gradlew gradlew.bat文件：执行gradle命令的文件，bat文件是windows系统用的 HelloWorld.iml文件：别管，AS自动生成的文件 local.properties文件：指定本机Android SDK路径，通常自动生成 settings.gradle文件：指定引入的模块 主要文件分析AndroidManifest.xml123456789101112&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; //表示对MainActivity这个活动进行注册，没注册不能用。其中&lt;action android:name="android.intent.action.MAIN" /&gt;和&lt;category android:name="android.intent.category.LAUNCHER" /&gt;//表示这个活动是项目的主活动，也是最先启动的活动。 资源引用布局文件通过R.layout.activity_main来引用，那其他资源如何引用呢？比如HelloWorld这个字符串，它的资源文件是strings.xml： 123&lt;resources&gt; &lt;string name="app_name"&gt;HelloWorld&lt;/string&gt;&lt;/resources&gt; 代码中引用：R.string.app_name xml中引用：@string/app_name 同样的，如果是图片资源就将string替换为drawable，图标则是mipmap，布局文件就是layout androidStudio 配置文件分析外层build.gradle文件123456789101112131415161718192021//这个文件是自动生成的buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.5.3' &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;//repositories&#123;&#125;中声明了jcenter()，这是一个代码托管仓库，声明了这个就能引用jcenter的开源项目了。还声明了goole()，这是google自有的仓库。 //dependencies中使用classpath声明了一个Gradle插件，用来表示这是个Android项目而不是C++或其他项目。 内层builld.gradle文件1234567891011121314151617181920212223242526272829apply plugin: 'com.android.application'android &#123; compileSdkVersion 29 buildToolsVersion "29.0.2" defaultConfig &#123; applicationId "com.example.helloworld" minSdkVersion 15 targetSdkVersion 29 versionCode 1 versionName "1.0" testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'androidx.appcompat:appcompat:1.0.2' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.0' androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'&#125; 第一行应用了一个插件，一般选两个值： com.android.application：表示这是个应用程序模块 com.android.library：表示这是个库模块，只能依附于别的应用程序模块运行 第三行android{}配置项目构建的属性： compileSdkVersion指定编译的版本，29代表用Android 10的SDK编译 buildToolsVersion指定构建工具的版本，有最新的AS会提示 defaultConfig{}细节配置 applicationId指定包名 minSdkVersion指定最低兼容版本，15表示Android4.0 targetSdkVersion数字越大会启用一些新功能，比如权限控制等 versionCode项目版本号 versionName项目版本名 buildTypes{}指定生成安装文件的配置 release{}正式版安装文件的配置 minifyEnabled指定是否代码混淆 proguardFiles指定混淆的规则文件 proguard-android-optimize.txtSDK目录下，项目通用混淆规则 proguard-rules.pro当前项目根目录下，当前项目的特有混淆规则 debug{}测试版安装文件的配置，通常忽略不写 dependencies{}:指定当前项目的所有依赖关系 第一行：fileTree：本地依赖 第二三行：远程依赖：androidx.appcompat域名部分，appcompat组名，1.0.2是版本名。Gradle会先检查本地是否已经有此库的缓存，如果没有就会联网下载 最后三行用来测试用例，暂时用不到。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android概述]]></title>
    <url>%2F2019%2F10%2F08%2F1-Android%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Android系统架构（自底向上） Linux内核层：Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如蓝牙驱动，WIFI驱动等 系统运行库层：这一层通过一些c/c++库来为Android系统提供了主要的特性支持，如数据库支持，浏览器内核支持，同时，这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java来编写Android应用 应用框架层：提供了构建应用程序时可能用到的各种API 应用层：所有安装在手机上的app都在这一层 Android的版本 在Android10之前的版本都是以甜点命名(据了解，仅仅是寻找可以为Android冠名的甜点的名称就给Android团队带来了不少的困难),因此，从Android10开始，结束以甜点命名，用简单的数字命名。 下面图为AndroidStudio中，各版本号、版本名和API级别的示意图 Android应用开发特色 四大组件 活动（Activity）：所有Android程序的门面 服务（Service）：在后台默默运行 广播接收器（Broadcast Receiver）：允许你用应用接收来自各处的广播消息，如电话、短信等，也可向外发出广播消息 内容提供器（Content Provider）：应用程序之间共享数据，如读取电话簿联系人 丰富的系统控件 SQLite数据库 强大的多媒体 地理位置定位]]></content>
      <categories>
        <category>第一行代码</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助知乎Matisse图片选择库仿微信发布动态通过加号添加图片]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%80%9F%E5%8A%A9%E7%9F%A5%E4%B9%8EMatisse%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%BA%93%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%8F%91%E5%B8%83%E5%8A%A8%E6%80%81%E9%80%9A%E8%BF%87%E5%8A%A0%E5%8F%B7%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[先上结果展示 code知乎Matisse库需要的配置 引入依赖（这里是全部用到的依赖）12345678/*添加依赖*/ implementation &apos;com.zhihu.android:matisse:0.5.2-beta4&apos; implementation &apos;com.github.bumptech.glide:glide:4.9.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.9.0&apos; implementation &apos;com.github.tbruyelle:rxpermissions:0.10.2&apos; implementation &apos;androidx.recyclerview:recyclerview:1.0.0&apos; implementation &apos;com.jakewharton:butterknife:10.2.0&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:10.2.0&apos; 2.配置FileProvider ，在Android Manifest当中的Application节点下添加FileProvider12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ccc.matisse&quot;&gt; &lt;!--添加权限声明--&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;&gt;&lt;/uses-permission&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加provider--&gt; &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;com.ccc.matisse&quot; /这里一般用包名就可以不强求，但要和activity中的一致 android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepaths&quot;&gt;&lt;/meta-data&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 然后在Res文件下创建xml文件夹，然后创建filepaths.xml 3.创建GlideLoadEngine1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.ccc.util;import android.content.Context;import android.graphics.drawable.Drawable;import android.net.Uri;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.bumptech.glide.Priority;import com.bumptech.glide.request.RequestOptions;import com.zhihu.matisse.engine.ImageEngine;public class GlideLoadEngine implements ImageEngine &#123; @Override public void loadThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri) &#123; Glide.with(context) .asBitmap() // some .jpeg files are actually gif .load(uri) .apply(new RequestOptions() .override(resize, resize) .placeholder(placeholder) .centerCrop()) .into(imageView); &#125; @Override public void loadGifThumbnail(Context context, int resize, Drawable placeholder, ImageView imageView, Uri uri) &#123; Glide.with(context) .asBitmap() // some .jpeg files are actually gif .load(uri) .apply(new RequestOptions() .override(resize, resize) .placeholder(placeholder) .centerCrop()) .into(imageView); &#125; @Override public void loadImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri) &#123; Glide.with(context) .load(uri) .apply(new RequestOptions() .override(resizeX, resizeY) .priority(Priority.HIGH) .fitCenter()) .into(imageView); &#125; @Override public void loadGifImage(Context context, int resizeX, int resizeY, ImageView imageView, Uri uri) &#123; Glide.with(context) .asGif() .load(uri) .apply(new RequestOptions() .override(resizeX, resizeY) .priority(Priority.HIGH) .fitCenter()) .into(imageView); &#125; @Override public boolean supportAnimatedGif() &#123; return true; &#125;&#125; 看结构 其他代码不详细贴了 直接去demo看吧点击下载demo Code]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Matisse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis自动提交问题]]></title>
    <url>%2F2019%2F08%2F04%2Fmybatis%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4openSession()%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题关于这个mybatis的自动提交和手动提交问题，在这个学期，自己做数据库项目时，就遇到过，当时可能比较急，没有顺手把这个问题记录下来，结果今晚写东西的时候再次遇到了（躲得了初一，躲不过十五），还好我脑子里还有点印象，大体知道问题所在，现在赶紧记录下来，防止出现类似错误。 问题描述大体意思是：假设我要往一个user表里插入一个新用户 eclipse（或idea）上显示插入没问题，可是打开mysql查看，就是没插入进去。这里就涉及到Mybatis修改数据的提交问题。 开启自动提交去看MyBatis的源代码可以发现 openSession() 方法有带参数为 autoCommit 的布尔值，也就是是否自动提交可以手动控制的。 当openSession(true),即括号内为true的时候，mybaits是可以自动提交修改后的数据的，这样上面提到的问题就会解决 当openSession(),即括号内为空（或false），为手动提交，需要最后调用 session.commit() 来完成数据更新操作。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio快速处理编译运行compileDebugJavaWithJavac问题]]></title>
    <url>%2F2019%2F08%2F01%2FcompileDebugJavaWithJavac%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述compileDebugJavaWithJavac是什么，从字面上看就是在debug调试的执行javac命令，编译器遇到不能解析的内容而抛出的异常，上面一大片报红，很难定位错误的原因在哪里。 解决方案在Terminal框内输入执行下面的命令能快速找到原因，会将出现错误的地方都显示出来 1gradlew compileDebugJavaWithJavac 如下图：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android快速注解框架Butterknife简单使用]]></title>
    <url>%2F2019%2F07%2F31%2FAndroid%E5%BF%AB%E9%80%9F%E6%B3%A8%E8%A7%A3%E6%A1%86%E6%9E%B6Butterknife%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介Butterknife中文又名黄油刀,是 J神JakeWharton开源的一款Android视图的字段和方法绑定快速注解框架.也是Android开发中比较常用的一款快速注解框架了,避免了不断的重复findViewById,在各种场合下快速绑定view的多种事件,大大提高了开发的效率.优点：1、强大的View绑定和Click事件处理功能，简化代码，提升开发效率2、方便的处理Adapter里的ViewHolder绑定问题3、运行时不会影响APP效率，使用配置方便4、代码清晰，可读性强 …… 配置使用在项目的app目录下的build.gradle中的dependencies中添加如下代码依赖12345dependencies &#123; implementation &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;&#125; Warning(很重要)注：1.使用ButterKnife修饰的方法和控件，不能用private or static 修饰，否则会报错。2.ButterKnife.bind(this)必须在初始化绑定布局文件之后,否则会报错3.在Fragment中需要在视图销毁时解绑Butterknife,否则会造成内存泄漏. 简单用法实例在Activity中绑定ButterKnife1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.butter) Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @OnClick(R.id.butter) public void onClick()&#123; Log.e(&quot;111111&quot;,&quot;11111&quot;); Toast.makeText(this, &quot;绑定单个view事件&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 在Fragment中绑定ButterKnife123456789101112131415161718192021public class ExampleFragment extends Fragment &#123; private Unbinder unbinder;//先声明一个Unbinder对象 @BindView(R.id.example) Button example; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = View.inflate(getContext(),R.layout.fragment_example,null); unbinder = ButterKnife.bind(this,view); return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind();//视图销毁时必须解绑 &#125;&#125; 在Adapter的ViewHolder中绑定Butterknife12345678910111213141516171819202122232425262728@NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.recy_dynamic_state_item,parent,false); MyViewHolder myViewHolder = new MyViewHolder(itemView);//此处将view传入 itemView.setOnClickListener(this); return myViewHolder; &#125;public class MyViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.iv_photo) SimpleDraweeView simpleDraweeView; @BindView(R.id.tv_title) TextView tvTitle; @BindView(R.id.tv_detail) TextView tvDetail; @BindView(R.id.date) TextView date; @BindView(R.id.avatar_user) SimpleDraweeView avatarUser; @BindView(R.id.username) TextView userName; public MyViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this,itemView);//此处进行绑定 &#125;&#125; 具体用例绑定View：1.单个控件id注解： @BindView（）12@BindView(R.id.example) Button example; 2.多个控件id注解： @BindViews（）12@BindViews(&#123;R.id.butter,R.id.butter1,R.id.butter2&#125;) List&lt;Button&gt; buttons; 绑定资源文件1.绑定string 字符串：@BindString()12@BindString(R.string.app_name) //绑定资源文件中string字符串 String name; 2.绑定array数组：@BindArray()1234567891011&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;开眼视频&lt;/string&gt; &lt;string-array name=&quot;weather&quot;&gt; &lt;item&gt;高温&lt;/item&gt; &lt;item&gt;低温&lt;/item&gt; &lt;item&gt;阴天&lt;/item&gt; &lt;item&gt;雨天&lt;/item&gt; &lt;item&gt;晴天&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 12@BindArray(R.array.weather) //绑定string资源里面array数组 String [] weathers ; 3.绑定颜色值：@BindColor()12@BindColor( R.color.colorPrimary) //绑定color文件中颜色值 int colorPrimary; 4.绑定Bitmap：@BindBitmap()12@BindBitmap(R.mipmap.ic_launcher) Bitmap bitmap; 5.其他资源绑定:12345678910@BindBool(R.bool.is_tablet) boolean isTablet; //绑定boolean@BindFont(R.font.comic_sans) Typeface comicSans; //绑定字体文字@BindDimen(R.dimen.horizontal_gap) int gapPx //绑定尺寸@BindDimen(R.dimen.horizontal_gap) float gap; //绑定尺寸@BindAnim(R.anim.fade_in) Animation fadeIn; //绑定动画@BindDrawable(R.drawable.placeholder) Drawable placeholder;//绑定Drawable 绑定监听事件1.单个控件点击事件1234@OnClick(R.id.butter) public void onClick()&#123; Toast.makeText(this, &quot;绑定单个view事件&quot;, Toast.LENGTH_SHORT).show(); &#125; 2.多个控件同一点击事件1234@OnClick(&#123;R.id.share_wechat,R.id.share_moments,R.id.share_weibo&#125;) public void onClick()&#123; Toast.makeText(this, &quot;多个控件同一点击事件&quot;, Toast.LENGTH_SHORT).show(); &#125; 3.多个控件点击事件1234567891011121314@OnClick(&#123;R.id.share_wechat,R.id.share_moments,R.id.share_weibo&#125;) public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.share_wechat: sharePlatform(Wechat.NAME); break; case R.id.share_moments: sharePlatform(WechatMoments.NAME); break; case R.id.share_weibo: sharePlatform(SinaWeibo.NAME); break; &#125; &#125; 4.绑定控件长按事件：@OnLongClick( )12345@OnLongClick( R.id.button1 ) //给 button1 设置一个长按事件public boolean onLongClick ()&#123; Toast.makeText(this, &quot;is a long click&quot;, Toast.LENGTH_SHORT).show(); return true ;&#125; 5.其他事件绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//选中，选中取消@OnCheckedChanged(R.id.example) public void onChecked(boolean checked) &#123; Toast.makeText(this, checked ? &quot;Checked!&quot; : &quot;Unchecked!&quot;, Toast.LENGTH_SHORT).show();&#125;//软键盘的功能按键@OnEditorAction(R.id.example)public boolean onEditorAction(KeyEvent key) &#123; Toast.makeText(this, &quot;Pressed: &quot; + key, Toast.LENGTH_SHORT).show(); return true; &#125;//焦点改变@OnFocusChange(R.id.example) public void onFocusChanged(boolean focused) &#123; Toast.makeText(this, focused ? &quot;Gained focus&quot; : &quot;Lost focus&quot;, Toast.LENGTH_SHORT).show(); &#125;//Item长按，返回true则可以拦截onItemClick@OnItemLongClick(R.id.example_list) public boolean onItemLongClick(int position) &#123; Toast.makeText(this, &quot;Long clicked position &quot; + position + &quot;!&quot;, Toast.LENGTH_SHORT).show(); return true; &#125;//Item点击事件@OnItemClick(R.id.example_list) public void onItemClick(int position) &#123; Toast.makeText(this, &quot;Clicked position &quot; + position + &quot;!&quot;, Toast.LENGTH_SHORT).show(); &#125;//Item被选择事件@OnItemSelected(R.id.example_list) public void onItemSelected(int position) &#123; Toast.makeText(this, &quot;Selected position &quot; + position + &quot;!&quot;, Toast.LENGTH_SHORT).show(); &#125;//EditText里面的文本变化事件@OnTextChanged(R.id.example) public void onTextChanged(CharSequence text) &#123; Toast.makeText(this, &quot;Text changed: &quot; + text, Toast.LENGTH_SHORT).show(); &#125;//页面改变事件@OnPageChange(R.id.example_pager) public void onPageSelected(int position) &#123; Toast.makeText(this, &quot;Selected &quot; + position + &quot;!&quot;, Toast.LENGTH_SHORT).show(); &#125;//触摸事件@OnTouch(R.id.example)public boolean onTouch() &#123; Toast.makeText(this, &quot;Touched!&quot;, Toast.LENGTH_SHORT).show(); return false; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea2018版本导出war包（其他版本仅供参考）]]></title>
    <url>%2F2019%2F07%2F31%2Fidea2018%E5%AF%BC%E5%87%BAwar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[注这篇文章是转载的，在网上看了几篇idea导出war包的文章，只有这一篇真正的好用，看的其他的你抄我，我抄你，还都是错的，笑死我了。 原地址 idea2018版本导出war包 进入项目的Project Structure界面，进行如下4步操作 有的可能会没有第4步的选项，没关系不影响。 通过上述4步操作后，进入如下界面注：1.修改war包的名称（根据实际情况）；2.如果出现WEB-INF文件夹则删除，否则不做操作；3.创建META-INF文件（必须,下一步会创建）。 选择如下的路径创建META-INF文件，IDEA会自动创建该文件 在操作完上面3大步骤后，进入如下界面，进行如图所示的操作注：这里必须要进行Put into Output Root操作（非常重要，否则相关jar包不能进行发布） 执行完Put into Output Root操作后，war包的目录结构如下注：也可能该界面不会出现META-INF文件夹，但是在webapp目录下一定有该文件夹。 至此，导出war包的准备工作已经完成，下面进行编译，在Build菜单下选择Make Project选项 Make成功后，继续在Build菜单栏下，选择Build Artifacts…选项 在弹出的菜单栏中进行Build操作或根据实际需求进行其他操作 OKOK，到目前为止，web项目已经被导出为war包，并且war包中的目录结构也是正确的（网上的很多操作导出的war包文件目录都有问题），至于war包的具体位置，根据第2步中设置的导出目录为准。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidstudio使用阿里云仓库提高依赖加载速度]]></title>
    <url>%2F2019%2F07%2F30%2FAndroidstudio%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[大概我们在使用一些第三方框架时，需要在项目中添加相应的依赖，默认添加依赖时从jcenter()这个仓库下载东西的速度非常慢，只要我们改用阿里云的仓库就可以大大提高加载速度。 操作只需要在项目的build.gradle(不是app目录下的那个build.gradle，是外面那个)中加入下面的代码123maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; &#125; 加入位置如图，然后同步项目即可。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给APP设置一个启动图]]></title>
    <url>%2F2019%2F07%2F29%2FAPP%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[~~ APP的启动图很常见，我们在打开一些app的时候经常先出现一张图(或是广告之类的),过了几秒后才会进入系统相关主页面，这篇就记录一下简单的启动图的处理。 .1.在你的app项目里新建一个Activity，命名为 SplashActivity，相应的创建对应的布局文件 activity_splash.xml. .2.将准备的图片放到mimmap包下，将上面的布局文件背景引用为这张图片12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.SplashActivity&quot; android:background=&quot;@mipmap/img_01&quot;&gt; //background属性来设置图片&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; .修改SplashActivity中的代码如下123456789101112131415161718192021public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); Thread myThread=new Thread()&#123;//创建子线程 @Override public void run() &#123; try&#123; sleep(3000);//使程序休眠3秒,即3秒后进入系统页面 Intent it=new Intent(getApplicationContext(),MainActivity.class);//启动MainActivity startActivity(it); finish();//关闭当前活动 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;; myThread.start();//启动线程 &#125;&#125; .修改配置文件AndroidManifest中的代码，将我们创建的 SplashActivity 设置为首个启动活动。很简单，标签中的内容从MainActivity活动中拿到SplashActivity中即可。123456789&lt;activity android:name=&quot;.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;/activity&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp上传文件至本地指定位置后台用servlet处理]]></title>
    <url>%2F2019%2F07%2F23%2Fandroid%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%90%8E%E5%8F%B0%E7%94%A8servlet%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[大概这里我弄了上传图片当做例子 目录结构 这里这几个jar包自己导入就行，第三个是一个大神写的框架，直接搜就能搜到 Android代码：HttpUtil.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HttpUtil &#123; public static Platform mPlatform=Platform.get(); public static void upLoadSingleFile(File file,String url)&#123; Log.i(&quot;filePath&quot;,file.getAbsolutePath()); Log.i(&quot;fileName&quot;,file.getName()); if(file.exists())&#123; OkHttpClient okHttpClient=new OkHttpClient.Builder().connectTimeout(10, TimeUnit.SECONDS).build(); //MediaType为全部类型 final MediaType mediaType=MediaType.parse(&quot;application/octet-stream&quot;); //根据文件类型，将File装进RequestBody中 RequestBody fileBody=RequestBody.create(mediaType,file); //将fileBody添加进MultipartBody final RequestBody requestBody=new MultipartBody.Builder() .addFormDataPart(&quot;file&quot;,file.getName(),fileBody) .build(); //Request请求对象 Request request=new Request.Builder() .post(requestBody) .url(url) .build(); Call call=okHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; mPlatform.execute(new Runnable() &#123; @Override public void run() &#123; Log.i(&quot;error&quot;,&quot;错误 &quot;); &#125; &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; ResponseBody responseBody=null; responseBody=response.body(); final String info = responseBody.string(); mPlatform.execute(new Runnable() &#123; @Override public void run() &#123; Log.i(&quot;success&quot;,info); &#125; &#125;); &#125; &#125;); &#125;else&#123; Log.i(&quot;error&quot;,&quot;文件不存在！&quot;); &#125; &#125;&#125; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class MainActivity extends AppCompatActivity &#123; private Button button; //选择图片按钮 private Button button2;//上传按钮 String fileurl=&quot;&quot;; //声明一个权限数组 String[] permissions = new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE&#125;; List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;(); private static final int PERMISSION_REQUEST = 1; private Platform mPlatform; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initPermission();//获取权限 mPlatform=Platform.get(); init(); &#125; private void init() &#123; //初始化按钮及其点击事件 button=findViewById(R.id.upload_activity_bt_img); button2=findViewById(R.id.btn_select); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.i(&quot;button&quot;,&quot;11111&quot;); uploadTextFile(); &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_PICK); //打开相册选择图片 intent.setType(&quot;image/*&quot;); startActivityForResult(intent,1); // 第二个参数是请求码 &#125; &#125;); &#125; //上传 private void uploadTextFile() &#123; Log.i(&quot;file&quot;,fileurl); //看一下路径是否正确 File file=new File(fileurl); //要请求的地址，testServlet下面会给出 String url=&quot;http://10.152.4.162:8080/upload/testServlet&quot;; HttpUtil.upLoadSingleFile(file,url); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case 1: // 请求码 fileurl=parseUri(data); Log.i(&quot;file&quot;,fileurl); break; default: &#125; &#125; //得到选中图片地址 public String parseUri(Intent data) &#123; Uri uri=data.getData(); String imagePath; // 第二个参数是想要获取的数据 Cursor cursor = getContentResolver().query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;, null, null, null); if (cursor == null) &#123; imagePath = uri.getPath(); &#125; else &#123; cursor.moveToFirst(); int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); imagePath = cursor.getString(index); cursor.close(); &#125; return imagePath; // 返回图片地址 &#125; //下面是动态申请权限，6.0后读写权限需要动态申请 private void initPermission()&#123; mPermissionList.clear(); /** * 判断哪些权限未授予 */ for (int i = 0; i &lt; permissions.length; i++) &#123; if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; mPermissionList.add(permissions[i]); &#125; &#125; /** * 判断是否为空 */ if (mPermissionList.isEmpty()) &#123; //未授予的权限为空，表示都授予了 &#125; else &#123; //请求权限方法 String[] permissions = mPermissionList.toArray(new String[mPermissionList.size()]);//将List转为数组 ActivityCompat.requestPermissions(MainActivity.this, permissions, PERMISSION_REQUEST); &#125; &#125; /** * 响应授权 * 这里不管用户是否拒绝，都进入首页，不再重复申请权限 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST: break; default: break; &#125; &#125; protected void onDestroy() &#123; super.onDestroy(); Handler handler=new Handler(Looper.getMainLooper()); handler.removeCallbacksAndMessages(null); &#125;&#125; 布局文件(很简单，就两个按钮)12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.activity.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/btn_select&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;选择文件&quot;/&gt; &lt;Button android:id=&quot;@+id/upload_activity_bt_img&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击上传&quot;/&gt;&lt;/LinearLayout&gt; 配置文件(不要忘了添加一下权限)123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; 本地服务器端######TestServlet.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@WebServlet(name = &quot;TestServlet&quot;,urlPatterns = &quot;/testServlet&quot;)public class TestServlet extends HttpServlet &#123; private ServletFileUpload mServletFileUpload; private void initUp() &#123; if (null == mServletFileUpload) &#123; File file = (File) getServletContext().getAttribute(&quot;javax.servlet.context.tempdir&quot;); mServletFileUpload = new ServletFileUpload(new DiskFileItemFactory( DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD, file )); mServletFileUpload.setFileSizeMax(1024L * 1024 * 100); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; System.out.println(&quot;开始处理请求。。。&quot;); initUp(); response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);//指定编码 Map&lt;String, List&lt;FileItem&gt;&gt; fileItemListMap = mServletFileUpload.parseParameterMap(request); for (Map.Entry&lt;String, List&lt;FileItem&gt;&gt; entry : fileItemListMap.entrySet()) &#123; List&lt;FileItem&gt; fileItemList = entry.getValue(); if (!fileItemList.isEmpty()) &#123; for (FileItem fileItem : fileItemList) &#123; if (!fileItem.isFormField()) &#123;//取非表单属性 ，也就是文件 String fileName = FilenameUtils.getName(new String(fileItem.getName().getBytes(), &quot;utf-8&quot;)); InputStream inputStream = fileItem.getInputStream(); File file = new File(&quot;D:/uploads&quot;, fileName); FileOutputStream fileOutputStream = new FileOutputStream(file); byte[] bytes = new byte[1024 * 8]; int len; while ((len = inputStream.read(bytes)) != -1) &#123; fileOutputStream.write(bytes, 0, len); fileOutputStream.flush(); &#125; fileOutputStream.close(); PrintWriter writer = response.getWriter(); writer.print(fileName + &quot; ----&gt; ok!!!!!&quot;);//成功 ，返回个响应 writer.flush(); &#125; &#125; &#125; &#125; System.out.println(&quot;请求处理结束。&quot;); &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 效果把手机模拟器里的 java路线.jpg 文件发送到服务器，经处理后保存到本地 D:\uploads 目录下]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动态申请权限]]></title>
    <url>%2F2019%2F07%2F23%2Fandroid%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[申请动态权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 //声明一个权限数组private String[] permissions = new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE&#125;;private List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;();//定义一个请求码private static final int PERMISSION_REQUEST = 1;//动态申请权限方法private void initPermission()&#123; mPermissionList.clear(); /** * 判断哪些权限未授予 */ for (int i = 0; i &lt; permissions.length; i++) &#123; if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; mPermissionList.add(permissions[i]); &#125; &#125; /** * 判断是否为空 */ if (mPermissionList.isEmpty()) &#123; //未授予的权限为空，表示都授予了 &#125; else &#123; //请求权限方法 String[] permissions = mPermissionList.toArray(new String[mPermissionList.size()]);//将List转为数组 //调用requestPermissions（）向系统申请权限 //该方法接收3个参数，第一个是activity实例，第二个是一个String数组，第三个是请求码 ActivityCompat.requestPermissions(MainActivity.this, permissions, PERMISSION_REQUEST); &#125; &#125; /** * 响应授权 * 这里不管用户是否拒绝，都进入首页，不再重复申请权限 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST: break; default: break; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5月份的一些零散点]]></title>
    <url>%2F2019%2F06%2F01%2F2019-6-11-5%E6%9C%88%E4%BB%BD%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ai,这个五月份来来回回搞了数据库和软工的项目，这两个都用Javaweb的一些知识写的，就当练手了，中间还参加准备了一个比赛，感觉没写多少东西，就简单的记录一下吧。 jsp 按钮点击跳转到servlet并传递变量值传递常量 id &lt;input type=&quot;submit&quot; name=&quot;Submit1&quot; value=&quot;选座&quot; onclick=&quot;window.location.href=&apos;test1?id=1&apos;&quot;/&gt; 传递变量 id &lt;input type=&quot;submit&quot; name=&quot;Submit2&quot; value=&quot;取消预约&quot; onclick=&quot;window.location.href=&apos;CancelyyServlet?h_id=&lt;%=h_id%&gt;&apos;&quot;/&gt; 在servlet页面 通过正常的 String id=request.getParameter(&quot;id&quot;); 接收即可 传递多个参数 用 &amp; 符号 eg:&lt;input type=&quot;submit&quot; name=&quot;Submit1&quot; value=&quot;预约&quot; onclick=&quot;window.location.href=&apos;ChangeHouseStateServlet?h_id=&lt;%=house.getH_id()%&gt;&amp;seat_id=&lt;%=house.getSeat_id()%&gt;&apos;&quot;/&gt; okttp请求时 response.body.string与toString 的区别1.toString(): This returns your object in string format.（以字符串的格式返回你的对象） 2. .string(): This returns your response。（返回你的response） 3. 正确写法： String responseText=response.body().string(); 网络权限 android.permission.INTERNET 不是危险权限 不需要动态申请阿里云服务器配置很蛋疼的问题配置阿里云服务器 按照步骤来 结果就是远程桌面连接不上 最后将端口号3389 改成了3399 连上了 MySQL修改登录密码先cmd打开命令行窗口，输入 mysql 进入mysql指令状态 ，然后 输入 SET PASSWORD FOR &apos;dbadmin&apos;@&apos;localhost&apos; = &apos;newpasswd2&apos;; 使用SET PASSWORD语句更改dbadmin用户帐户的密码。 推荐一个在线 java 反编译工具将 .class 反编译成 .java java在线反编译工具 jsp中 session简单用法传递time HttpSession session=request.getSession(); session.setAttribute(&quot;time&quot;, time); javaweb项目中文件的路径问题（蛋疼）参照index.jsp 在webContent文件夹下的就是主路径 localhost:8080/yysystem/index.jsp 像访问index.jsp就直接项目名+index.jsp 如果在webContent 下建立了一个 jsp文件夹 里面有home.jsp 那么访问的时候就是 localhost:8080/yysystem/jsp/home.jsp 此时，若想从home.jsp中跳转到 index.jsp ，要注意，这里index.jsp位于目前位置home.jsp的上一级路径，所以写路径时要写 ../ 例如：&lt;input type=&quot;button&quot; value=&quot;退出系统&quot; name=&quot;exit&quot; onclick=&quot;window.location.href=&apos;../index.jsp&apos;&quot;/&gt; 访问包下的servlet也是同理 &lt;form action=&quot;../HouseServlet&quot; method=&quot;post&quot;&gt; filter 过滤&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 这样写就是过滤掉webContent/jsp文件夹下的所有文件 *jsp 这样写是过滤所有以.jsp结尾的 mysql 模糊查询SELECT username FROM post WHERE post_content LIKE &apos;%dnf%&apos; %表示由零个或多个字符组成的字符串 在post表中查询 post_content中含有 dnf 的username]]></content>
      <categories>
        <category>随心</category>
      </categories>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常学习编程中一些 异常和报错 的记录]]></title>
    <url>%2F2019%2F05%2F24%2F%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8%E5%92%8C%E6%8A%A5%E9%94%99%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[android本区域用来记录一下日常android操作中,出现的异常和报错。 rg.gradle.tooling.BuildException androidstudio生成.apk文件时，报错123456789101112131415161718192021222324Error:Internal error:org.gradle.tooling.BuildException: Could not execute build using Gradle distribution &apos;https://services.gradle.org/distributions/gradle-4.10.1-all.zip&apos;. ....... org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getSelectedArtifacts(DefaultConfiguration.java:1037) at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getFiles(DefaultConfiguration.java:1025) ... 43 moreCaused by: org.gradle.api.GradleException: Cannot find a version of &apos;com.android.support:support-annotations&apos; that satisfies the version constraints: Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support.test:runner:1.0.2&apos; --&gt; &apos;com.android.support:support-annotations:27.1.1&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support.test:runner:1.0.2&apos; --&gt; &apos;com.android.support.test:monitor:1.0.2&apos; --&gt; &apos;com.android.support:support-annotations:27.1.1&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; --&gt; &apos;com.android.support.test:runner:1.0.2&apos; --&gt; &apos;com.android.support:support-annotations:27.1.1&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-vector-drawable:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-v4:26.1.0&apos; --&gt; &apos;com.android.support:support-compat:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-v4:26.1.0&apos; --&gt; &apos;com.android.support:support-media-compat:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-v4:26.1.0&apos; --&gt; &apos;com.android.support:support-core-utils:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-v4:26.1.0&apos; --&gt; &apos;com.android.support:support-core-ui:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Dependency path &apos;xxxx:app:unspecified&apos; --&gt; &apos;xxx:loginmanager:unspecified&apos; --&gt; &apos;com.yanzhenjie:permission:1.0.7&apos; --&gt; &apos;com.android.support:appcompat-v7:26.1.0&apos; --&gt; &apos;com.android.support:support-annotations:26.1.0&apos; Constraint path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:support-annotations&apos; strictly &apos;26.1.0&apos; because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:support-annotations&apos; strictly &apos;26.1.0&apos; because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:support-annotations&apos; strictly &apos;26.1.0&apos; because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path &apos;xxx:app:unspecified&apos; --&gt; &apos;com.android.support:support-annotations&apos; strictly &apos;26.1.0&apos; because of the following reason: debugRuntimeClasspath uses version 26.1.0 at org.gradle.api.internal.artifacts.ivyservice.resolveengine.graph.builder.DependencyGraphBuilder.validateGraph(DependencyGraphBuilder.java:322) ... 59 more 解决方案： 123456从错误信息中我们可以推测出是support-annotations这个包重复了,有27.1.1的依赖和26.1.0的依赖,所以修改其中一个,让其保持一致,或者在app的 build.gradle 中将使用27.1.1的依赖关系去掉,将下面的引用注释掉:androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;]]></content>
      <categories>
        <category>异常和报错整理</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android端获取Tomcat服务器端json数据并通过listview显示]]></title>
    <url>%2F2019%2F05%2F14%2Fandroid%E7%AB%AF%E8%8E%B7%E5%8F%96Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[大体描述：大体意思是用eclipse ee创建一个Javaweb项目,该项目能从MySQL数据库中获取user表的数据，将数据封装成json格式，将此项目发布到本地Tomcat服务器，在android端获取刚才的json数据，并用listview显示。废话不多说下面直接开始。 Tomcat服务器端很简单，建立一个servlet用来处理数据，再建一个数据库工具类，我这里是DatabaseUtil.java，不要忘记servlet在web.xml中需要注册。 项目结构： code:ServletDemo1.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.servlet.demo;import java.io.IOException;import java.sql.ResultSet;import java.sql.SQLException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSON;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import util.DatabaseUtil;public class ServletDemo1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletDemo1() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sql = &quot;select * from user&quot;; JSONArray jsonArray=new JSONArray(); //json数组 try &#123; ResultSet result = DatabaseUtil.query(sql); while (result.next()) &#123; JSONObject jObject=new JSONObject(); //json临时对象 jObject.put(&quot;id&quot;, result.getInt(1)); jObject.put(&quot;username&quot;, result.getString(2)); jObject.put(&quot;password&quot;, result.getString(3)); jsonArray.add(jObject); //将封装好的json对象放入json数组 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; String jsondata=jsonArray.toString(); //将json数组转换成字符串，供下面返回给android端使用 //System.out.println(jsondata); //本地测试用 response.getWriter().append(jsondata).flush(); &#125;&#125; DatabaseUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Statement;public class DatabaseUtil &#123; private static Connection mConnection; private static Connection getConnection() &#123; if (mConnection == null) &#123; String url = &quot;jdbc:mysql://localhost:3306/mybatis&quot;; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); mConnection = (Connection) DriverManager.getConnection(url, &quot;root&quot;, &quot;123&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return mConnection; &#125; //这里只用了查询操作 public static ResultSet query(String querySql) throws SQLException &#123; Statement stateMent = (Statement) getConnection().createStatement(); return stateMent.executeQuery(querySql); &#125; public static void closeConnection() &#123; if (mConnection != null) &#123; try &#123; mConnection.close(); mConnection = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; web.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ConnectTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.demo.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 本地测试结果在浏览器地址栏里输入（端口啥的自己改了的话用自己的，不多说）1http://localhost:8080/ConnectTest/ServletDemo1 测试结果： android端也比较简单，有两个activity，在mainactivity中有个button按钮，点击后跳转到第二个activity,我这里是ListActivity ,在listactivity中显示获取到的json数据。 用到的jar包 类 布局 code工具类 HttpUtil123456789101112package util;import okhttp3.OkHttpClient;import okhttp3.Request;public class HttpUtil &#123; public static void sendOkHttpRequest(String address,okhttp3.Callback callback)&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder().url(address).build(); client.newCall(request).enqueue(callback); &#125;&#125; 实体类 User123456789101112131415161718192021222324package com.ccc.connecttest.activity;public class User &#123; private int id; private String username; private String password; public User(int id,String username, String password)&#123; this.id=id; this.username=username; this.password=password; &#125; public int getId() &#123; return id; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125;&#125; 适配器 UserAdapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ccc.connecttest.activity;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.TextView;import com.ccc.connecttest.R;import java.util.List;public class UserAdapter extends ArrayAdapter&lt;User&gt; &#123; private int resourceId; public UserAdapter(Context context, int resourceId, List&lt;User&gt; objects) &#123; super(context, resourceId,objects); this.resourceId=resourceId; &#125; @Override public View getView(int position, View convertView,ViewGroup parent) &#123; User user=getItem(position); View view; ViewHolder viewHolder; if(convertView==null)&#123; view= LayoutInflater.from(getContext()).inflate(resourceId,parent,false); viewHolder=new ViewHolder(); viewHolder.userid=(TextView)view.findViewById(R.id.tv_id); viewHolder.username=(TextView)view.findViewById(R.id.tv_username); viewHolder.userpassword=(TextView)view.findViewById(R.id.tv_password); view.setTag(viewHolder); //将viewHolder存储在view中 &#125;else&#123; view=convertView; viewHolder=(ViewHolder)view.getTag(); &#125; viewHolder.userid.setText(String.valueOf(user.getId())); viewHolder.username.setText(user.getUsername()); viewHolder.userpassword.setText(user.getPassword()); return view; &#125; static class ViewHolder&#123; TextView userid; TextView username; TextView userpassword; &#125;&#125; 显示的页面 ListActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.ccc.connecttest.activity;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.ListView;import com.ccc.connecttest.R;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import java.util.ArrayList;import java.util.List;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Response;import util.HttpUtil;public class ListActivity extends AppCompatActivity &#123; private List&lt;User&gt; userList=new ArrayList&lt;&gt;(); private ListView listView; private String json_url=&quot;http://192.168.2.133:8080/ConnectTest/ServletDemo1&quot;;//本地Tomcat刚才测试的地址 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); queryFromServer(json_url); //处理取得数据 listView=findViewById(R.id.lv); UserAdapter adapter = new UserAdapter(ListActivity.this, R.layout.user, userList); listView.setAdapter(adapter); &#125; private void queryFromServer(String json_url) &#123; HttpUtil.sendOkHttpRequest(json_url, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.i(&quot;error&quot;,&quot;出现错误！&quot;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseText=response.body().string(); try &#123; JSONArray jsonArray=new JSONArray(responseText); for(int i=0;i&lt;jsonArray.length();i++)&#123; JSONObject jsonObject=jsonArray.getJSONObject(i); String id=jsonObject.getString(&quot;id&quot;); String username=jsonObject.getString(&quot;username&quot;); String password=jsonObject.getString(&quot;password&quot;); User user=new User(Integer.parseInt(id),username,password); userList.add(user); Log.i(&quot;user&quot;,&quot;添加了一个User&quot;); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 主页面 MainActivity123456789101112131415161718192021222324252627package com.ccc.connecttest.activity;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import com.ccc.connecttest.R;public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button=findViewById(R.id.btnSign); //点击跳转到显示页面 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, ListActivity.class)); &#125; &#125;); &#125;&#125; 配置 AndroidManifest.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ccc.connecttest&quot;&gt; &lt;!-- 千万不要忘了申请使用网络权限--&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个ListActivity不要忘记注册--&gt; &lt;activity android:name=&quot;.activity.ListActivity&quot;/&gt; &lt;/application&gt;&lt;/manifest&gt; 布局activity_main.xml: 123456789101112131415&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;Button android:layout_marginTop=&quot;200dp&quot; android:id=&quot;@+id/btnSign&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;获取&quot; /&gt;&lt;/LinearLayout activity_list.xml:123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ListView android:id=&quot;@+id/lv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/LinearLayout&gt; listview每一项适配文件： user.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;15dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_id&quot; android:text=&quot;1111&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:text=&quot;2222&quot; android:id=&quot;@+id/tv_username&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;TextView android:text=&quot;3333&quot; android:id=&quot;@+id/tv_password&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#d97e87&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 结果图 项目下载点击下载]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Tomcat服务器接收android端上传的数据]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%9C%AC%E5%9C%B0Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6android%E7%AB%AF%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[大体描述android端提交账号和密码，Tomcat服务器端会接收到，eclipse的控制台输出得到的账号和密码。 Tomcat服务器端先建立了一个javaweb项目，我这项目名是ConnectTest,然后在建立了一个包，在这个包下建立了一个servlet文件，我这命名为ServletDemo1。建立完servlet文件后，千万不要忘记在web.xml中注册，下面我将贴一下具体代码实现和项目结构。 项目结构超级简单： ServletDemo1.java12345678910111213141516171819202122232425262728293031package com.servlet.demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletDemo1() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取请求的数据，并向控制台输出 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;-----&gt; doPost username:&quot; + username + &quot; password:&quot; + password); &#125;&#125; web.xml也很简单就是对上面的那个servlet进行注册：123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;ConnectTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.demo.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; android端因为只是一个简单的例子，所以页面很简单，两个输入框，一个输入账号，一个输入密码，点击发送按钮后，账号和密码会提交到Tomcat服务器端，所以eclipse这边的Tomcat服务器控制台会输出账号和密码。 界面 项目结构这里只贴上java代码实现部分的结构，布局部分的默认就行： 可以看到建了两个包，一个client是存放线程类的，另外一个主界面类。 HttpThread.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.client;import android.util.Log;import java.io.IOException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;public class HttpThread extends Thread &#123; private String url; private String username; private String password; public HttpThread(String url, String username, String password)&#123; this.url=url; this.username=username; this.password=password; &#125; public void send() throws IOException &#123; //将username和password传给Tomcat服务器 url=url+&quot;?username=&quot;+username+&quot;&amp;password=&quot;+password; try &#123; Log.i(&quot;测试&quot;, &quot;start&quot;); //Log.i我用来测试调试的。 URL httpUrl=new URL(url); //获取网络连接 HttpURLConnection coon=(HttpURLConnection)httpUrl.openConnection(); //设置请求方法为Post coon.setRequestMethod(&quot;POST&quot;); //设置访问超时时间 coon.setReadTimeout(5000); //调用getInputStream方法后，服务端才会收到请求，并阻塞式地接收服务端返回的数据 coon.getInputStream(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125; public void run()&#123; super.run(); try &#123; send(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; MainActivity.java:1234567891011121314151617181920212223242526272829303132333435363738package com.example.connecttest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.example.client.HttpThread;public class MainActivity extends AppCompatActivity &#123; private EditText username; private EditText password; private Button signup; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); username=(EditText)findViewById(R.id.account); password=(EditText)findViewById(R.id.password); signup=(Button)findViewById(R.id.btnSign); signup.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(&quot;1111&quot;, &quot;1111111&quot;); onLogin(); Toast.makeText(MainActivity.this,&quot;success&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void onLogin() &#123; String url=&quot;http://192.168.2.133:8080/ConnectTest/ServletDemo1&quot;; new HttpThread(url,username.getText().toString().trim(),password.getText().toString().trim()).start(); &#125;&#125; AndroidManifest.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.connecttest&quot;&gt; &lt;!-- 申请权限--&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 布局 activity_main.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;EditText android:layout_marginTop=&quot;100dp&quot; android:id=&quot;@+id/account&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;请输入账号：&quot; android:background=&quot;#FCF2A4&quot;/&gt; &lt;EditText android:layout_marginTop=&quot;5dp&quot; android:id=&quot;@+id/password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;请输入密码：&quot; android:background=&quot;#FCF2A4&quot;/&gt; &lt;Button android:layout_marginTop=&quot;5dp&quot; android:id=&quot;@+id/btnSign&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;发送&quot; android:background=&quot;#67BAFD&quot;/&gt;&lt;/LinearLayout&gt; 效果 eclipse端输出：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis逆向工程]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[逆向工程？mybatis的一个主要的特点就是需要程序员自己编写sql，如果表太多的话，会很麻烦，所以mybatis官方提供了一个逆向工程，可以针对单表自动生成mybatis执行所需要的代码（包括mapper.xml、mapper.java、po..）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。 逆向工程的jar包下载点击下载逆向工程 mybatis-generator-core jar包 进去之后 点击那个 Download……就行，就是下图中圈出来的那个。 项目结构这里说一下，这是项目最终的结构了，在最初，只需要在 src 下面建立一个包，再在这个包下建立一个最后我们要运行的java文件即可，我这里是 GeneratorSqlmap.java ，那些com.mybatis.mapper和com.mybatis.po都是我们运行刚才的java文件后自动生成的，下面会说一下。 项目完整配置过程1导入所需jar包，大体就是在学mybatis时的那些jar包，如下图： 划线的是最重要的几个包，像第一个就是我们刚才下载的逆向工程核心包。 2在src下新建一个包，我这里建的是 com.mybatis.generator 包，再在这个包下建立一个用于最后运行的java文件，我这里是 GeneratorSqlmap.java ,具体代码会在下面贴上。 3在src下建立一个文件 log4j.properties ,这个就是我们学mybatis时用过的，直接拿过来用也行，但必须放在 src 下，不然运行项目后，会出现如下警告：123log4j:WARN No appenders could be found for logger (org.mybatis.generator.logging.LogFactory).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 4在项目下建立一个 generatorConfig.xml 文件，用于具体配置 5运行刚才创建的 GeneratorSqlmap.java 文件，就会看到src 下多了两个包，一个是mapper的包，一个是po的包 code:GeneratorSqlmap.java: 1234567891011121314151617181920212223242526272829303132333435363738package com.mybaits.generator;import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定逆向工程配置文件 File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; log4j.properties： 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n generatorConfig.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone = GMT&quot; userId=&quot;root&quot; password=&quot;123&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置，重要！！ --&gt; &lt;javaModelGenerator targetPackage=&quot;com.mybatis.po&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置，重要！！ --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.mybatis.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.mybatis.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt; &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 我这里只用了一个表，user 表： 最后完整的项目结构]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis和spring整合]]></title>
    <url>%2F2019%2F05%2F03%2Fmybatis-spring%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[简述Mybatis将一些琐碎的事交给Spring来处理（像数据库链接，配置等），自身更加注重sql语句本身 整合思路 需要spring来管理数据源信息。 需要spring通过单例方式管理SqlSessionFactory。 使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成） 持久层的mapper都需要由spring进行管理，spring和mybatis整合生成mapper代理对象。 集成的对象1.jar包集成(主要导入Mybatis的jar包、spring的jar包、Mybatis-spring整合包、mysql的相关jar包，c3p0数据库连接池相关jar包，如果使用Junit测试的话，还要导入Junit的jar包，我用了)。 2.配置文件集成(两大配置文件，mybatis的全局配置文件SqlMapConfig.xml和spring的核心配置文件applicationContext.xml)。 3.SqlSessionFactory集成。 4.Mapper接口集成。 结构图 编写applicationContext.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;&gt; &lt;!-- 加载 db.properties 中的参数设置，要引用db.properties中的参数，这句必须要有--&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 将数据库连接的操作交给spring，这里用的是c3p0连接池，需要导入c3p0的相关jar包--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的SqlSessionFactory，需要注入全局配置文件和连接池 --&gt; &lt;bean id=&quot;sqlSessionFactoryId&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;SqlMapConfig.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置批量mapper代理开发模式，这里就不能指定id了,而是通过引用具体的 mapper类名来获取mapper对象，进而操作函数--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.qqq.dao&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactoryId&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; dao设计–UserMapper.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.qqq.dao.UserMapper&quot;&gt; &lt;!-- 这里只是举例了查询的例子 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.qqq.domain.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserAll&quot; resultType=&quot;com.qqq.domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; dao设计–UserMapper.java 接口123456789package com.qqq.dao;import java.util.List;import com.qqq.domain.User;public interface UserMapper &#123; public User findUserById(int id); public List&lt;User&gt; findUserAll();&#125; 在SqlMapconfig.xml中加载UserMapper.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 如果mapper.xml和mapper.java接口在同一个目录，此处也可不用定义mappers --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/qqq/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 主体类–User.java123456789101112131415161718192021222324252627282930package com.qqq.domain;import javax.swing.Spring;public class User &#123; private int id; private String username; private int userage; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, userage=&quot; + userage + &quot;]&quot;; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getUserage() &#123; return userage; &#125; public void setUserage(int userage) &#123; this.userage = userage; &#125;&#125; db.properties1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMTjdbc.username=rootjdbc.password=123 log4j.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 测试类 Test1.java1234567891011121314151617181920212223package com.qqq.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.qqq.dao.UserMapper;import com.qqq.domain.User;public class Test1 &#123; //这里用了Junit 所以不能忘记加 @Test @Test public void testMultiMapper()&#123; String springxml=&quot;applicationContext.xml&quot;; ApplicationContext context=new ClassPathXmlApplicationContext(springxml); UserMapper userMapper=(UserMapper) context.getBean(&quot;userMapper&quot;); //查找id号为2的用户信息 User user=userMapper.findUserById(2); System.out.println(user); &#125;&#125; 数据库表 测试结果]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML特殊字符编码对照表]]></title>
    <url>%2F2019%2F04%2F24%2FHTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[HTML特殊字符编码对照表]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中限定类名和非限定类名]]></title>
    <url>%2F2019%2F04%2F24%2FJava%E4%B8%AD%E9%99%90%E5%AE%9A%E7%B1%BB%E5%90%8D%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E7%B1%BB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[限定类名，就是类名全称，带包路径的用点隔开，例如: java.lang.String。 非限定(non-qualified)类名也叫短名，就是我们平时说的类名，不带包的，例如：String。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis链接MySQL出现异常，URL报错]]></title>
    <url>%2F2019%2F04%2F24%2FMyBatis%E9%93%BE%E6%8E%A5MySql%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Exception大体类似于下面这种报错 answer原来是这样写：1&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT&quot;/&gt; 改成如下形式就对了(即将上面那种写法的 ； 分号 改成 &amp; amp ; )1&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone = GMT&quot;/&gt; analysis&amp;amp；只是&amp;在xml下的形式 HTML中常用的特殊字符： &lt; 小于 &amp;lt; &amp;#60; &gt; 大于 &amp;gt; &amp;#62; &amp; &amp;符号 &amp;amp; &amp;#38; &quot; 双引号 &amp;quot; &amp;#34; 更多的可以点击链接去查看： HTML特殊字符编码对照表]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MySql</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的存储和遍历]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[0.图 = 点 + 边 1.邻接矩阵表示12345678910 #define maxn 100typedef struct &#123; int no; //顶点编号 char data[maxn];//顶点的其他信息&#125;VertexType;typedef struct&#123; int edges[maxn][maxn]; //存放边的数组 int n, e; //顶点数，边数 VertexType vex[maxn][maxn]; //存放顶点数组&#125;MGraph; 2.邻接表表示12345678910111213typedef struct EdgeNode&#123; //边表结点 int adjvex; //该边的终点编号( 如u-&gt;v ，这里指的就是v的编号 ) int weight; //边的权值 struct EdgeNode *next; //指向下一条边的指针&#125;EdgeNode;typedef struct VextexNode&#123; char data; //顶点域，存储顶点信息 EdgeNode *firstedge; //边表头指针，指向连接的第一条边&#125;VextexNode, AdjList[maxn]; //AdjList是邻接表类型typedef struct&#123; AdjList adjList; //邻接表 int n, e; //图中顶点数和边数&#125;GraphAdjList; 附：用邻接表表示创建无向图(这里用的是头插法)：12345678910111213141516171819202122232425262728void CreateALGraph(GraphAdjList *Gp)&#123; int i, j, k; EdgeNode *pe; cout &lt;&lt; &quot;输入顶点数和边数(空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;numNodes &gt;&gt; Gp-&gt;numEdges; for (i = 0 ; i &lt; Gp-&gt;numNodes; i++) &#123; cout &lt;&lt; &quot;输入顶点信息：&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;adjList[i].data; Gp-&gt;adjList[i].firstedge = NULL;/* 将边表置为空表 */ &#125; for (k = 0; k &lt; Gp-&gt;numEdges; k++)/* 建立边表 */ &#123; cout &lt;&lt; &quot;输入边(u,v)的顶点序号i,j&quot;&lt;&lt; endl; cin &gt;&gt; i &gt;&gt; j; pe = (EdgeNode *)malloc(sizeof(EdgeNode)); pe-&gt;adjvex = j; //边的终点编号为j // 将pe的指针指向当前顶点上指向的结点 pe-&gt;next = Gp-&gt;adjList[i].firstedge; Gp-&gt;adjList[i].firstedge = pe;/* 将当前顶点的指针指向pe */ //因为是无向图，所以下面还要以i作为边的终点 pe = (EdgeNode *)malloc(sizeof(EdgeNode)); pe-&gt;adjvex = i; pe-&gt;next = Gp-&gt;adjList[j].firstedge; Gp-&gt;adjList[j].firstedge = pe; &#125;&#125; 3.深度优先遍历注：INF是无穷，visited[] 是全局数组，用来标记点是否被访问，初始置为0 1.邻接矩阵：12345678910void DFS(MGraph g, int v)&#123; int w; cout &lt;&lt; v; //输出当前访问的结点 visited[v] = 1; //将已访问的置为1 for (w = 0; w &lt; g.n; w++)&#123; //找当前顶点v的所有邻接顶点 if (g.edges[v][w] != 0 &amp;&amp; g.edges[v][w] != INF&amp;&amp;visited[w] == 0)&#123; //找顶点v未访问过的邻接点w DFS(g, w); &#125; &#125;&#125; 2.邻接表：123456789101112void DFS(GraphAdjList *g, int v)&#123; EdgeNode *p; cout &lt;&lt; v; //输出当前访问的点 visited[v] = 1; //已访问的置为1 p = g-&gt;adjList[v].firstedge; //p指向顶点v的第一个边邻接点 while (p != NULL)&#123; if (visited[p-&gt;adjvex] == 0)&#123; DFS(g, p-&gt;adjvex); //若p-&gt;adjvex顶点未访问，递归访问它 &#125; p = p-&gt;next; //p指向顶点v的下一个邻接点 &#125;&#125; 4.广度优先遍历(层次)1.邻接矩阵：12345678910111213141516171819202122void BFS(MGraph g, int v)&#123; queue&lt;int&gt; qu; //定义一个队列 qu int visited[maxn]; //定义一个存放结点打的访问标志的数组 int w, i; memset(visited, 0, sizeof(visited)); //初始化访问标志数组 cout &lt;&lt; v; //输出当前访问的顶点编号 visited[v] = 1; //已访问的置为1 qu.push(v); //v进队 while (!qu.empty())&#123; //队列不空时循环 w = qu.front(); qu.pop(); //出队队首顶点 for (int i = 0; i &lt; g.n; i++)&#123; //若当前相邻顶点i未被访问 if (g.edges[v][i] != 0 &amp;&amp; g.edges[v][i] != INF&amp;&amp;visited[i] == 0)&#123; cout &lt;&lt; i; //访问相邻顶点 visited[i]=1; //已访问的置为1 qu.push(i); //该顶点进队 &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 2.邻接表：12345678910111213141516171819202122232425void BFS(GraphAdjList* g, int v)&#123; EdgeNode *p; queue&lt;int&gt; qu; //定义一个队列 qu int visited[maxn]; //定义一个存放结点打的访问标志的数组 int w, i; memset(visited, 0, sizeof(visited)); //初始化访问标志数组 cout &lt;&lt; v; //输出当前访问的顶点编号 visited[v] = 1; //已访问的置为1 qu.push(v); //v进队 while (!qu.empty())&#123; //队列不空时循环 w = qu.front(); qu.pop(); //出队队首顶点w p = g-&gt;adjList[w].firstedge; //找顶点w的第一个邻接点 while (p != NULL)&#123; //若当前相邻的顶点未被访问 if (visited[p-&gt;adjvex] == 0)&#123; cout &lt;&lt; p-&gt;adjvex; //访问相邻顶点 visited[p-&gt;adjvex] = 1; //已访问的置为1 qu.push(p-&gt;adjvex); //该顶点进队 &#125; p = p-&gt;next; //找顶点w的下一个邻接点 &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列求哈夫曼编码长度]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AD%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[problem：数据结构实验之二叉树六：哈夫曼编码 code:123456789101112131415161718192021222324252627282930313233343536 #include&lt; iostream&gt; #include&lt; queue&gt; #include&lt; functional&gt;using namespace std;int main()&#123; char s[1000]; int t[500]; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; while (cin &gt;&gt; s)&#123; int sum1, sum2 = 0; memset(t, 0, sizeof(t)); int len = strlen(s); sum1 = len * 8; for (int i = 0; i &lt; len; i++)&#123; t[s[i]]++; //将字符串中的字符转化为ASCII码中的编号存入数组中，并且记录个数 &#125; for (int i = 0; i &lt; 500; i++)&#123; if (t[i] != 0)&#123; q.push(t[i]); &#125; &#125; while (!q.empty())&#123; //每次取出最小的两个也就是队列最开始两个，相加产生的新数据存入队列中 int x1 = q.top(); q.pop(); if (!q.empty())&#123; //这里要判断一下，上一步取出x1后队列是不是空了,避免在空的队列中操作 int x2 = q.top(); q.pop(); int x3 = x1 + x2; sum2 += x3; q.push(x3); &#125; &#125; printf(&quot;%d %d %.1lf\n&quot;, sum1, sum2, 1.0 * sum1 / sum2); &#125; return 0;&#125; 还有一道类似的搬东西的题合并果子之哈夫曼树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树概念平衡二叉树建立在二叉排序树的基础上，目的是使二叉排序树的平均查找长度更小，即让各结点的深度尽可能小，因此，树中每个结点的两棵子树的深度不要偏差太大。平衡二叉树的递归定义：平衡二叉树是一棵二叉树，其可以为空，或满足如下2个性质：①左右子树深度之差的绝对值不大于1。②左右子树都是平衡二叉树。 平衡因子的概念：结点的平衡因子 = 结点的左子树深度 — 结点的右子树深度。若平衡因子的取值为-1、0或1时，该节点是平衡的，否则是不平衡的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt;using namespace std;typedef int ElementType;typedef struct AVLNode&#123; ElementType Data; struct AVLNode* Left; struct AVLNode* Right;&#125;*AVLTree;//计算树高int GetHeight(AVLTree A)&#123; int HL, HR, MaxH; if (A == NULL) return 0; else&#123; HL = GetHeight(A-&gt;Left); HR = GetHeight(A-&gt;Right); MaxH = max(HL, HR); return (MaxH + 1); &#125;&#125;//左单旋（左左型LL：需顺时针转,即插入的结点在不平衡结点的左孩子的左子树上，导致根节点的平衡因子由1变为2）AVLTree SingleLeftRotation(AVLTree A)&#123; AVLTree B = A-&gt;Left; A-&gt;Left = B-&gt;Right; B-&gt;Right = A; return B;&#125;//右单旋（右右型RR：需逆时针转,即插入的结点在不平衡结点的右孩子的右子树上，导致根节点的平衡因子由1变为2）AVLTree SingleRightRotation(AVLTree A)&#123; AVLTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; return B;&#125;//左-右双旋（左右型LR：即插入的结点在不平衡结点的左孩子的右子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleLeftRightRotation(AVLTree A)&#123; A-&gt;Left = SingleRightRotation(A-&gt;Left); return SingleLeftRotation(A);&#125;//右-左双旋（右左型RL：即插入的结点在不平衡结点的右孩子的左子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleRightLeftRotation(AVLTree A)&#123; A-&gt;Right = SingleLeftRotation(A-&gt;Right); return SingleRightRotation(A);&#125;//插入结点AVLTree Insert(AVLTree A, ElementType X)&#123; if (!A)&#123; A = (AVLTree)malloc(sizeof(struct AVLNode)); A-&gt;Data = X; A-&gt;Left = A-&gt;Right = NULL; &#125; else if (X&lt;A-&gt;Data)&#123; A-&gt;Left = Insert(A-&gt;Left, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == 2) if (X&lt;A-&gt;Left-&gt;Data) A = SingleLeftRotation(A);//左左型(LL)需要右旋转 else A = DoubleLeftRightRotation(A);//左右型(LR)需要左右旋转 &#125; else if (X&gt;A-&gt;Data)&#123; A-&gt;Right = Insert(A-&gt;Right, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == -2) if (X&gt;A-&gt;Right-&gt;Data) A = SingleRightRotation(A);//右右型(RR)需要左旋转 else A = DoubleRightLeftRotation(A);//右左型(RL)需要右左旋转 &#125; return A;&#125;int main()&#123; AVLTree A = NULL; int n, t; cin &gt;&gt; n; for (int i = 0; i&lt;n; i++)&#123; cin &gt;&gt; t; A = Insert(A, t); &#125; //输出了根节点 cout &lt;&lt; A-&gt;Data &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用maven在eclipse中创建java web项目]]></title>
    <url>%2F2019%2F04%2F02%2Fmaven%E5%88%9B%E5%BB%BAjavaweb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.菜单-&gt;File-&gt;New-&gt;Other-&gt;Maven-&gt;Maven Project 点击next 2. 点击next 3.这个界面，选择 maven-archetype-webapp 。 点击next 4.这个界面，填写自己项目的信息。 5.现在得到的项目会出现红叉，即报错原因有两个： 没有java源代码目录 index.jsp报错 6.创建java源代码目录在上一步的截图中可以发现，没有地方存放java源文件，这个时候就需要按照如下步骤做：右键项目-&gt;属性-&gt;Java Build Path-&gt;Libraries-&gt;Edit-&gt;Workspace defaultJRE(jdk8)-&gt;Finish如图： 会出现下图效果： 7.通过pom.xml添加servlet jar包这个时候，还存在index.jsp会 报错的问题。 这个问题的解决办法是添加servlet.jar包。 双击pom.xml，出现pom专有的编辑页面。点击OverView右边的Dependencies可以看到里面有一个默认存在的junit然后点击Add，弹出选择窗口在中间 Enter GroupId, artifactId or sha1 prefix or pattern(*)…. 这个地方输入servlet，下面就会出来被搜索到的servlet jar包选中它，并点击ok 注: Scope要选择compile，表示编译期间要用到。 如下图：(前两个带星号的自己随便填个东西就行) 8.保存更改，项目报错消除了 9.运行 输出 helloworld！接下来只需像一般的javaweb项目那样，将这个项目添加到Tomcat里运行即可。 在浏览器输入： 1http://localhost:8080/j2ee 关于在pom.xml文件中添加依赖包时搜索不到servlet包的问题1.菜单-&gt;Window-&gt;preferences-&gt;maven 选中Download respository…… 那一项 2.菜单-&gt;Window-&gt;Show View-&gt;Other-&gt;Maven-&gt;Maven Repositories选中 Global Repositories 下的 alimaven 点击右键选择 Full Index Enabled (如果maven仓库已修改为阿里云仓库，就会有alimaven),点击后 eclipse 会自动开始下载所有的 jar 包，下载完成后，再右键 Local Respositories 选择 Rebuild Index 即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在eclipse中集成maven]]></title>
    <url>%2F2019%2F04%2F02%2Feclipse%E4%B8%AD%E9%9B%86%E6%88%90maven%2F</url>
    <content type="text"><![CDATA[1.集成mavenEclipse EE版本是已经集成好MAVEN的了，无需额外手动集成可以去官网下一个eclipse ee 2.设置maven路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;Installations-&gt;add-&gt;Directory…选择你的maven安装后的文件夹 把原来的那个低版本maven删除掉，如果有的话 3.设置仓库路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;User Settings-&gt;Global Settings 和 User Settings都使用我们在上篇文章中自己设置的仓库下的 setting.xml 文件。 点击一下Reindex,确保 local Repository为我们设置的本地仓库位置 1D:\maven-repository]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F04%2F01%2Fmaven%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录一下Maven的下载和环境变量的配置 下载官方下载地址 我下载的时候最新版本如下，去上面的官网点击即可下载。 配置环境变量1.右键我的电脑-属性-高级系统设置-环境变量-系统变量-Path-编辑-新建。 这里填入你下载的 maven 目录下 bin 目录的地址。 2.使用win+r(或右键开始菜单，选择运行), 然后输入cmd 打开命令行，输入 1mvn -v 若出现下图所示的，则配置成功。 maven仓库的相关修改仓库，顾名思义是用来存放项目需要的jar包的，maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。maven仓库的默认位置是在 C:\Users\你的用户名.m2\repository 因为刚下载和配置好并没有运行过，所以C盘中会看不到这个目录。因为我们需要的各种jar包都是放在这的，所以放在c盘感觉并不好，接下来就更改一下仓库的位置，放到D盘中。 在D盘中新建一个文件夹叫 maven-repository ，在你的maven安装目录下的conf文件夹下找到 setting.xml 文件，参考我的 D:\apache-maven-3.6.0\conf\setting.xml,打开找到下图的内容将 localRepository 这对标签内填上刚才创建的maven-repository文件夹的地址。 然后将这个 setting.xml 文件复制一个，粘贴到刚才的maven-repository文件夹下，以后新建项目maven自动将下载的依赖包放到该文件夹下。 使用阿里云仓库maven 会默认从maven官方提供的服务器下载jar包。而官方服务器在国外，被墙了，下的贼慢。 为了快速下载相关jar包，可以使用国内maven 阿里云的下载地址 打开刚才创建的 maven-repository文件夹下的 setting.xml 文件 找到 mirrors 这对标签，在里面添加如下代码即可。123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 如下图：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树 SDUTOJ 2482]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91SDUTOJ2482%2F</url>
    <content type="text"><![CDATA[problem:点击跳转到题目 understand:学了二叉树，得知先序和中序遍历或者后序和中序遍历都可以唯一确定一颗二叉树，所以这里我们采用求先序序列进行比较的方法。因为二叉排序树的中序遍历一定是递增序列都一样，所以此题只需比较每棵树的先序序列即可。 code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int z[11];int ccount;void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree(int a[])&#123; tree t = NULL; int key; for (int i = 0; i &lt; 9; i++)&#123; Inserttree(t, a[i]); &#125; return t;&#125;//先序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; z[ccount++] = t-&gt;data; traveltree(t-&gt;left); traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; int n; while (cin &gt;&gt; n&amp;&amp;n != 0)&#123; ccount = 0; string s = &quot;&quot;; cin &gt;&gt; s; int b[11],c[11],d[11]; //下面是 输入的第一串字符 构建二叉排序树并先序遍历后 得到的数组 c for (int i = 0; i &lt;s.length();i++)&#123; b[i] = s[i] - &apos;0&apos;; &#125; t=CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; c[i] = z[i]; //前序遍历 &#125; // for (int i = 0; i &lt; n; i++)&#123; t = NULL; ccount = 0; cin &gt;&gt; s; //下面是 输入的要进行比较的字符串 构建二叉排序树并先序遍历后 得到的数组 d for (int i = 0; i &lt;s.length(); i++)&#123; b[i] = s[i] - &apos;0&apos;; &#125; t = CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; d[i] = z[i]; //前序遍历 &#125; //下面是比较两个树 先序遍历的结果 c和d ，相同则YES ，不同则NO int flag = 0; for (int i = 0; i &lt; s.length(); i++)&#123; if (c[i] != d[i])&#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; flag = 1; break; &#125; &#125; if (!flag)&#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[理解：二叉排序树或者是一颗空树，或者是具有下列性质的二叉树：(1):若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值 (2):若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值 (3):它的左、右子树也分别为二叉排序树 code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int n; //含有n个结点//插入void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree()&#123; tree t = NULL; int key; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; key; Inserttree(t, key); &#125; return t;&#125;//中序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; traveltree(t-&gt;left); cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;; traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; cin &gt;&gt; n; t = CreateTree(); traveltree(t); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的同构]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[附上题目链接：二叉树的同构 理解：只要确保每个节点和其左右孩子的结点相等，或者孩子交换之后相等就可以。只要每个结点都符合，那么整棵树自然从上到下就都符合。 code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt; #include&lt;cstdio&gt;using namespace std;const int maxn = 20;struct node&#123; char key; int left, right;&#125;tree1[maxn], tree2[maxn]; //构建一个结构体用来构建两个二叉树int n1, n2;void build_tree(struct node * tree, int n)&#123; int i; char s[2]; for (i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s; tree[i].key = s[0]; cin &gt;&gt; s; if (s[0] == &apos;-&apos;)&#123; tree[i].left = 11; //如果输入为 - 则置为一个非0到10的数 &#125; else&#123; tree[i].left = s[0] - &apos;0&apos;; //字符向数字转换 &#125; cin &gt;&gt; s; if (s[0] == &apos;-&apos;)&#123; tree[i].right = 11; &#125; else&#123; tree[i].right = s[0] - &apos;0&apos;; &#125; &#125;&#125;bool checkc(int i, int j)&#123; //检测key相同的两个结点的左右孩子是否相同或者交换后是否相同 if (tree1[tree1[i].left].key == tree2[tree2[j].left].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].right].key) &#123; return 1; &#125; if (tree1[tree1[i].left].key == tree2[tree2[j].right].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].left].key) &#123; return 1; &#125; return 0;&#125;bool check()&#123; int i, j; //找到key相同的结点 for (i = 0; i &lt; n1; i++)&#123; for (j = 0; j &lt; n2; j++)&#123; if (tree1[i].key == tree2[j].key)&#123; if (checkc(i, j))&#123; break; //孩子相同或者交换后相同继续下一个结点 &#125; else&#123; return 0; &#125; &#125; &#125; if (j == n2)&#123; return 0; //没找到 &#125; &#125; return 1; //整棵二叉树都符合条件&#125;int main()&#123; while (cin&gt;&gt;n1)&#123; build_tree(tree1, n1); cin&gt;&gt;n2; build_tree(tree2, n2); if (n2!=n1)&#123; cout &lt;&lt; &quot;No&quot;&lt;&lt;endl; &#125; else if (check())&#123; cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl; &#125; else&#123; cout &lt;&lt; &quot;No&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二叉树的深度，递归和非递归]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[递归： 123456789101112131415int high(Tree t)//求二叉树的高度&#123; int n,m; if(t==NULL) return 0; else &#123; n=high(t-&gt;lchild); //对左子树求高度 m=high(t-&gt;rchild); //对右子树求高度 if(n&gt;m) //高度为取两者中大的值+1 return n+1; else return m+1; &#125;&#125; 非递归（队列）：12345678910111213141516171819202122int high(Tree t)//求二叉树的高度&#123; int depth = 0; Tree p=NULL; queue&lt;Tree&gt; q; q.push(t); //根节点入队 while (!q.empty())&#123; depth++; //每到新的一层 高度+1 int width = q.size(); //求出本层的结点数 while (width--)&#123; //本层结点全部出队 p = q.front(); q.pop(); if (p-&gt;left)&#123; q.push(p-&gt;left); &#125; if (p-&gt;right)&#123; q.push(p-&gt;right); &#125; &#125; &#125; return depth;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定先序和中序序列,求后序序列]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%B1%82%E5%90%8E%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[要求：输入二叉树的先序遍历序列和中序遍历序列，输出该二叉树的后序遍历序列。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;//由先序序列s1[0···n-1]和中序序列s2[0···n-1]建立二叉链存储结构的二叉树//s1:先序遍历字符串 s2:中序遍历字符串 n:结点个数Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s1[0]; //根节点的值 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s2[k] == root)&#123; //在s2中查找 根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1 + 1, s2, k); //递归创建左子树 bt-&gt;rchild = creattree(s1 + k + 1, s2 + k + 1, n - k - 1); //递归创建右子树 return bt;&#125;//后序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); cout &lt;&lt; t-&gt;value; &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： ABDCEF BDAECF 输出： DBEFCA 附：已知中序后序求先序代码：12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s2[n-1]; //这里和上面的不一样 后序遍历的最后一个元素才是 根节点 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s1[k] == root)&#123; //在中序序列中查找根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1, s2, k); bt-&gt;rchild = creattree(s1 + k + 1, s2 + k, n - k - 1); //注意这里的范围 s2+k 画一画就明白了 return bt;&#125;//先序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; cout &lt;&lt; t-&gt;value; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： dbgeafc dgebfca 输出： abdegcf]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(4)]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%80%82%E9%85%8D%E5%99%A8%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下适配器容器1.stack（栈容器）实现头文件：&lt; stack&gt; 概述： 它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。例如，以下语句指定myst栈的底层容器为vector： 1stack&lt;string,vector&lt;string&gt; &gt; myst; //第2个参数指定底层容器为vector 主要成员函数： empty()：判断栈容器是否为空 size()：返回栈容器中实际元素个数 push(elem)：元素elem进栈 top()：返回栈顶元素 pop()：元素出栈 注意：stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 演示代码： #include&lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); printf(&quot;栈顶元素: %d\n&quot;, st.top()); printf(&quot;出栈顺序: &quot;); while (!st.empty()) //栈不空时出栈所有元素 { printf(&quot;%d &quot;, st.top()); st.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 栈顶元素: 3 出栈顺序: 3 2 1 2.queue（队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 主要成员函数： empty()：判断队列容器是否为空。 size()：返回队列容器中实际元素个数。 front()：返回队头元素。 back()：返回队尾元素。 push(elem)：元素elem进队。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; qu; qu.push(1); qu.push(2); qu.push(3); printf(&quot;队头元素: %d\n&quot;, qu.front()); printf(&quot;队尾元素: %d\n&quot;, qu.back()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.front()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 1 队尾元素: 3 出队顺序: 1 2 3 3.priority_queue（优先队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。比如：对于 int 类型的元素，priority_queue 默认元素值越大越优先。 主要成员函数： empty()：判断优先队列容器是否为空。 size()：返回优先队列容器中实际元素个数。 push(elem)：元素elem进队。 top()：获取队头元素。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; qu; qu.push(3); qu.push(1); qu.push(2); printf(&quot;队头元素: %d\n&quot;, qu.top()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.top()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 3 出队顺序: 3 2 1 (可见是按照值的大小出队) 注： 优先队列默认是自动的从大到小排列，想要让它从小到大排列，可以包含头文件 &lt; functional&gt;,再如下形式声明即可 1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; //会对入队的元素从小到大排列]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(3)]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下关联容器1.set（集合容器）/ multiset（多重集容器）实现头文件：&lt; set&gt;概述： set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 insert()：插入元素 erase()：从容器删除一个或几个元素 clear()：删除所有元素 count(k)：返回容器中关键字k出现的次数 find(k)：如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值 upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素 lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;int&gt; s; //定义set容器s set&lt;int&gt;::iterator it; //定义set容器迭代器it s.insert(1); s.insert(3); s.insert(2); s.insert(4); s.insert(2); printf(&quot; s: &quot;); for (it = s.begin(); it != s.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); multiset&lt;int&gt; ms; //定义multiset容器ms multiset&lt;int&gt;::iterator mit; //定义multiset容器迭代器mit ms.insert(1); ms.insert(3); ms.insert(2); ms.insert(4); ms.insert(2); printf(&quot;ms: &quot;); for (mit = ms.begin(); mit != ms.end(); mit++) printf(&quot;%d &quot;, *mit); printf(&quot;\n&quot;); return 0; } 输出： s: 1 2 3 4 ms: 1 2 2 3 4 2.map（映射容器）/ multimap（多重映射容器）实现头文件：&lt; set&gt; 概述： map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。在map和multimap 中的key和value是一个pair类结构。pair类结构的声明形如： 1234struct pair&#123; T first; T second;&#125; map/multimap利用pair的&lt;运算符将所有元素即key-value对按key的升序排列，以红黑树的形式存储，可以根据key快速地找到与之对应的value（查找时间为O(log2n)）。map中不允许关键字重复出现，支持[]运算符；而multimap中允许关键字重复出现，但不支持[]运算符。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap) insert(elem)：插入一个元素elem并返回该元素的位置 clear()：删除所有元素 find()：在容器中查找元素 count()：容器中指定关键字的元素个数（map中只有1或者0） 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： 1.12map&lt;char,int&gt; mymap; //定义map容器mymap，其元素类型为pair&lt;char,int&gt;mymap[&apos;a&apos;] = 1; //或者mymap.insert(pair&lt;char，int&gt;(&apos;a&apos;,1) ); 2. #include&lt;iostream&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;char, int&gt; mymap; //定义map容器mymap mymap.insert(pair&lt;char, int&gt;(&apos;a&apos;, 1)); //插入方式1 mymap.insert(map&lt;char, int&gt;::value_type(&apos;b&apos;, 2)); //插入方式2 mymap[&apos;c&apos;] = 3; //插入方式3 map&lt;char, int&gt;::iterator it; for (it = mymap.begin(); it != mymap.end(); it++) printf(&quot;[%c,%d] &quot;, it-&gt;first, it-&gt;second); printf(&quot;\n&quot;); return 0; } 输出： [a,1] [b,2] [c,3]]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(2)]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A81%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下顺序容器1.vector(向量容器)实现头文件：&lt; vector&gt;定义方式：1234vector&lt;int&gt; v1; //定义元素为int的向量v1vector&lt;int&gt; v2(10); //指定向量v2的初始大小为10个int元素vector&lt;double&gt; v3(10,1.23); //指定v3的10个初始元素的初值为1.23vector&lt;int&gt; v4(a,a+5); //用数组a[0···4]共5个元素初始化v4 主要成员函数： empty(): 判断当前向量是否为空。 size(): 返回当前向量容器中的实际元素个数。 [ ]: 返回指定下标的元素。 reserve(n): 为当前向量容器预分配n个元素的存储空间。 capacity(): 返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 resize(n): 调整当前向量容器的大小，使其能容纳n个元素。 push_back(): 在当前向量容器尾部添加一个元素。 insert(pos,elem): 在pos位置插入元素elem，即将元素elem插入到迭代器指定的元素之前。 front(): 获取当前向量容器的第一个元素。 back(): 获取当前向量容器的最后一个元素。 erase(): 删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 clear(): 删除当前向量容器中的所有元素。 begin(): 该函数的两个版本返回iterator或const_iterator,引用容器的第一个元素。 end(): 该函数的两个版本返回返回iterator或const_iterator,引用容器的最后一个元素后面的一个位置。 rbegin(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的最后一个元素。 rend(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的第一个元素的前面一个位置。 最后两个是反向迭代。 演示代码： #include&lt;iostream&gt; #include&lt; vector&gt; using namespace std; int main(){ vector&lt;int&gt; myv; //定义vector容器myv vector&lt;int&gt;::iterator it;//定义myv的正向迭代器 it myv.push_back(1); //在myv的末尾添加元素 1 it = myv.begin(); //it迭代器指向开头元素 1 myv.insert(it, 2); //在it指向的元素之前插入元素 2 myv.push_back(3); //在myv的末尾添加元素 3 myv.push_back(4); //在myv的末尾添加元素 4 it = myv.end(); //it 迭代器指向元素4的后面 it--; //it 迭代器指向元素 4 myv.erase(it); //删除元素4 for (it = myv.begin(); it != myv.end(); it++){ cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } return 0; } 2.string(字符串容器)实现头文件：&lt; string&gt;定义方式：123456char cstr[]=&quot;China! Greate Wall&quot;; //C-字符串string s1(cstr); // s1:China! Greate Wallstring s2(s1); // s2:China! Greate Wallstring s3(cstr，7，11); // s3:Greate Wallstring s4(cstr，6); // s4:China!string s5(5，&apos;A&apos;); // s5:AAAAA 主要成员函数： empty()：判断当前字符串是否为空串 size()：返回当前字符串的实际字符个数。 length()：返回当前字符串的实际字符个数。 [idx]：返回当前字符串位于idx位置的字符，idx从0开始。 at(idx)：返回当前字符串位于idx位置的字符。 compare(const string&amp; str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 append(cstr)：在当前字符串的末尾添加一个字符串str。 insert(size_type idx，const string&amp; str) ：在当前字符串的idx处插入一个字符串str。 find(string &amp;s,size_type pos):从当前字符串中的pos位置开始查找字符串s的第一个位置，，找到后返回其位置，若没有找到返回-1。 replace(size_type idx,size_type len,costring&amp; str):将当前字符串中起始于idx的len个字符用一个字符串str替换。 substr(size_type idx,size_type len):返回当前字符串起始于idx的长度为len的字串。 clear():删除当前字符串中的所有字符。 erase():删除当前字符串中的所有字符。 erase(size_type idx):删除当前字符串从idx开始的所有字符。 erase(size_type idx,size_type len):删除当前字符串从idx开始的len个字符。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include &lt; iostream&gt; #include &lt; string&gt; using namespace std; int main(){ string s1 = &quot;&quot;, s2, s3 = &quot;Bye&quot;; s1.append(&quot;Good morning&quot;); //s1=&quot; Good morning&quot; s2 = s1; //s1=&quot; Good morning&quot; int i = s2.find(&quot;morning&quot;); //i=5 s2.replace(i, s2.length() - i, s3); //相当于s2.replace(5,7,s3) cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; endl; return 0; } 输出：s1：Good morning s2:Good Bye 3.deque(双端队列)实现头文件：&lt; deque&gt;定义方式：123456deque&lt;int&gt; dq1; //定义元素为int的双端队列dq1deque&lt;int&gt; dq2(10); //指定dq2的初始大小为10个int元素deque&lt;double&gt; dq3(10，1.23); //指定dq3的10个初始元素的初值为1.23deque&lt;int&gt; dq4(dq2.begin()，dq2.end()); //用dq2的所有元素初始化dq4 主要成员函数： empty()：判断双端队列容器是否为空队。 size()：返回双端队列容器中元素个数。 push_front(elem)：在队头插入元素elem。 push_back(elem)：在队尾插入元素elem。 pop_front()：删除队头一个元素。 pop_back()：删除队尾一个元素。 erase()：从双端队列容器中删除一个或几个元素。 clear()：删除双端队列容器中所有元素。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;deque&gt; using namespace std; void disp(deque&lt;int&gt; &amp;dq) //输出dq的所有元素 { deque&lt;int&gt;::iterator iter; //定义迭代器iter for (iter=dq.begin();iter!=dq.end();iter++) printf(&quot;%d &quot;,*iter); printf(&quot;\n&quot;); } int main() { deque&lt;int&gt; dq; //建立一个双端队列dq dq.push_front(1); //队头插入1 dq.push_back(2); //队尾插入2 dq.push_front(3); //队头插入3 dq.push_back(4); //队尾插入4 printf(&quot;dq: &quot;); disp(dq); dq.pop_front(); //删除队头元素 dq.pop_back(); //删除队尾元素 printf(&quot;dq: &quot;); disp(dq); return 0; } 输出： dq:3 1 2 4 dq:1 2 4.list(链表容器)实现头文件：&lt; list&gt;定义方式：1234list&lt;int&gt; l1; //定义元素为int的链表l1list&lt;int&gt; l2 (10); //指定链表l2的初始大小为10个int元素list&lt;double&gt; l3 (10，1.23); //指定l3的10个初始元素的初值为1.23list&lt;int&gt; l4(a，a+5); //用数组a[0..4]共5个元素初始化l4 主要成员函数： empty()：判断链表容器是否为空。 size()：返回链表容器中实际元素个数。 push_back()：在链表尾部插入元素。 pop_back()：删除链表容器的最后一个元素。 remove ()：删除链表容器中所有指定值的元素。 remove_if(cmp)：删除链表容器中满足条件的元素。 erase()：从链表容器中删除一个或几个元素。 unique()：删除链表容器中相邻的重复元素。 clear()：删除链表容器中所有的元素。 insert(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，n，elem)：在pos位置插入n个元素elem。 insert(pos，pos1，pos2)：在迭代器pos处插入[pos1，pos2)的元素。 reverse()：反转链表。 sort()：对链表容器中的元素排序。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include &lt;list&gt; using namespace std; void disp(list&lt;int&gt; &amp;lst) //输出lst的所有元素 { list&lt;int&gt;::iterator it; for (it = lst.begin(); it != lst.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); } int main() { list&lt;int&gt; lst; //定义list容器lst list&lt;int&gt;::iterator it, start, end; lst.push_back(5); //添加5个整数5,2,4,1,3 lst.push_back(2); lst.push_back(4); lst.push_back(1); lst.push_back(3); printf(&quot;初始lst: &quot;); disp(lst); it = lst.begin(); //it指向首元素5 start = ++lst.begin(); //start指向第2个元素2 end = --lst.end(); //end指向尾元素3 lst.insert(it, start, end); printf(&quot;执行lst.insert(it,start,end)\n&quot;); printf(&quot;插入后lst: &quot;); disp(lst); return 0; } 输出： 初始lst: 5 2 4 1 3 执行lst.insert(it,start,end) 插入后lst: 2 4 1 5 2 4 1 3]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(1)]]></title>
    <url>%2F2019%2F03%2F23%2Fc%2B%2BSTL%2F</url>
    <content type="text"><![CDATA[这篇大体介绍一下STL相关内容STL简介C++中已经实现了数据结构中的很多容器和算法，它们构成标准C++库的子集，即标准模板类库 (Standard Template Library).STL是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。 STL概述STL主要由container(容器)、algorithm(算法)和iterator(迭代器)三大部分构成，容器用于存放数据对象(元素)，算法用于操作容器中的数据对象，算法和容器之间的中介就是迭代器。 container(容器):简单的说一个stl容器就是一种数据结构，例如链表、栈和队列等，STL中都已经实现好了，在算法设计中可以直接使用它们。这篇下面会详细讲各个容器，另外一些哈希表容器hash_set,hash_map等，它们属于非标准STL容器，其功能可以用set,map代替。 algorithm(算法):stl的算法部分主要由头文件、和组成。stl提供了大约100个实现算法的模板函数。 iterator(迭代器):stl迭代器用于访问容器中的数据对象。每个容器都有自己的迭代器，只有容器自己知道如何访问自己的元素。迭代器像c/c++中的指针，算法通过迭代器来定位和操作容器中的元素。 常用STL容器STL容器很多，每一个容器就是一个类模板，大致分为顺序容器、适配器容器和关联容器3种类型。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找的分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找折半查找又称二分查找，它是一种效率较高的查找方法。但是折半查找要求查找序列中的元素是有序的，为了简单，假设序列是递增有序的。折半查找的基本思路：设 a[low···high] 是当前的查找区间，首先确定该区间的中点位置mid=(low+high)/2 (取下界);然后将待查的 k值 与 a[mid].key 比较： （1）若k==a[mid].key,则查找成功并返回该元素的物理下标 （2）若k&lt;a[mid],则由表的有序性可知 a[mid···high] 均大于k，因此表中若存在值 等于k的元素，则该元素必定位于 左子表 a[low···mid-1] 中，故新的查找区间 是左子表a[low···mid-1]。 （3）若k&gt;a[mid],则要查找的元素必定位于 右子表 a[mid+1···high] 中，故新的查找区间 是右子表a[mid+1···high]。 下一次查找是针对新的查找区间进行的。 因此可以从最初的查找区间a[0···n-1]开始，每经过一次与当前查找区间中点位置上的关键字比较就可以确定查找是否成功，不成功则当前的查找区间缩小一半。重复这一过程，直到找到关键字为K的元素，或者直到当前的查找区间为空（即查找失败）时为止。 代码实现12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;using namespace std;//折半查找int BinSearch(int a[], int low, int high, int k)&#123; int mid; if (low &lt;= high)&#123; //当前区间存在元素时 mid = (low + high) / 2; //求查找区间的中间位置 if (a[mid] == k)&#123; //找到了，直接返回其物理下标 mid return mid; &#125; if (a[mid] &gt; k)&#123; //当a[mid]&gt;k 时在a[low···mid-1]中递归查找 return BinSearch(a, low, mid - 1, k); &#125; else&#123; //当a[mid]&lt;k 时在a[mid+1···high]中递归查找 return BinSearch(a, mid + 1, high, k); &#125; &#125; else&#123; return -1; //找不到，错误处理 &#125;&#125;int main()&#123; int n = 10, i; int k = 6; //要找的值 int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; i = BinSearch(a, 0, n - 1, k); if (i &gt;= 0)&#123; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个元素值为k&quot;; &#125; return 0;&#125; 附：(非递归实现)12345678910111213141516int BinSearch(int a[], int n, int k)&#123; //在含有n个元素的数组a中查找 是否有值为K的元素 int low = 0, high = n - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (a[mid] == k)&#123; return mid; &#125; if (a[mid] &gt; k)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序的基本思想是首先将 a[0···n-1] 看成n个长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到n/k^2个长度为k^2的有序子表，如此反复进行下去，最后得到一个长度为n的有序表。若k=2，即归并是在相邻的两个有序子表中进行的，称为二路归并排序。若k&gt;2，即归并操作在相邻的多个有序子表中进行，则叫多路归并排序。我们仅讨论二路归并排序。分解—&gt;子问题求解—&gt;合并 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 #include&lt;iostream&gt;using namespace std;void display(int a[],int n)&#123; //输出数组元素 for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;//合并void Merge(int a[], int left, int mid, int right)&#123; int *temp = new int[right - left + 1]; //定义并初始化临时数组 int i = left; //左边序列指针 int j = mid + 1; //右边序列指针 int t = 0; //临时数组指针 while (i &lt;= mid&amp;&amp;j &lt;= right)&#123; //第一个子表（左）和第二个子表（右）均没有扫描完时循环，左边子表和右边子表均从自己的第1个元素开始向右扫描 if (a[i] &lt;= a[j])&#123; temp[t++] = a[i++]; //如果第一个子表的当前元素值小，放入temp中 &#125; else&#123; temp[t++] = a[j++]; //如果第二个子表的当前元素值小，放入temp中 &#125; &#125; while (i &lt;= mid)&#123; //如果第一个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[i++]; &#125; while (j &lt;= right)&#123; //如果第二个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[j++]; &#125; t = 0; while (left &lt;= right)&#123; //将temp中的元素全部复制到原数组中 a[left++] = temp[t++]; &#125; delete[]temp; //释放临时空间&#125;//归并排序void MergeSort(int a[],int left,int right)&#123; if (left &lt; right)&#123; //子序列有两个或两个以上元素 int mid = (left + right) / 2; MergeSort(a, left, mid); //左边归并排序，使得左子序列有序 MergeSort(a, mid + 1, right); //右边归并排序，使得右子序列有序 Merge(a, left, mid, right); //将两个有序子序列合并 &#125;&#125;int main()&#123; int a[9] = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; cout &lt;&lt; &quot;排序前： &quot;; display(a,9); cout &lt;&lt; endl; cout &lt;&lt;&quot;排序后： &quot;; MergeSort(a,0,8); display(a, 9);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序的基本思想是在待排序的n个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分，然后对子序列分别重复上述过程，直到每个子序列内只有一个元素或为空为止。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;//输出a中所有元素void display(int a[],int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;//划分int Partition(int a[], int s, int t)&#123; int i = s, j = t; int tem = a[s]; //用序列的第1个记录作为基准 while (i != j)&#123; //从序列两端交替向中间扫描，直到 i=j 为止 while (j&gt;i&amp;&amp;a[j] &gt;= tem)&#123; j--; //从右向左扫描，找到第一个关键字小于tem的a[j] &#125; a[i] = a[j]; //将a[j]前移到a[i]的位置 while (i &lt; j&amp;&amp;a[i] &lt;= tem)&#123; i++; //从左向右扫描，找到第一个关键字大于tem的a[i] &#125; a[j] = a[i]; //将a[i]后移到a[j]的位置 &#125; a[i] = tem; //将基准插到中间 return i;&#125;void QuickSort(int a[], int s, int t)&#123; //对 a[s···t]元素序列进行递增排序 if (s &lt; t)&#123; int i = Partition(a, s, t); //基准的位置 QuickSort(a, s, i - 1); //对基准左边的序列递归排序 QuickSort(a, i+1, t); //对基准右边的序列递归排序 &#125;&#125;int main()&#123; int n = 10; int a[] = &#123; 2, 5, 1, 7, 10, 6, 9, 4, 3, 8 &#125;; cout &lt;&lt; &quot;排序前：&quot;; display(a,n); cout &lt;&lt; endl; cout &lt;&lt; &quot;排序后：&quot;; QuickSort(a, 0, n - 1); display(a, n);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(3)]]></title>
    <url>%2F2019%2F03%2F22%2Fbaidulbs3%2F</url>
    <content type="text"><![CDATA[说一下百度LBS的SDk版本肯定以后会更新，或许更新后刚才的小例子就gg了，不能跑了，所以官方的才是最新的，最好的 官网学习Android地图SDK指南]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(2)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs2%2F</url>
    <content type="text"><![CDATA[这篇搞一下codeAndroidManifest.xml 文件下面要用到的 API_KEY,去（1）中创建的应用中查看，就是下图中访问应用对应的，复制就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; package=&quot;com.example.qqqq&quot;&gt; &lt;!-- 此权限用于网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; &lt;!-- 此权限用于访问GPS定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt; &lt;!-- 此权限可以获取使用Wi-Fi等WLAN无线网络--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;!-- 此权限用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;!-- 改变WLAN状态的开关，如果打开或关闭Wi-Fi必需加入这个声明--&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt; &lt;!-- 此权限用于获取手机当前状态--&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;!-- 可以向存储卡写入数据，写入离线定位数据要用到--&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;!-- 此权限用于访问网络--&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;!-- SD卡读取权限，用户写入离线数据--&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; tools:ignore=&quot;ProtectedPermissions&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;!-- 这里的meta标签和service是必须要添加的两个标签，meta标签中name属性是固定的，value属性就是你 刚才在百度那创建的应用后得到的 API_KEY 的值，service中的也是固定的，写上就行--&gt; &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;jtBn5iCn3B5CEolmfwCPlSchXnQXFmTd&quot;/&gt; &lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot;&gt; &lt;/service&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; activity_main.xml 文件12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;!-- 这里的TextView 是用来测试的，看一下经纬度，地址啥的有没有错误，后面设置为不可见了--&gt; &lt;TextView android:id=&quot;@+id/show_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:visibility=&quot;gone&quot;/&gt; &lt;!-- 添加这个百度提供的 View，固定格式，id可以自己改--&gt; &lt;com.baidu.mapapi.map.MapView android:id=&quot;@+id/show_bdmap&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;true&quot;&gt; &lt;/com.baidu.mapapi.map.MapView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class MainActivity extends AppCompatActivity &#123; private TextView showData; private LocationClient mLocationListener; private boolean isFirstLocate=true; private BaiduMap baiduMap; private MapView showBdmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //进行初始化操作，这一步必须在 setContentView(R.layout.activity_main) 之前，否则会报错 SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); //申请权限和处理权限 List&lt;String&gt; permissionlist=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)!= PackageManager.PERMISSION_GRANTED)&#123; permissionlist.add(Manifest.permission.ACCESS_COARSE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_NETWORK_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CHANGE_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.CHANGE_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.INTERNET); &#125; if(!permissionlist.isEmpty())&#123; String[] permissions=permissionlist.toArray(new String[permissionlist.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; initData(); &#125; &#125; //申请权限和处理权限 public void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(MainActivity.this, &quot;必须同意才能用!&quot;, Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; initData(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;发生未知错误!&quot;,Toast.LENGTH_SHORT); finish(); &#125; break; &#125; &#125; private void initData()&#123; //初始化对象 showData=findViewById(R.id.show_data); showBdmap=findViewById(R.id.show_bdmap); baiduMap=showBdmap.getMap(); //BaiduMap是地图总控制器，这里获取一个BaiduMap的实例 baiduMap.setMyLocationEnabled(true); //百度地图是否显示我的位置，这个必须要写，否则设备的位置将无法在地图上显示 //设置位置客户端选项 LocationClientOption option=new LocationClientOption(); //设置定位模式为高精度模式 option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy); //设置间隔扫描的时间,每隔5秒会更新一次定位信息 option.setScanSpan(5000); //设置是否需要地址（需要联网，百度提供的位置信息） option.setIsNeedAddress(true); //实例化 LocationClient 传入的context应该是全局的 mLocationListener=new LocationClient(getApplicationContext()); //将选项设置进去 mLocationListener.setLocOption(option); //设置监听器 mLocationListener.registerLocationListener(new BDAbstractLocationListener() &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentPosition=new StringBuilder(); //获取经纬度 currentPosition.append(&quot;纬度：&quot;).append(bdLocation.getLatitude()).append(&quot;\n&quot;); currentPosition.append(&quot;经线：&quot;).append(bdLocation.getLongitude()).append(&quot;\n&quot;); //获取详细地址信息 currentPosition.append(&quot;国家：&quot;).append(bdLocation.getCountry()).append(&quot;\n&quot;); currentPosition.append(&quot;省：&quot;).append(bdLocation.getProvince()).append(&quot;\n&quot;); currentPosition.append(&quot;市：&quot;).append(bdLocation.getCity()).append(&quot;\n&quot;); currentPosition.append(&quot;区：&quot;).append(bdLocation.getDistrict()).append(&quot;\n&quot;); currentPosition.append(&quot;街道：&quot;).append(bdLocation.getStreet()).append(&quot;\n&quot;); //获取定位方式 currentPosition.append(&quot;定位方式：&quot;); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append(&quot;GPS定位&quot;); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append(&quot;网络定位&quot;); &#125; //更新地图位置 if(bdLocation.getLocType()==BDLocation.TypeGpsLocation||bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; //这个就是测试一下，显示的信息是否合理 showData.setText(currentPosition); &#125; &#125;); //开始定位 mLocationListener.start(); &#125; //更新位置 private void navigateTo(BDLocation bdLocation) &#123; //只让它更新一次 if(isFirstLocate)&#123; //获得经纬度 装进Latlng LatLng ll=new LatLng(bdLocation.getLatitude(),bdLocation.getLongitude()); //设置地图更新位置到 MapStatusUpdate 里面 MapStatusUpdate update= MapStatusUpdateFactory.newLatLng(ll); //地图更新 baiduMap.animateMapStatus(update); //设置缩放比例 update=MapStatusUpdateFactory.zoomTo(16f); //地图更新，完成缩放 baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; //构建我的位置，MyLocationData.Builder这个类是用来封装当前设备所在位置的，只需将经纬度传入到这个类的相应方法中即可 MyLocationData.Builder builder=new MyLocationData.Builder(); //获取经纬度 builder.latitude(bdLocation.getLatitude()); builder.longitude(bdLocation.getLongitude()); //构建 MyLocationData 实例，只需调用MyLocationData.Builder这个类的 build()方法 MyLocationData locationData=builder.build(); //将设备当前位置显示在地图上 baiduMap.setMyLocationData(locationData); &#125; //处理生命周期，这里必须要处理，像 mLocationListener.stop();如果不停止的话，会在后台不停地定位，消耗电量 protected void onResume()&#123; super.onResume(); showBdmap.onResume(); &#125; protected void onPause()&#123; super.onPause(); showBdmap.onPause(); &#125; protected void onDestroy()&#123; super.onDestroy(); mLocationListener.stop(); showBdmap.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(1)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs%2F</url>
    <content type="text"><![CDATA[这篇主要搞一下写代码前的一些准备LBS是啥？？？ 基于位置的服务，简称LBS(Location Based Service)，这个技术在近几年比较火，主要原理是利用无线电通讯网络或GPS等定位方式来确定出当前移动设备所在的位置。我们用的许多软件都有基本的定位服务，像天气，地图等等。 定位方式？？？通常有两种，一种是通过GPS定位，主要原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种方式精确度非常高，但是缺点是只能在室外使用，室内基本无法接收到卫星的信号。另外一种是网络定位，主要原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，精确度一般，但优点是在室内外都可用。 百度LBS上面的两种定位方式android都提供了相应的API支持，但Google被墙，网络定位的API失效，GPS定位室内不能用，比较蛋疼。相比之下，国内的也有非常好用的LBS–百度LBS服务。 正片开始1.百度地图开放平台 先进这个网址，有账号的登录，没有的注册一个，很简单，把一些基本信息填完整即可。 2.创建应用 再点开这个网址，点击创建应用，如下图 其中SHA1和包名，在androidstudio项目中如图： 双击signingReport 在你的androidstudio下方就会出现 包名可以在AndroidManifest.xml中查看 3.下载百度地图SDK 百度地图SDK 点击开发包下载–&gt;自定义下载–&gt;选择自己需要的服务–&gt;开发包下载 4.将下载的文件解压，并导入下图位置 解压后如图： 观察你的项目结构，app模块下有一个libs目录，这里是存放jar包的，所以把解压后的那个jar包 BaiduLBS_Android.jar 复制到这里 接下来展开 scr/main目录，在main上点击右键 new–&gt;Directory 新建一个名为 jniLibs 的目录，将压缩包里的其他目录直接全部复制到这里 最后点击androidstudio顶部工具栏中的 Sync 按钮，这样项目就可以引用我们导入的jar包了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java文件读写操作的一个简单例子]]></title>
    <url>%2F2019%2F03%2F20%2Fjava-io%2F</url>
    <content type="text"><![CDATA[java文件读写操作的一个简单事例一些简单的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class coin extends JFrame implements ActionListener &#123; // 代码中涉及的异常处理自己看情况添加即可 包名更换成自己的 创建的 ceshi.txt 在自己的java项目中的scr文件夹，点击刷新即可看见 private JTextArea jTextArea = new JTextArea(15, 15); private JButton jButton = new JButton(&quot;读取&quot;); private JButton jButton2 = new JButton(&quot;写入&quot;); public coin() &#123; JFrame jFrame = new JFrame(&quot;文件读写&quot;); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); jFrame.setLayout(new FlowLayout()); jFrame.setSize(300, 200); jButton.addActionListener(this); jButton2.addActionListener(this); jFrame.add(jTextArea); jFrame.add(jButton); jFrame.add(jButton2); jFrame.setVisible(true); &#125; // 读取文件 public void readfile() throws IOException &#123; File file = new File(&quot;ceshi.txt&quot;);// 创建文件 try &#123; InputStream is = new FileInputStream(file);// 创建输入流 byte[] buffer = new byte[200]; while (is.read(buffer) != -1) &#123; String string = new String(buffer); jTextArea.setText(string); &#125; is.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; // 写入文件 public void writefile() throws IOException &#123; File file = new File(&quot;ceshi.txt&quot;); try &#123; OutputStream os = new FileOutputStream(file, true);// true是追加写入 默认不追加 String string = jTextArea.getText().toString(); byte[] buffer = string.getBytes();// 将字符串 转换成byte数组 os.write(buffer); os.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // &#125; // 按钮点击事件实现 public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource() == jButton) &#123; try &#123; readfile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; else if (e.getSource() == jButton2) &#123; try &#123; writefile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴矢量图标库]]></title>
    <url>%2F2019%2F03%2F19%2Ftubiao%2F</url>
    <content type="text"><![CDATA[分享一个很棒的图标网站点击下面的链接即可查看 Iconfont–阿里巴巴矢量图标库]]></content>
      <categories>
        <category>随心</category>
      </categories>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个布局的简单注意点]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_layout%2F</url>
    <content type="text"><![CDATA[1.LinearLayout(线性布局)注意两个点：1.orientation 属性：布局中组件的排列方式，有horizontal(水平)，vertical(竖直，默认)两种方式。2.weight 属性：权重属性在屏幕适配时用的比较多(有几种用法可以去百度一下，用一种当 layout_width和layout_height都为match_parent时，可能难理解) 2.RelativeLayout(相对布局)直接看图，也没啥，还有margin和padding写个简单的梅花布局练练就应该都理解了. 3.TableLayout(表格布局)这个基本不常用，一般线性+相对布局就可以了，只需要了解一下。 1.如果我们想一行上有多个组件的话,就要添加一个TableRow的容器,把组件都丢到里面. 2.tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定. 3.tablerow的layout_width属性,默认是fill_parent的,我们自己设置成其他的值也不会生效， 但是layout_height默认是wrapten——content的,我们却可以自己设置大小. 4.整个表格布局的宽度取决于父容器的宽度(占满父容器本身) 5. 123android:collapseColumns:设置需要被隐藏的列的序号android:shrinkColumns:设置允许被收缩的列的列序号android:stretchColumns:设置运行被拉伸的列的列序号 以上这三个属性的列号都是从0开始算的,比如shrinkColunmns = “2”,对应的是第三列！ 可以设置多个,用逗号隔开比如”0,2”,如果是所有列都生效,则用”*”号即可 除了这三个常用属性,还有两个属性,分别就是跳格子以及合并单元格,这和HTML中的Table类似: android:layout_column=”2”:表示的就是跳过第二个,直接显示到第三个格子处,从1开始算的! android:layout_span=”4”:表示合并4个单元格,也就说这个组件占4个单元格 eg:123456789101112&lt;TableRow&gt; &lt;TextView /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登陆&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;退出&quot;/&gt; &lt;TextView /&gt;&lt;/TableRow&gt; 4.FrameLayout(帧布局)常用属性：12android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 当我们往帧布局里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式,所以它应用的场景并不多;帧布局的大小由控件中最大的子控件决定,如果控件的大小一样大的话,那么同一时刻就只能看到最上面的那个组件!后续添加的控件会覆盖前一个! eg:1234567891011121314151617181920&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot; android:foreground=&quot;@drawable/logo&quot; android:foregroundGravity=&quot;right|bottom&quot;&gt; &lt;TextView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;#FF6143&quot; /&gt; &lt;TextView android:layout_width=&quot;150dp&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#7BFE00&quot; /&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#FFFF00&quot; /&gt; &lt;/FrameLayout&gt; 5.GridLayout(网格布局) 用法： step 1:先定义组件的对其方式 android:orientation 水平或者竖直,设置多少行与多少列 step 2:设置组件所在的行或者列,记得是从0开始算的,不设置默认每个组件占一行一列 step 3:设置组件横跨几行或者几列;设置完毕后,需要在设置一个填充:android:layout_gravity = “fill” eg:计算器的清除键占2格1234&lt;Button android:layout_columnSpan=&quot;2&quot; android:layout_gravity=&quot;fill&quot; android:text=&quot;清空&quot; /&gt; 6.AbsoluteLayout(绝对布局)这个没啥好说的，基本不用，学java swing时就强调过了 控制大小:12android:layout_width:组件宽度android:layout_height:组件高度 控制位置:12android:layout_x:设置组件的X坐标 android:layout_y:设置组件的Y坐标]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (2)--JComboBox]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing02%2F</url>
    <content type="text"><![CDATA[JComboBox Integer Month[]= {1,2,3,4,5,6,7,8,9,10,11,12}; JComboBox jComboBox1=new JComboBox(Month); jComboBox1.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent event) { switch (event.getStateChange()) { case ItemEvent.SELECTED: System.out.println(&quot;选中&quot; + event.getItem()); break; case ItemEvent.DESELECTED: System.out.println(&quot;取消选中&quot;+event.getItem()); break; } } }); JComboBox的监听事件，通过 event.getStateChange() 方法来获取是否处于选中某一项的状态，若处于选中状态,则再通过 event。getItem()即可获取选中项。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (1)--JButton]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing01%2F</url>
    <content type="text"><![CDATA[JButton 12345JButton btn=new JButton(&quot;按钮&quot;);btn.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; //此处添加要执行的操作 &#125;&#125;); 一般按钮个数比较少的情况下，直接使用匿名内部类的方式更为方便。 当有多个按钮的时候，需要让类继承 ActionListener 接口 123456789101112131415161718192021JButton jButton1=new JButton(&quot;btn1&quot;);JButton jButton2=new JButton(&quot;btn2&quot;);jButton1.addActionListener(this);jButton2.addActionListener(this);//下面需要实现 ActionListener 接口的actionPerformed（）方法 1.public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jButton1) &#123; System.out.println(&quot;111111&quot;); &#125;else if(e.getSource()==jButton2)&#123; System.out.println(&quot;222222&quot;); &#125;&#125;2.public void actionPerformed(ActionEvent e) &#123; if(e.getActionCommand().equals(&quot;btn1&quot;)) &#123; System.out.println(&quot;111111&quot;); &#125;else if(e.getActionCommand().equals(&quot;btn2&quot;))&#123; System.out.println(&quot;222222&quot;); &#125;&#125; 这里会有两种方式，都可以 1.是利用 e.getSource()来直接获取点击的对象名（注意是对象名，jButton1,jButton2） 2.是利用 e.getActionCommand().equals()来直接获取点击按钮的名称，即字符串（btn1.btn2）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (3)--JList]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-20-java-swing03%2F</url>
    <content type="text"><![CDATA[JList 1234567String province[]= &#123;&quot;省份&quot;,&quot;北京&quot;,&quot;天津&quot;,&quot;上海&quot;,&quot;重庆&quot;&#125;;JList&lt;String&gt; jList=new JList&lt;&gt;(province);jList.addListSelectionListener(new ListSelectionListener() &#123; public void valueChanged(ListSelectionEvent e) &#123; System.out.println(jList.getSelectedValue().toString()); &#125;&#125;); JList 通过 getSelectedValue() 方法即可获取选中项当然 用 getSelectedIndex() 方法可以获取到点击的项的下标 如此示例中 北京项 下标为1，天津项 下标为2.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter 异常]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-19-javasql01%2F</url>
    <content type="text"><![CDATA[Java 9 及以上 eclipse 链接 SQL数据库 抛出 java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter 异常 方法需要导入 javax.xml.bind.jar 去下载一个即可 网址： http://www.java2s.com/Code/Jar/j/Downloadjavaxxmlbindjar.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (4)--JRadioButton及简单用法]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-24-java-swing04%2F</url>
    <content type="text"><![CDATA[多个JRadioButton必须放到 ButtonGroup 中能起到单选的作用，这里需要注意 ButtonGroup 并不是组件，所以只需把每一个单选按钮添加到 容器内 即可，不需要把 ButtonGroup 添加到容器内，下面演示一下 代码123456789101112131415161718192021222324252627282930313233343536373839package Number;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.ButtonGroup;import javax.swing.JFrame;import javax.swing.JRadioButton;public class coin extends JFrame implements ActionListener&#123; private ButtonGroup buttonGroup=new ButtonGroup(); private JRadioButton jRadioButton=new JRadioButton(&quot;男&quot;); private JRadioButton jRadioButton2=new JRadioButton(&quot;女&quot;); public coin() &#123; JFrame jFrame=new JFrame(&quot;单选按钮&quot;); jFrame.setSize(200, 150); jFrame.setLayout(new FlowLayout()); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); //将单选按钮添加到按钮组中 buttonGroup.add(jRadioButton); buttonGroup.add(jRadioButton2); //设置单选按钮的点击事件 jRadioButton.addActionListener(this); jRadioButton2.addActionListener(this); //只需将单选按钮添加进入容器 jFrame.add(jRadioButton); jFrame.add(jRadioButton2); jFrame.setVisible(true); &#125; //点击事件实现方法，同前面的 JButton 的方式，具体可以去看前面的JButton的用法 public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jRadioButton) &#123; System.out.println(&quot;boy&quot;); &#125;else if(e.getSource()==jRadioButton2) &#123; System.out.println(&quot;girl&quot;); &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android工程解析]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_project%2F</url>
    <content type="text"><![CDATA[先看图，这张图再熟悉不过了 下面进行一些解释1.java：我们写Java代码的地方，业务功能都在这里实现 2.res：存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件 3.drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 4.mipmap-hdpi：高分辨率，一般我们把图片丢这里mipmap-mdpi：中等分辨率mipmap-xhdpi：超高分辨率mipmap-xxhdpi：超超高分辨率 5.layout：该目录下存放的就是我们的布局文件 6.values：该目录下存放的是一些定义的字符串资源、样式资源、颜色资源、数组资源等等 在res目录下，所有的资源文件都会在 R.java 文件下生成对应的资源 id,我们可以通过id访问到对应的资源。例如在java代码中使用相关资源：布局引用：setContentView(R.layout.main);图片引用：imgIcon.setBackgroundDrawableResource(R.drawable.icon); 在xml文件中使用相关资源：(通过 @XXX 即可引用)文本引用：android:text=”@string/hello_world”图片引用：android:background = “@drawable/img_back” 分析几个文件1.布局文件 2.MainActivity.java文件 3.AndroidManifest.xml配置文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
