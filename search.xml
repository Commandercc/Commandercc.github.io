<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树概念平衡二叉树建立在二叉排序树的基础上，目的是使二叉排序树的平均查找长度更小，即让各结点的深度尽可能小，因此，树中每个结点的两棵子树的深度不要偏差太大。平衡二叉树的递归定义：平衡二叉树是一棵二叉树，其可以为空，或满足如下2个性质：①左右子树深度之差的绝对值不大于1。②左右子树都是平衡二叉树。 平衡因子的概念：结点的平衡因子 = 结点的左子树深度 — 结点的右子树深度。若平衡因子的取值为-1、0或1时，该节点是平衡的，否则是不平衡的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt;using namespace std;typedef int ElementType;typedef struct AVLNode&#123; ElementType Data; struct AVLNode* Left; struct AVLNode* Right;&#125;*AVLTree;//计算树高int GetHeight(AVLTree A)&#123; int HL, HR, MaxH; if (A == NULL) return 0; else&#123; HL = GetHeight(A-&gt;Left); HR = GetHeight(A-&gt;Right); MaxH = max(HL, HR); return (MaxH + 1); &#125;&#125;//左单旋（左左型LL：需顺时针转,即插入的结点在不平衡结点的左孩子的左子树上，导致根节点的平衡因子由1变为2）AVLTree SingleLeftRotation(AVLTree A)&#123; AVLTree B = A-&gt;Left; A-&gt;Left = B-&gt;Right; B-&gt;Right = A; return B;&#125;//右单旋（右右型RR：需逆时针转,即插入的结点在不平衡结点的右孩子的右子树上，导致根节点的平衡因子由1变为2）AVLTree SingleRightRotation(AVLTree A)&#123; AVLTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; return B;&#125;//左-右双旋（左右型LR：即插入的结点在不平衡结点的左孩子的右子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleLeftRightRotation(AVLTree A)&#123; A-&gt;Left = SingleRightRotation(A-&gt;Left); return SingleLeftRotation(A);&#125;//右-左双旋（右左型RL：即插入的结点在不平衡结点的右孩子的左子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleRightLeftRotation(AVLTree A)&#123; A-&gt;Right = SingleLeftRotation(A-&gt;Right); return SingleRightRotation(A);&#125;//插入结点AVLTree Insert(AVLTree A, ElementType X)&#123; if (!A)&#123; A = (AVLTree)malloc(sizeof(struct AVLNode)); A-&gt;Data = X; A-&gt;Left = A-&gt;Right = NULL; &#125; else if (X&lt;A-&gt;Data)&#123; A-&gt;Left = Insert(A-&gt;Left, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == 2) if (X&lt;A-&gt;Left-&gt;Data) A = SingleLeftRotation(A);//左左型(LL)需要右旋转 else A = DoubleLeftRightRotation(A);//左右型(LR)需要左右旋转 &#125; else if (X&gt;A-&gt;Data)&#123; A-&gt;Right = Insert(A-&gt;Right, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == -2) if (X&gt;A-&gt;Right-&gt;Data) A = SingleRightRotation(A);//右右型(RR)需要左旋转 else A = DoubleRightLeftRotation(A);//右左型(RL)需要右左旋转 &#125; return A;&#125;int main()&#123; AVLTree A = NULL; int n, t; cin &gt;&gt; n; for (int i = 0; i&lt;n; i++)&#123; cin &gt;&gt; t; A = Insert(A, t); &#125; //输出了根节点 cout &lt;&lt; A-&gt;Data &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用maven在eclipse中创建java web项目]]></title>
    <url>%2F2019%2F04%2F02%2Fmaven%E5%88%9B%E5%BB%BAjavaweb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.菜单-&gt;File-&gt;New-&gt;Other-&gt;Maven-&gt;Maven Project 点击next 2. 点击next 3.这个界面，选择 maven-archetype-webapp 。 点击next 4.这个界面，填写自己项目的信息。 5.现在得到的项目会出现红叉，即报错原因有两个： 没有java源代码目录 index.jsp报错 6.创建java源代码目录在上一步的截图中可以发现，没有地方存放java源文件，这个时候就需要按照如下步骤做：右键项目-&gt;属性-&gt;Java Build Path-&gt;Libraries-&gt;Edit-&gt;Workspace defaultJRE(jdk8)-&gt;Finish如图： 会出现下图效果： 7.通过pom.xml添加servlet jar包这个时候，还存在index.jsp会 报错的问题。 这个问题的解决办法是添加servlet.jar包。 双击pom.xml，出现pom专有的编辑页面。点击OverView右边的Dependencies可以看到里面有一个默认存在的junit然后点击Add，弹出选择窗口在中间 Enter GroupId, artifactId or sha1 prefix or pattern(*)…. 这个地方输入servlet，下面就会出来被搜索到的servlet jar包选中它，并点击ok 注: Scope要选择compile，表示编译期间要用到。 如下图：(前两个带星号的自己随便填个东西就行) 8.保存更改，项目报错消除了 9.运行 输出 helloworld！接下来只需像一般的javaweb项目那样，将这个项目添加到Tomcat里运行即可。 在浏览器输入： 1http://localhost:8080/j2ee 关于在pom.xml文件中添加依赖包时搜索不到servlet包的问题1.菜单-&gt;Window-&gt;preferences-&gt;maven 选中Download respository…… 那一项 2.菜单-&gt;Window-&gt;Show View-&gt;Other-&gt;Maven-&gt;Maven Repositories选中 Global Repositories 下的 alimaven 点击右键选择 Full Index Enabled (如果maven仓库已修改为阿里云仓库，就会有alimaven),点击后 eclipse 会自动开始下载所有的 jar 包，下载完成后，再右键 Local Respositories 选择 Rebuild Index 即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在eclipse中集成maven]]></title>
    <url>%2F2019%2F04%2F02%2Feclipse%E4%B8%AD%E9%9B%86%E6%88%90maven%2F</url>
    <content type="text"><![CDATA[1.集成mavenEclipse EE版本是已经集成好MAVEN的了，无需额外手动集成可以去官网下一个eclipse ee 2.设置maven路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;Installations-&gt;add-&gt;Directory…选择你的maven安装后的文件夹 把原来的那个低版本maven删除掉，如果有的话 3.设置仓库路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;User Settings-&gt;Global Settings 和 User Settings都使用我们在上篇文章中自己设置的仓库下的 setting.xml 文件。 点击一下Reindex,确保 local Repository为我们设置的本地仓库位置 1D:\maven-repository]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F04%2F01%2Fmaven%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录一下Maven的下载和环境变量的配置 下载官方下载地址 我下载的时候最新版本如下，去上面的官网点击即可下载。 配置环境变量1.右键我的电脑-属性-高级系统设置-环境变量-系统变量-Path-编辑-新建。 这里填入你下载的 maven 目录下 bin 目录的地址。 2.使用win+r(或右键开始菜单，选择运行), 然后输入cmd 打开命令行，输入 1mvn -v 若出现下图所示的，则配置成功。 maven仓库的相关修改仓库，顾名思义是用来存放项目需要的jar包的，maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。maven仓库的默认位置是在 C:\Users\你的用户名.m2\repository 因为刚下载和配置好并没有运行过，所以C盘中会看不到这个目录。因为我们需要的各种jar包都是放在这的，所以放在c盘感觉并不好，接下来就更改一下仓库的位置，放到D盘中。 在D盘中新建一个文件夹叫 maven-repository ，在你的maven安装目录下的conf文件夹下找到 setting.xml 文件，参考我的 D:\apache-maven-3.6.0\conf\setting.xml,打开找到下图的内容将 localRepository 这对标签内填上刚才创建的maven-repository文件夹的地址。 然后将这个 setting.xml 文件复制一个，粘贴到刚才的maven-repository文件夹下，以后新建项目maven自动将下载的依赖包放到该文件夹下。 使用阿里云仓库maven 会默认从maven官方提供的服务器下载jar包。而官方服务器在国外，被墙了，下的贼慢。 为了快速下载相关jar包，可以使用国内maven 阿里云的下载地址 打开刚才创建的 maven-repository文件夹下的 setting.xml 文件 找到 mirrors 这对标签，在里面添加如下代码即可。123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 如下图：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树 SDUTOJ 2482]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91SDUTOJ2482%2F</url>
    <content type="text"><![CDATA[problem:点击跳转到题目 understand:学了二叉树，得知先序和中序遍历或者后序和中序遍历都可以唯一确定一颗二叉树，所以这里我们采用求先序序列进行比较的方法。因为二叉排序树的中序遍历一定是递增序列都一样，所以此题只需比较每棵树的先序序列即可。 code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int z[11];int ccount;void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree(int a[])&#123; tree t = NULL; int key; for (int i = 0; i &lt; 9; i++)&#123; Inserttree(t, a[i]); &#125; return t;&#125;//先序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; z[ccount++] = t-&gt;data; traveltree(t-&gt;left); traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; int n; while (cin &gt;&gt; n&amp;&amp;n != 0)&#123; ccount = 0; string s = ""; cin &gt;&gt; s; int b[11],c[11],d[11]; //下面是 输入的第一串字符 构建二叉排序树并先序遍历后 得到的数组 c for (int i = 0; i &lt;s.length();i++)&#123; b[i] = s[i] - '0'; &#125; t=CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; c[i] = z[i]; //前序遍历 &#125; // for (int i = 0; i &lt; n; i++)&#123; t = NULL; ccount = 0; cin &gt;&gt; s; //下面是 输入的要进行比较的字符串 构建二叉排序树并先序遍历后 得到的数组 d for (int i = 0; i &lt;s.length(); i++)&#123; b[i] = s[i] - '0'; &#125; t = CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; d[i] = z[i]; //前序遍历 &#125; //下面是比较两个树 先序遍历的结果 c和d ，相同则YES ，不同则NO int flag = 0; for (int i = 0; i &lt; s.length(); i++)&#123; if (c[i] != d[i])&#123; cout &lt;&lt; "NO" &lt;&lt; endl; flag = 1; break; &#125; &#125; if (!flag)&#123; cout &lt;&lt; "YES" &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[理解：二叉排序树或者是一颗空树，或者是具有下列性质的二叉树：(1):若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值 (2):若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值 (3):它的左、右子树也分别为二叉排序树 code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int n; //含有n个结点//插入void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree()&#123; tree t = NULL; int key; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; key; Inserttree(t, key); &#125; return t;&#125;//中序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; traveltree(t-&gt;left); cout &lt;&lt; t-&gt;data &lt;&lt; " "; traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; cin &gt;&gt; n; t = CreateTree(); traveltree(t); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的同构]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[附上题目链接：二叉树的同构 理解：只要确保每个节点和其左右孩子的结点相等，或者孩子交换之后相等就可以。只要每个结点都符合，那么整棵树自然从上到下就都符合。 code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt; #include&lt;cstdio&gt;using namespace std;const int maxn = 20;struct node&#123; char key; int left, right;&#125;tree1[maxn], tree2[maxn]; //构建一个结构体用来构建两个二叉树int n1, n2;void build_tree(struct node * tree, int n)&#123; int i; char s[2]; for (i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s; tree[i].key = s[0]; cin &gt;&gt; s; if (s[0] == '-')&#123; tree[i].left = 11; //如果输入为 - 则置为一个非0到10的数 &#125; else&#123; tree[i].left = s[0] - '0'; //字符向数字转换 &#125; cin &gt;&gt; s; if (s[0] == '-')&#123; tree[i].right = 11; &#125; else&#123; tree[i].right = s[0] - '0'; &#125; &#125;&#125;bool checkc(int i, int j)&#123; //检测key相同的两个结点的左右孩子是否相同或者交换后是否相同 if (tree1[tree1[i].left].key == tree2[tree2[j].left].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].right].key) &#123; return 1; &#125; if (tree1[tree1[i].left].key == tree2[tree2[j].right].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].left].key) &#123; return 1; &#125; return 0;&#125;bool check()&#123; int i, j; //找到key相同的结点 for (i = 0; i &lt; n1; i++)&#123; for (j = 0; j &lt; n2; j++)&#123; if (tree1[i].key == tree2[j].key)&#123; if (checkc(i, j))&#123; break; //孩子相同或者交换后相同继续下一个结点 &#125; else&#123; return 0; &#125; &#125; &#125; if (j == n2)&#123; return 0; //没找到 &#125; &#125; return 1; //整棵二叉树都符合条件&#125;int main()&#123; while (cin&gt;&gt;n1)&#123; build_tree(tree1, n1); cin&gt;&gt;n2; build_tree(tree2, n2); if (n2!=n1)&#123; cout &lt;&lt; "No"&lt;&lt;endl; &#125; else if (check())&#123; cout &lt;&lt; "Yes"&lt;&lt;endl; &#125; else&#123; cout &lt;&lt; "No"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二叉树的深度，递归和非递归]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[递归： 123456789101112131415int high(Tree t)//求二叉树的高度&#123; int n,m; if(t==NULL) return 0; else &#123; n=high(t-&gt;lchild); //对左子树求高度 m=high(t-&gt;rchild); //对右子树求高度 if(n&gt;m) //高度为取两者中大的值+1 return n+1; else return m+1; &#125;&#125; 非递归（队列）：12345678910111213141516171819202122int high(Tree t)//求二叉树的高度&#123; int depth = 0; Tree p=NULL; queue&lt;Tree&gt; q; q.push(t); //根节点入队 while (!q.empty())&#123; depth++; //每到新的一层 高度+1 int width = q.size(); //求出本层的结点数 while (width--)&#123; //本层结点全部出队 p = q.front(); q.pop(); if (p-&gt;left)&#123; q.push(p-&gt;left); &#125; if (p-&gt;right)&#123; q.push(p-&gt;right); &#125; &#125; &#125; return depth;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定先序和中序序列,求后序序列]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%B1%82%E5%90%8E%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[要求：输入二叉树的先序遍历序列和中序遍历序列，输出该二叉树的后序遍历序列。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;//由先序序列s1[0···n-1]和中序序列s2[0···n-1]建立二叉链存储结构的二叉树//s1:先序遍历字符串 s2:中序遍历字符串 n:结点个数Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s1[0]; //根节点的值 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s2[k] == root)&#123; //在s2中查找 根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1 + 1, s2, k); //递归创建左子树 bt-&gt;rchild = creattree(s1 + k + 1, s2 + k + 1, n - k - 1); //递归创建右子树 return bt;&#125;//后序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); cout &lt;&lt; t-&gt;value; &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： ABDCEF BDAECF 输出： DBEFCA 附：已知中序后序求先序代码：12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s2[n-1]; //这里和上面的不一样 后序遍历的最后一个元素才是 根节点 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s1[k] == root)&#123; //在中序序列中查找根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1, s2, k); bt-&gt;rchild = creattree(s1 + k + 1, s2 + k, n - k - 1); //注意这里的范围 s2+k 画一画就明白了 return bt;&#125;//先序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; cout &lt;&lt; t-&gt;value; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： dbgeafc dgebfca 输出： abdegcf]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(4)]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%80%82%E9%85%8D%E5%99%A8%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下适配器容器1.stack（栈容器）实现头文件：&lt; stack&gt; 概述： 它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。例如，以下语句指定myst栈的底层容器为vector： 1stack&lt;string,vector&lt;string&gt; &gt; myst; //第2个参数指定底层容器为vector 主要成员函数： empty()：判断栈容器是否为空 size()：返回栈容器中实际元素个数 push(elem)：元素elem进栈 top()：返回栈顶元素 pop()：元素出栈 注意：stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 演示代码： #include&lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); printf(&quot;栈顶元素: %d\n&quot;, st.top()); printf(&quot;出栈顺序: &quot;); while (!st.empty()) //栈不空时出栈所有元素 { printf(&quot;%d &quot;, st.top()); st.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 栈顶元素: 3 出栈顺序: 3 2 1 2.queue（队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 主要成员函数： empty()：判断队列容器是否为空。 size()：返回队列容器中实际元素个数。 front()：返回队头元素。 back()：返回队尾元素。 push(elem)：元素elem进队。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; qu; qu.push(1); qu.push(2); qu.push(3); printf(&quot;队头元素: %d\n&quot;, qu.front()); printf(&quot;队尾元素: %d\n&quot;, qu.back()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.front()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 1 队尾元素: 3 出队顺序: 1 2 3 3.priority_queue（优先队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。比如：对于 int 类型的元素，priority_queue 默认元素值越大越优先。 主要成员函数： empty()：判断优先队列容器是否为空。 size()：返回优先队列容器中实际元素个数。 push(elem)：元素elem进队。 top()：获取队头元素。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; qu; qu.push(3); qu.push(1); qu.push(2); printf(&quot;队头元素: %d\n&quot;, qu.top()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.top()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 3 出队顺序: 3 2 1 (可见是按照值的大小出队)]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(3)]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下关联容器1.set（集合容器）/ multiset（多重集容器）实现头文件：&lt; set&gt;概述： set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 insert()：插入元素 erase()：从容器删除一个或几个元素 clear()：删除所有元素 count(k)：返回容器中关键字k出现的次数 find(k)：如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值 upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素 lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;int&gt; s; //定义set容器s set&lt;int&gt;::iterator it; //定义set容器迭代器it s.insert(1); s.insert(3); s.insert(2); s.insert(4); s.insert(2); printf(&quot; s: &quot;); for (it = s.begin(); it != s.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); multiset&lt;int&gt; ms; //定义multiset容器ms multiset&lt;int&gt;::iterator mit; //定义multiset容器迭代器mit ms.insert(1); ms.insert(3); ms.insert(2); ms.insert(4); ms.insert(2); printf(&quot;ms: &quot;); for (mit = ms.begin(); mit != ms.end(); mit++) printf(&quot;%d &quot;, *mit); printf(&quot;\n&quot;); return 0; } 输出： s: 1 2 3 4 ms: 1 2 2 3 4 2.map（映射容器）/ multimap（多重映射容器）实现头文件：&lt; set&gt; 概述： map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。在map和multimap 中的key和value是一个pair类结构。pair类结构的声明形如： 1234struct pair&#123; T first; T second;&#125; map/multimap利用pair的&lt;运算符将所有元素即key-value对按key的升序排列，以红黑树的形式存储，可以根据key快速地找到与之对应的value（查找时间为O(log2n)）。map中不允许关键字重复出现，支持[]运算符；而multimap中允许关键字重复出现，但不支持[]运算符。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap) insert(elem)：插入一个元素elem并返回该元素的位置 clear()：删除所有元素 find()：在容器中查找元素 count()：容器中指定关键字的元素个数（map中只有1或者0） 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： 1.12map&lt;char,int&gt; mymap; //定义map容器mymap，其元素类型为pair&lt;char,int&gt;mymap['a'] = 1; //或者mymap.insert(pair&lt;char，int&gt;('a',1) ); 2. #include&lt;iostream&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;char, int&gt; mymap; //定义map容器mymap mymap.insert(pair&lt;char, int&gt;(&apos;a&apos;, 1)); //插入方式1 mymap.insert(map&lt;char, int&gt;::value_type(&apos;b&apos;, 2)); //插入方式2 mymap[&apos;c&apos;] = 3; //插入方式3 map&lt;char, int&gt;::iterator it; for (it = mymap.begin(); it != mymap.end(); it++) printf(&quot;[%c,%d] &quot;, it-&gt;first, it-&gt;second); printf(&quot;\n&quot;); return 0; } 输出： [a,1] [b,2] [c,3]]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(2)]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A81%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下顺序容器1.vector(向量容器)实现头文件：&lt; vector&gt;定义方式：1234vector&lt;int&gt; v1; //定义元素为int的向量v1vector&lt;int&gt; v2(10); //指定向量v2的初始大小为10个int元素vector&lt;double&gt; v3(10,1.23); //指定v3的10个初始元素的初值为1.23vector&lt;int&gt; v4(a,a+5); //用数组a[0···4]共5个元素初始化v4 主要成员函数： empty(): 判断当前向量是否为空。 size(): 返回当前向量容器中的实际元素个数。 [ ]: 返回指定下标的元素。 reserve(n): 为当前向量容器预分配n个元素的存储空间。 capacity(): 返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 resize(n): 调整当前向量容器的大小，使其能容纳n个元素。 push_back(): 在当前向量容器尾部添加一个元素。 insert(pos,elem): 在pos位置插入元素elem，即将元素elem插入到迭代器指定的元素之前。 front(): 获取当前向量容器的第一个元素。 back(): 获取当前向量容器的最后一个元素。 erase(): 删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 clear(): 删除当前向量容器中的所有元素。 begin(): 该函数的两个版本返回iterator或const_iterator,引用容器的第一个元素。 end(): 该函数的两个版本返回返回iterator或const_iterator,引用容器的最后一个元素后面的一个位置。 rbegin(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的最后一个元素。 rend(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的第一个元素的前面一个位置。 最后两个是反向迭代。 演示代码： #include&lt;iostream&gt; #include&lt; vector&gt; using namespace std; int main(){ vector&lt;int&gt; myv; //定义vector容器myv vector&lt;int&gt;::iterator it;//定义myv的正向迭代器 it myv.push_back(1); //在myv的末尾添加元素 1 it = myv.begin(); //it迭代器指向开头元素 1 myv.insert(it, 2); //在it指向的元素之前插入元素 2 myv.push_back(3); //在myv的末尾添加元素 3 myv.push_back(4); //在myv的末尾添加元素 4 it = myv.end(); //it 迭代器指向元素4的后面 it--; //it 迭代器指向元素 4 myv.erase(it); //删除元素4 for (it = myv.begin(); it != myv.end(); it++){ cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } return 0; } 2.string(字符串容器)实现头文件：&lt; string&gt;定义方式：123456char cstr[]="China! Greate Wall"; //C-字符串string s1(cstr); // s1:China! Greate Wallstring s2(s1); // s2:China! Greate Wallstring s3(cstr，7，11); // s3:Greate Wallstring s4(cstr，6); // s4:China!string s5(5，'A'); // s5:AAAAA 主要成员函数： empty()：判断当前字符串是否为空串 size()：返回当前字符串的实际字符个数。 length()：返回当前字符串的实际字符个数。 [idx]：返回当前字符串位于idx位置的字符，idx从0开始。 at(idx)：返回当前字符串位于idx位置的字符。 compare(const string&amp; str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 append(cstr)：在当前字符串的末尾添加一个字符串str。 insert(size_type idx，const string&amp; str) ：在当前字符串的idx处插入一个字符串str。 find(string &amp;s,size_type pos):从当前字符串中的pos位置开始查找字符串s的第一个位置，，找到后返回其位置，若没有找到返回-1。 replace(size_type idx,size_type len,costring&amp; str):将当前字符串中起始于idx的len个字符用一个字符串str替换。 substr(size_type idx,size_type len):返回当前字符串起始于idx的长度为len的字串。 clear():删除当前字符串中的所有字符。 erase():删除当前字符串中的所有字符。 erase(size_type idx):删除当前字符串从idx开始的所有字符。 erase(size_type idx,size_type len):删除当前字符串从idx开始的len个字符。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include &lt; iostream&gt; #include &lt; string&gt; using namespace std; int main(){ string s1 = &quot;&quot;, s2, s3 = &quot;Bye&quot;; s1.append(&quot;Good morning&quot;); //s1=&quot; Good morning&quot; s2 = s1; //s1=&quot; Good morning&quot; int i = s2.find(&quot;morning&quot;); //i=5 s2.replace(i, s2.length() - i, s3); //相当于s2.replace(5,7,s3) cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; endl; return 0; } 输出：s1：Good morning s2:Good Bye 3.deque(双端队列)实现头文件：&lt; deque&gt;定义方式：123456deque&lt;int&gt; dq1; //定义元素为int的双端队列dq1deque&lt;int&gt; dq2(10); //指定dq2的初始大小为10个int元素deque&lt;double&gt; dq3(10，1.23); //指定dq3的10个初始元素的初值为1.23deque&lt;int&gt; dq4(dq2.begin()，dq2.end()); //用dq2的所有元素初始化dq4 主要成员函数： empty()：判断双端队列容器是否为空队。 size()：返回双端队列容器中元素个数。 push_front(elem)：在队头插入元素elem。 push_back(elem)：在队尾插入元素elem。 pop_front()：删除队头一个元素。 pop_back()：删除队尾一个元素。 erase()：从双端队列容器中删除一个或几个元素。 clear()：删除双端队列容器中所有元素。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;deque&gt; using namespace std; void disp(deque&lt;int&gt; &amp;dq) //输出dq的所有元素 { deque&lt;int&gt;::iterator iter; //定义迭代器iter for (iter=dq.begin();iter!=dq.end();iter++) printf(&quot;%d &quot;,*iter); printf(&quot;\n&quot;); } int main() { deque&lt;int&gt; dq; //建立一个双端队列dq dq.push_front(1); //队头插入1 dq.push_back(2); //队尾插入2 dq.push_front(3); //队头插入3 dq.push_back(4); //队尾插入4 printf(&quot;dq: &quot;); disp(dq); dq.pop_front(); //删除队头元素 dq.pop_back(); //删除队尾元素 printf(&quot;dq: &quot;); disp(dq); return 0; } 输出： dq:3 1 2 4 dq:1 2 4.list(链表容器)实现头文件：&lt; list&gt;定义方式：1234list&lt;int&gt; l1; //定义元素为int的链表l1list&lt;int&gt; l2 (10); //指定链表l2的初始大小为10个int元素list&lt;double&gt; l3 (10，1.23); //指定l3的10个初始元素的初值为1.23list&lt;int&gt; l4(a，a+5); //用数组a[0..4]共5个元素初始化l4 主要成员函数： empty()：判断链表容器是否为空。 size()：返回链表容器中实际元素个数。 push_back()：在链表尾部插入元素。 pop_back()：删除链表容器的最后一个元素。 remove ()：删除链表容器中所有指定值的元素。 remove_if(cmp)：删除链表容器中满足条件的元素。 erase()：从链表容器中删除一个或几个元素。 unique()：删除链表容器中相邻的重复元素。 clear()：删除链表容器中所有的元素。 insert(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，n，elem)：在pos位置插入n个元素elem。 insert(pos，pos1，pos2)：在迭代器pos处插入[pos1，pos2)的元素。 reverse()：反转链表。 sort()：对链表容器中的元素排序。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include &lt;list&gt; using namespace std; void disp(list&lt;int&gt; &amp;lst) //输出lst的所有元素 { list&lt;int&gt;::iterator it; for (it = lst.begin(); it != lst.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); } int main() { list&lt;int&gt; lst; //定义list容器lst list&lt;int&gt;::iterator it, start, end; lst.push_back(5); //添加5个整数5,2,4,1,3 lst.push_back(2); lst.push_back(4); lst.push_back(1); lst.push_back(3); printf(&quot;初始lst: &quot;); disp(lst); it = lst.begin(); //it指向首元素5 start = ++lst.begin(); //start指向第2个元素2 end = --lst.end(); //end指向尾元素3 lst.insert(it, start, end); printf(&quot;执行lst.insert(it,start,end)\n&quot;); printf(&quot;插入后lst: &quot;); disp(lst); return 0; } 输出： 初始lst: 5 2 4 1 3 执行lst.insert(it,start,end) 插入后lst: 2 4 1 5 2 4 1 3]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(1)]]></title>
    <url>%2F2019%2F03%2F23%2Fc%2B%2BSTL%2F</url>
    <content type="text"><![CDATA[这篇大体介绍一下STL相关内容STL简介C++中已经实现了数据结构中的很多容器和算法，它们构成标准C++库的子集，即标准模板类库 (Standard Template Library).STL是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。 STL概述STL主要由container(容器)、algorithm(算法)和iterator(迭代器)三大部分构成，容器用于存放数据对象(元素)，算法用于操作容器中的数据对象，算法和容器之间的中介就是迭代器。 container(容器):简单的说一个stl容器就是一种数据结构，例如链表、栈和队列等，STL中都已经实现好了，在算法设计中可以直接使用它们。这篇下面会详细讲各个容器，另外一些哈希表容器hash_set,hash_map等，它们属于非标准STL容器，其功能可以用set,map代替。 algorithm(算法):stl的算法部分主要由头文件、和组成。stl提供了大约100个实现算法的模板函数。 iterator(迭代器):stl迭代器用于访问容器中的数据对象。每个容器都有自己的迭代器，只有容器自己知道如何访问自己的元素。迭代器像c/c++中的指针，算法通过迭代器来定位和操作容器中的元素。 常用STL容器STL容器很多，每一个容器就是一个类模板，大致分为顺序容器、适配器容器和关联容器3种类型。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找的分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找折半查找又称二分查找，它是一种效率较高的查找方法。但是折半查找要求查找序列中的元素是有序的，为了简单，假设序列是递增有序的。折半查找的基本思路：设 a[low···high] 是当前的查找区间，首先确定该区间的中点位置mid=(low+high)/2 (取下界);然后将待查的 k值 与 a[mid].key 比较： （1）若k==a[mid].key,则查找成功并返回该元素的物理下标 （2）若k&lt;a[mid],则由表的有序性可知 a[mid···high] 均大于k，因此表中若存在值 等于k的元素，则该元素必定位于 左子表 a[low···mid-1] 中，故新的查找区间 是左子表a[low···mid-1]。 （3）若k&gt;a[mid],则要查找的元素必定位于 右子表 a[mid+1···high] 中，故新的查找区间 是右子表a[mid+1···high]。 下一次查找是针对新的查找区间进行的。 因此可以从最初的查找区间a[0···n-1]开始，每经过一次与当前查找区间中点位置上的关键字比较就可以确定查找是否成功，不成功则当前的查找区间缩小一半。重复这一过程，直到找到关键字为K的元素，或者直到当前的查找区间为空（即查找失败）时为止。 代码实现12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;using namespace std;//折半查找int BinSearch(int a[], int low, int high, int k)&#123; int mid; if (low &lt;= high)&#123; //当前区间存在元素时 mid = (low + high) / 2; //求查找区间的中间位置 if (a[mid] == k)&#123; //找到了，直接返回其物理下标 mid return mid; &#125; if (a[mid] &gt; k)&#123; //当a[mid]&gt;k 时在a[low···mid-1]中递归查找 return BinSearch(a, low, mid - 1, k); &#125; else&#123; //当a[mid]&lt;k 时在a[mid+1···high]中递归查找 return BinSearch(a, mid + 1, high, k); &#125; &#125; else&#123; return -1; //找不到，错误处理 &#125;&#125;int main()&#123; int n = 10, i; int k = 6; //要找的值 int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; i = BinSearch(a, 0, n - 1, k); if (i &gt;= 0)&#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个元素值为k"; &#125; return 0;&#125; 附：(非递归实现)12345678910111213141516int BinSearch(int a[], int n, int k)&#123; //在含有n个元素的数组a中查找 是否有值为K的元素 int low = 0, high = n - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (a[mid] == k)&#123; return mid; &#125; if (a[mid] &gt; k)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序的基本思想是首先将 a[0···n-1] 看成n个长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到n/k^2个长度为k^2的有序子表，如此反复进行下去，最后得到一个长度为n的有序表。若k=2，即归并是在相邻的两个有序子表中进行的，称为二路归并排序。若k&gt;2，即归并操作在相邻的多个有序子表中进行，则叫多路归并排序。我们仅讨论二路归并排序。分解—&gt;子问题求解—&gt;合并 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 #include&lt;iostream&gt;using namespace std;void display(int a[],int n)&#123; //输出数组元素 for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125;&#125;//合并void Merge(int a[], int left, int mid, int right)&#123; int *temp = new int[right - left + 1]; //定义并初始化临时数组 int i = left; //左边序列指针 int j = mid + 1; //右边序列指针 int t = 0; //临时数组指针 while (i &lt;= mid&amp;&amp;j &lt;= right)&#123; //第一个子表（左）和第二个子表（右）均没有扫描完时循环，左边子表和右边子表均从自己的第1个元素开始向右扫描 if (a[i] &lt;= a[j])&#123; temp[t++] = a[i++]; //如果第一个子表的当前元素值小，放入temp中 &#125; else&#123; temp[t++] = a[j++]; //如果第二个子表的当前元素值小，放入temp中 &#125; &#125; while (i &lt;= mid)&#123; //如果第一个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[i++]; &#125; while (j &lt;= right)&#123; //如果第二个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[j++]; &#125; t = 0; while (left &lt;= right)&#123; //将temp中的元素全部复制到原数组中 a[left++] = temp[t++]; &#125; delete[]temp; //释放临时空间&#125;//归并排序void MergeSort(int a[],int left,int right)&#123; if (left &lt; right)&#123; //子序列有两个或两个以上元素 int mid = (left + right) / 2; MergeSort(a, left, mid); //左边归并排序，使得左子序列有序 MergeSort(a, mid + 1, right); //右边归并排序，使得右子序列有序 Merge(a, left, mid, right); //将两个有序子序列合并 &#125;&#125;int main()&#123; int a[9] = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; cout &lt;&lt; "排序前： "; display(a,9); cout &lt;&lt; endl; cout &lt;&lt;"排序后： "; MergeSort(a,0,8); display(a, 9);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序的基本思想是在待排序的n个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分，然后对子序列分别重复上述过程，直到每个子序列内只有一个元素或为空为止。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;//输出a中所有元素void display(int a[],int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;//划分int Partition(int a[], int s, int t)&#123; int i = s, j = t; int tem = a[s]; //用序列的第1个记录作为基准 while (i != j)&#123; //从序列两端交替向中间扫描，直到 i=j 为止 while (j&gt;i&amp;&amp;a[j] &gt;= tem)&#123; j--; //从右向左扫描，找到第一个关键字小于tem的a[j] &#125; a[i] = a[j]; //将a[j]前移到a[i]的位置 while (i &lt; j&amp;&amp;a[i] &lt;= tem)&#123; i++; //从左向右扫描，找到第一个关键字大于tem的a[i] &#125; a[j] = a[i]; //将a[i]后移到a[j]的位置 &#125; a[i] = tem; //将基准插到中间 return i;&#125;void QuickSort(int a[], int s, int t)&#123; //对 a[s···t]元素序列进行递增排序 if (s &lt; t)&#123; int i = Partition(a, s, t); //基准的位置 QuickSort(a, s, i - 1); //对基准左边的序列递归排序 QuickSort(a, i+1, t); //对基准右边的序列递归排序 &#125;&#125;int main()&#123; int n = 10; int a[] = &#123; 2, 5, 1, 7, 10, 6, 9, 4, 3, 8 &#125;; cout &lt;&lt; &quot;排序前：&quot;; display(a,n); cout &lt;&lt; endl; cout &lt;&lt; &quot;排序后：&quot;; QuickSort(a, 0, n - 1); display(a, n);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(3)]]></title>
    <url>%2F2019%2F03%2F22%2Fbaidulbs3%2F</url>
    <content type="text"><![CDATA[说一下百度LBS的SDk版本肯定以后会更新，或许更新后刚才的小例子就gg了，不能跑了，所以官方的才是最新的，最好的 官网学习Android地图SDK指南]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(2)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs2%2F</url>
    <content type="text"><![CDATA[这篇搞一下codeAndroidManifest.xml 文件下面要用到的 API_KEY,去（1）中创建的应用中查看，就是下图中访问应用对应的，复制就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.example.qqqq"&gt; &lt;!-- 此权限用于网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;!-- 此权限用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;!-- 此权限可以获取使用Wi-Fi等WLAN无线网络--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;!-- 改变WLAN状态的开关，如果打开或关闭Wi-Fi必需加入这个声明--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取手机当前状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;!-- 可以向存储卡写入数据，写入离线定位数据要用到--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;!-- 此权限用于访问网络--&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!-- SD卡读取权限，用户写入离线数据--&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" tools:ignore="ProtectedPermissions" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- 这里的meta标签和service是必须要添加的两个标签，meta标签中name属性是固定的，value属性就是你 刚才在百度那创建的应用后得到的 API_KEY 的值，service中的也是固定的，写上就行--&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="jtBn5iCn3B5CEolmfwCPlSchXnQXFmTd"/&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true"&gt; &lt;/service&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; activity_main.xml 文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这里的TextView 是用来测试的，看一下经纬度，地址啥的有没有错误，后面设置为不可见了--&gt; &lt;TextView android:id="@+id/show_data" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" android:visibility="gone"/&gt; &lt;!-- 添加这个百度提供的 View，固定格式，id可以自己改--&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/show_bdmap" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true"&gt; &lt;/com.baidu.mapapi.map.MapView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class MainActivity extends AppCompatActivity &#123; private TextView showData; private LocationClient mLocationListener; private boolean isFirstLocate=true; private BaiduMap baiduMap; private MapView showBdmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //进行初始化操作，这一步必须在 setContentView(R.layout.activity_main) 之前，否则会报错 SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); //申请权限和处理权限 List&lt;String&gt; permissionlist=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)!= PackageManager.PERMISSION_GRANTED)&#123; permissionlist.add(Manifest.permission.ACCESS_COARSE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_NETWORK_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CHANGE_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.CHANGE_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.INTERNET); &#125; if(!permissionlist.isEmpty())&#123; String[] permissions=permissionlist.toArray(new String[permissionlist.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; initData(); &#125; &#125; //申请权限和处理权限 public void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(MainActivity.this, "必须同意才能用!", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; initData(); &#125;else&#123; Toast.makeText(MainActivity.this,"发生未知错误!",Toast.LENGTH_SHORT); finish(); &#125; break; &#125; &#125; private void initData()&#123; //初始化对象 showData=findViewById(R.id.show_data); showBdmap=findViewById(R.id.show_bdmap); baiduMap=showBdmap.getMap(); //BaiduMap是地图总控制器，这里获取一个BaiduMap的实例 baiduMap.setMyLocationEnabled(true); //百度地图是否显示我的位置，这个必须要写，否则设备的位置将无法在地图上显示 //设置位置客户端选项 LocationClientOption option=new LocationClientOption(); //设置定位模式为高精度模式 option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy); //设置间隔扫描的时间,每隔5秒会更新一次定位信息 option.setScanSpan(5000); //设置是否需要地址（需要联网，百度提供的位置信息） option.setIsNeedAddress(true); //实例化 LocationClient 传入的context应该是全局的 mLocationListener=new LocationClient(getApplicationContext()); //将选项设置进去 mLocationListener.setLocOption(option); //设置监听器 mLocationListener.registerLocationListener(new BDAbstractLocationListener() &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentPosition=new StringBuilder(); //获取经纬度 currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("经线：").append(bdLocation.getLongitude()).append("\n"); //获取详细地址信息 currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道：").append(bdLocation.getStreet()).append("\n"); //获取定位方式 currentPosition.append("定位方式："); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS定位"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络定位"); &#125; //更新地图位置 if(bdLocation.getLocType()==BDLocation.TypeGpsLocation||bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; //这个就是测试一下，显示的信息是否合理 showData.setText(currentPosition); &#125; &#125;); //开始定位 mLocationListener.start(); &#125; //更新位置 private void navigateTo(BDLocation bdLocation) &#123; //只让它更新一次 if(isFirstLocate)&#123; //获得经纬度 装进Latlng LatLng ll=new LatLng(bdLocation.getLatitude(),bdLocation.getLongitude()); //设置地图更新位置到 MapStatusUpdate 里面 MapStatusUpdate update= MapStatusUpdateFactory.newLatLng(ll); //地图更新 baiduMap.animateMapStatus(update); //设置缩放比例 update=MapStatusUpdateFactory.zoomTo(16f); //地图更新，完成缩放 baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; //构建我的位置，MyLocationData.Builder这个类是用来封装当前设备所在位置的，只需将经纬度传入到这个类的相应方法中即可 MyLocationData.Builder builder=new MyLocationData.Builder(); //获取经纬度 builder.latitude(bdLocation.getLatitude()); builder.longitude(bdLocation.getLongitude()); //构建 MyLocationData 实例，只需调用MyLocationData.Builder这个类的 build()方法 MyLocationData locationData=builder.build(); //将设备当前位置显示在地图上 baiduMap.setMyLocationData(locationData); &#125; //处理生命周期，这里必须要处理，像 mLocationListener.stop();如果不停止的话，会在后台不停地定位，消耗电量 protected void onResume()&#123; super.onResume(); showBdmap.onResume(); &#125; protected void onPause()&#123; super.onPause(); showBdmap.onPause(); &#125; protected void onDestroy()&#123; super.onDestroy(); mLocationListener.stop(); showBdmap.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(1)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs%2F</url>
    <content type="text"><![CDATA[这篇主要搞一下写代码前的一些准备LBS是啥？？？ 基于位置的服务，简称LBS(Location Based Service)，这个技术在近几年比较火，主要原理是利用无线电通讯网络或GPS等定位方式来确定出当前移动设备所在的位置。我们用的许多软件都有基本的定位服务，像天气，地图等等。 定位方式？？？通常有两种，一种是通过GPS定位，主要原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种方式精确度非常高，但是缺点是只能在室外使用，室内基本无法接收到卫星的信号。另外一种是网络定位，主要原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，精确度一般，但优点是在室内外都可用。 百度LBS上面的两种定位方式android都提供了相应的API支持，但Google被墙，网络定位的API失效，GPS定位室内不能用，比较蛋疼。相比之下，国内的也有非常好用的LBS–百度LBS服务。 正片开始1.百度地图开放平台 先进这个网址，有账号的登录，没有的注册一个，很简单，把一些基本信息填完整即可。 2.创建应用 再点开这个网址，点击创建应用，如下图 其中SHA1和包名，在androidstudio项目中如图： 双击signingReport 在你的androidstudio下方就会出现 包名可以在AndroidManifest.xml中查看 3.下载百度地图SDK 百度地图SDK 点击开发包下载–&gt;自定义下载–&gt;选择自己需要的服务–&gt;开发包下载 4.将下载的文件解压，并导入下图位置 解压后如图： 观察你的项目结构，app模块下有一个libs目录，这里是存放jar包的，所以把解压后的那个jar包 BaiduLBS_Android.jar 复制到这里 接下来展开 scr/main目录，在main上点击右键 new–&gt;Directory 新建一个名为 jniLibs 的目录，将压缩包里的其他目录直接全部复制到这里 最后点击androidstudio顶部工具栏中的 Sync 按钮，这样项目就可以引用我们导入的jar包了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java文件读写操作的一个简单例子]]></title>
    <url>%2F2019%2F03%2F20%2Fjava-io%2F</url>
    <content type="text"><![CDATA[java文件读写操作的一个简单事例一些简单的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class coin extends JFrame implements ActionListener &#123; // 代码中涉及的异常处理自己看情况添加即可 包名更换成自己的 创建的 ceshi.txt 在自己的java项目中的scr文件夹，点击刷新即可看见 private JTextArea jTextArea = new JTextArea(15, 15); private JButton jButton = new JButton("读取"); private JButton jButton2 = new JButton("写入"); public coin() &#123; JFrame jFrame = new JFrame("文件读写"); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); jFrame.setLayout(new FlowLayout()); jFrame.setSize(300, 200); jButton.addActionListener(this); jButton2.addActionListener(this); jFrame.add(jTextArea); jFrame.add(jButton); jFrame.add(jButton2); jFrame.setVisible(true); &#125; // 读取文件 public void readfile() throws IOException &#123; File file = new File("ceshi.txt");// 创建文件 try &#123; InputStream is = new FileInputStream(file);// 创建输入流 byte[] buffer = new byte[200]; while (is.read(buffer) != -1) &#123; String string = new String(buffer); jTextArea.setText(string); &#125; is.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; // 写入文件 public void writefile() throws IOException &#123; File file = new File("ceshi.txt"); try &#123; OutputStream os = new FileOutputStream(file, true);// true是追加写入 默认不追加 String string = jTextArea.getText().toString(); byte[] buffer = string.getBytes();// 将字符串 转换成byte数组 os.write(buffer); os.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // &#125; // 按钮点击事件实现 public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource() == jButton) &#123; try &#123; readfile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; else if (e.getSource() == jButton2) &#123; try &#123; writefile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴矢量图标库]]></title>
    <url>%2F2019%2F03%2F19%2Ftubiao%2F</url>
    <content type="text"><![CDATA[分享一个很棒的图标网站点击下面的链接即可查看 Iconfont–阿里巴巴矢量图标库]]></content>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用]]></title>
    <url>%2F2019%2F03%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[12 34]]></content>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个布局的简单注意点]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_layout%2F</url>
    <content type="text"><![CDATA[1.LinearLayout(线性布局)注意两个点：1.orientation 属性：布局中组件的排列方式，有horizontal(水平)，vertical(竖直，默认)两种方式。2.weight 属性：权重属性在屏幕适配时用的比较多(有几种用法可以去百度一下，用一种当 layout_width和layout_height都为match_parent时，可能难理解) 2.RelativeLayout(相对布局)直接看图，也没啥，还有margin和padding写个简单的梅花布局练练就应该都理解了. 3.TableLayout(表格布局)这个基本不常用，一般线性+相对布局就可以了，只需要了解一下。 1.如果我们想一行上有多个组件的话,就要添加一个TableRow的容器,把组件都丢到里面. 2.tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定. 3.tablerow的layout_width属性,默认是fill_parent的,我们自己设置成其他的值也不会生效， 但是layout_height默认是wrapten——content的,我们却可以自己设置大小. 4.整个表格布局的宽度取决于父容器的宽度(占满父容器本身) 5. 123android:collapseColumns:设置需要被隐藏的列的序号android:shrinkColumns:设置允许被收缩的列的列序号android:stretchColumns:设置运行被拉伸的列的列序号 以上这三个属性的列号都是从0开始算的,比如shrinkColunmns = “2”,对应的是第三列！ 可以设置多个,用逗号隔开比如”0,2”,如果是所有列都生效,则用”*”号即可 除了这三个常用属性,还有两个属性,分别就是跳格子以及合并单元格,这和HTML中的Table类似: android:layout_column=”2”:表示的就是跳过第二个,直接显示到第三个格子处,从1开始算的! android:layout_span=”4”:表示合并4个单元格,也就说这个组件占4个单元格 eg:123456789101112&lt;TableRow&gt; &lt;TextView /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="退出"/&gt; &lt;TextView /&gt;&lt;/TableRow&gt; 4.FrameLayout(帧布局)常用属性：12android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 当我们往帧布局里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式,所以它应用的场景并不多;帧布局的大小由控件中最大的子控件决定,如果控件的大小一样大的话,那么同一时刻就只能看到最上面的那个组件!后续添加的控件会覆盖前一个! eg:1234567891011121314151617181920&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:foreground="@drawable/logo" android:foregroundGravity="right|bottom"&gt; &lt;TextView android:layout_width="200dp" android:layout_height="200dp" android:background="#FF6143" /&gt; &lt;TextView android:layout_width="150dp" android:layout_height="150dp" android:background="#7BFE00" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="100dp" android:background="#FFFF00" /&gt; &lt;/FrameLayout&gt; 5.GridLayout(网格布局) 用法： step 1:先定义组件的对其方式 android:orientation 水平或者竖直,设置多少行与多少列 step 2:设置组件所在的行或者列,记得是从0开始算的,不设置默认每个组件占一行一列 step 3:设置组件横跨几行或者几列;设置完毕后,需要在设置一个填充:android:layout_gravity = “fill” eg:计算器的清除键占2格1234&lt;Button android:layout_columnSpan="2" android:layout_gravity="fill" android:text="清空" /&gt; 6.AbsoluteLayout(绝对布局)这个没啥好说的，基本不用，学java swing时就强调过了 控制大小:12android:layout_width:组件宽度android:layout_height:组件高度 控制位置:12android:layout_x:设置组件的X坐标 android:layout_y:设置组件的Y坐标]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (2)--JComboBox]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing02%2F</url>
    <content type="text"><![CDATA[JComboBox Integer Month[]= {1,2,3,4,5,6,7,8,9,10,11,12}; JComboBox jComboBox1=new JComboBox(Month); jComboBox1.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent event) { switch (event.getStateChange()) { case ItemEvent.SELECTED: System.out.println(&quot;选中&quot; + event.getItem()); break; case ItemEvent.DESELECTED: System.out.println(&quot;取消选中&quot;+event.getItem()); break; } } }); JComboBox的监听事件，通过 event.getStateChange() 方法来获取是否处于选中某一项的状态，若处于选中状态,则再通过 event。getItem()即可获取选中项。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (1)--JButton]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing01%2F</url>
    <content type="text"><![CDATA[JButton 12345JButton btn=new JButton("按钮");btn.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; //此处添加要执行的操作 &#125;&#125;); 一般按钮个数比较少的情况下，直接使用匿名内部类的方式更为方便。 当有多个按钮的时候，需要让类继承 ActionListener 接口 123456789101112131415161718192021JButton jButton1=new JButton("btn1");JButton jButton2=new JButton("btn2");jButton1.addActionListener(this);jButton2.addActionListener(this);//下面需要实现 ActionListener 接口的actionPerformed（）方法 1.public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jButton1) &#123; System.out.println("111111"); &#125;else if(e.getSource()==jButton2)&#123; System.out.println("222222"); &#125;&#125;2.public void actionPerformed(ActionEvent e) &#123; if(e.getActionCommand().equals("btn1")) &#123; System.out.println("111111"); &#125;else if(e.getActionCommand().equals("btn2"))&#123; System.out.println("222222"); &#125;&#125; 这里会有两种方式，都可以 1.是利用 e.getSource()来直接获取点击的对象名（注意是对象名，jButton1,jButton2） 2.是利用 e.getActionCommand().equals()来直接获取点击按钮的名称，即字符串（btn1.btn2）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (3)--JList]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-20-java-swing03%2F</url>
    <content type="text"><![CDATA[JList 1234567String province[]= &#123;"省份","北京","天津","上海","重庆"&#125;;JList&lt;String&gt; jList=new JList&lt;&gt;(province);jList.addListSelectionListener(new ListSelectionListener() &#123; public void valueChanged(ListSelectionEvent e) &#123; System.out.println(jList.getSelectedValue().toString()); &#125;&#125;); JList 通过 getSelectedValue() 方法即可获取选中项当然 用 getSelectedIndex() 方法可以获取到点击的项的下标 如此示例中 北京项 下标为1，天津项 下标为2.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter 异常]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-19-javasql01%2F</url>
    <content type="text"><![CDATA[Java 9 及以上 eclipse 链接 SQL数据库 抛出 java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter 异常 方法需要导入 javax.xml.bind.jar 去下载一个即可 网址： http://www.java2s.com/Code/Jar/j/Downloadjavaxxmlbindjar.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (4)--JRadioButton及简单用法]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-24-java-swing04%2F</url>
    <content type="text"><![CDATA[多个JRadioButton必须放到 ButtonGroup 中能起到单选的作用，这里需要注意 ButtonGroup 并不是组件，所以只需把每一个单选按钮添加到 容器内 即可，不需要把 ButtonGroup 添加到容器内，下面演示一下 代码123456789101112131415161718192021222324252627282930313233343536373839package Number;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.ButtonGroup;import javax.swing.JFrame;import javax.swing.JRadioButton;public class coin extends JFrame implements ActionListener&#123; private ButtonGroup buttonGroup=new ButtonGroup(); private JRadioButton jRadioButton=new JRadioButton("男"); private JRadioButton jRadioButton2=new JRadioButton("女"); public coin() &#123; JFrame jFrame=new JFrame("单选按钮"); jFrame.setSize(200, 150); jFrame.setLayout(new FlowLayout()); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); //将单选按钮添加到按钮组中 buttonGroup.add(jRadioButton); buttonGroup.add(jRadioButton2); //设置单选按钮的点击事件 jRadioButton.addActionListener(this); jRadioButton2.addActionListener(this); //只需将单选按钮添加进入容器 jFrame.add(jRadioButton); jFrame.add(jRadioButton2); jFrame.setVisible(true); &#125; //点击事件实现方法，同前面的 JButton 的方式，具体可以去看前面的JButton的用法 public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jRadioButton) &#123; System.out.println("boy"); &#125;else if(e.getSource()==jRadioButton2) &#123; System.out.println("girl"); &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android工程解析]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_project%2F</url>
    <content type="text"><![CDATA[先看图，这张图再熟悉不过了 下面进行一些解释1.java：我们写Java代码的地方，业务功能都在这里实现 2.res：存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件 3.drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 4.mipmap-hdpi：高分辨率，一般我们把图片丢这里mipmap-mdpi：中等分辨率mipmap-xhdpi：超高分辨率mipmap-xxhdpi：超超高分辨率 5.layout：该目录下存放的就是我们的布局文件 6.values：该目录下存放的是一些定义的字符串资源、样式资源、颜色资源、数组资源等等 在res目录下，所有的资源文件都会在 R.java 文件下生成对应的资源 id,我们可以通过id访问到对应的资源。例如在java代码中使用相关资源：布局引用：setContentView(R.layout.main);图片引用：imgIcon.setBackgroundDrawableResource(R.drawable.icon); 在xml文件中使用相关资源：(通过 @XXX 即可引用)文本引用：android:text=”@string/hello_world”图片引用：android:background = “@drawable/img_back” 分析几个文件1.布局文件 2.MainActivity.java文件 3.AndroidManifest.xml配置文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
