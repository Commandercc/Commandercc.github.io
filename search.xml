<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android快速注解框架Butterknife简单使用]]></title>
    <url>%2F2019%2F07%2F31%2FAndroid%E5%BF%AB%E9%80%9F%E6%B3%A8%E8%A7%A3%E6%A1%86%E6%9E%B6Butterknife%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介Butterknife中文又名黄油刀,是 J神JakeWharton开源的一款Android视图的字段和方法绑定快速注解框架.也是Android开发中比较常用的一款快速注解框架了,避免了不断的重复findViewById,在各种场合下快速绑定view的多种事件,大大提高了开发的效率.优点：1、强大的View绑定和Click事件处理功能，简化代码，提升开发效率2、方便的处理Adapter里的ViewHolder绑定问题3、运行时不会影响APP效率，使用配置方便4、代码清晰，可读性强 …… 配置使用在项目的app目录下的build.gradle中的dependencies中添加如下代码依赖12345dependencies &#123; implementation 'com.jakewharton:butterknife:8.8.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'&#125; Warning(很重要)注：1.使用ButterKnife修饰的方法和控件，不能用private or static 修饰，否则会报错。2.ButterKnife.bind(this)必须在初始化绑定布局文件之后,否则会报错3.在Fragment中需要在视图销毁时解绑Butterknife,否则会造成内存泄漏. 简单用法实例在Activity中绑定ButterKnife1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.butter) Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @OnClick(R.id.butter) public void onClick()&#123; Log.e("111111","11111"); Toast.makeText(this, "绑定单个view事件", Toast.LENGTH_SHORT).show(); &#125;&#125; 在Fragment中绑定ButterKnife123456789101112131415161718192021public class ExampleFragment extends Fragment &#123; private Unbinder unbinder;//先声明一个Unbinder对象 @BindView(R.id.example) Button example; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = View.inflate(getContext(),R.layout.fragment_example,null); unbinder = ButterKnife.bind(this,view); return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind();//视图销毁时必须解绑 &#125;&#125; 在Adapter的ViewHolder中绑定Butterknife12345678910111213141516171819202122232425262728@NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.recy_dynamic_state_item,parent,false); MyViewHolder myViewHolder = new MyViewHolder(itemView);//此处将view传入 itemView.setOnClickListener(this); return myViewHolder; &#125;public class MyViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.iv_photo) SimpleDraweeView simpleDraweeView; @BindView(R.id.tv_title) TextView tvTitle; @BindView(R.id.tv_detail) TextView tvDetail; @BindView(R.id.date) TextView date; @BindView(R.id.avatar_user) SimpleDraweeView avatarUser; @BindView(R.id.username) TextView userName; public MyViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this,itemView);//此处进行绑定 &#125;&#125; 具体用例绑定View：1.单个控件id注解： @BindView（）12@BindView(R.id.example) Button example; 2.多个控件id注解： @BindViews（）12@BindViews(&#123;R.id.butter,R.id.butter1,R.id.butter2&#125;) List&lt;Button&gt; buttons; 绑定资源文件1.绑定string 字符串：@BindString()12@BindString(R.string.app_name) //绑定资源文件中string字符串 String name; 2.绑定array数组：@BindArray()1234567891011&lt;resources&gt; &lt;string name="app_name"&gt;开眼视频&lt;/string&gt; &lt;string-array name="weather"&gt; &lt;item&gt;高温&lt;/item&gt; &lt;item&gt;低温&lt;/item&gt; &lt;item&gt;阴天&lt;/item&gt; &lt;item&gt;雨天&lt;/item&gt; &lt;item&gt;晴天&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 12@BindArray(R.array.weather) //绑定string资源里面array数组 String [] weathers ; 3.绑定颜色值：@BindColor()12@BindColor( R.color.colorPrimary) //绑定color文件中颜色值 int colorPrimary; 4.绑定Bitmap：@BindBitmap()12@BindBitmap(R.mipmap.ic_launcher) Bitmap bitmap; 5.其他资源绑定:12345678910@BindBool(R.bool.is_tablet) boolean isTablet; //绑定boolean@BindFont(R.font.comic_sans) Typeface comicSans; //绑定字体文字@BindDimen(R.dimen.horizontal_gap) int gapPx //绑定尺寸@BindDimen(R.dimen.horizontal_gap) float gap; //绑定尺寸@BindAnim(R.anim.fade_in) Animation fadeIn; //绑定动画@BindDrawable(R.drawable.placeholder) Drawable placeholder;//绑定Drawable 绑定监听事件1.单个控件点击事件1234@OnClick(R.id.butter) public void onClick()&#123; Toast.makeText(this, "绑定单个view事件", Toast.LENGTH_SHORT).show(); &#125; 2.多个控件同一点击事件1234@OnClick(&#123;R.id.share_wechat,R.id.share_moments,R.id.share_weibo&#125;) public void onClick()&#123; Toast.makeText(this, "多个控件同一点击事件", Toast.LENGTH_SHORT).show(); &#125; 3.多个控件点击事件1234567891011121314@OnClick(&#123;R.id.share_wechat,R.id.share_moments,R.id.share_weibo&#125;) public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.share_wechat: sharePlatform(Wechat.NAME); break; case R.id.share_moments: sharePlatform(WechatMoments.NAME); break; case R.id.share_weibo: sharePlatform(SinaWeibo.NAME); break; &#125; &#125; 4.绑定控件长按事件：@OnLongClick( )12345@OnLongClick( R.id.button1 ) //给 button1 设置一个长按事件public boolean onLongClick ()&#123; Toast.makeText(this, "is a long click", Toast.LENGTH_SHORT).show(); return true ;&#125; 5.其他事件绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//选中，选中取消@OnCheckedChanged(R.id.example) public void onChecked(boolean checked) &#123; Toast.makeText(this, checked ? "Checked!" : "Unchecked!", Toast.LENGTH_SHORT).show();&#125;//软键盘的功能按键@OnEditorAction(R.id.example)public boolean onEditorAction(KeyEvent key) &#123; Toast.makeText(this, "Pressed: " + key, Toast.LENGTH_SHORT).show(); return true; &#125;//焦点改变@OnFocusChange(R.id.example) public void onFocusChanged(boolean focused) &#123; Toast.makeText(this, focused ? "Gained focus" : "Lost focus", Toast.LENGTH_SHORT).show(); &#125;//Item长按，返回true则可以拦截onItemClick@OnItemLongClick(R.id.example_list) public boolean onItemLongClick(int position) &#123; Toast.makeText(this, "Long clicked position " + position + "!", Toast.LENGTH_SHORT).show(); return true; &#125;//Item点击事件@OnItemClick(R.id.example_list) public void onItemClick(int position) &#123; Toast.makeText(this, "Clicked position " + position + "!", Toast.LENGTH_SHORT).show(); &#125;//Item被选择事件@OnItemSelected(R.id.example_list) public void onItemSelected(int position) &#123; Toast.makeText(this, "Selected position " + position + "!", Toast.LENGTH_SHORT).show(); &#125;//EditText里面的文本变化事件@OnTextChanged(R.id.example) public void onTextChanged(CharSequence text) &#123; Toast.makeText(this, "Text changed: " + text, Toast.LENGTH_SHORT).show(); &#125;//页面改变事件@OnPageChange(R.id.example_pager) public void onPageSelected(int position) &#123; Toast.makeText(this, "Selected " + position + "!", Toast.LENGTH_SHORT).show(); &#125;//触摸事件@OnTouch(R.id.example)public boolean onTouch() &#123; Toast.makeText(this, "Touched!", Toast.LENGTH_SHORT).show(); return false; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea2018版本导出war包（其他版本仅供参考）]]></title>
    <url>%2F2019%2F07%2F31%2Fidea2018%E5%AF%BC%E5%87%BAwar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[注这篇文章是转载的，在网上看了几篇idea导出war包的文章，只有这一篇真正的好用，看的其他的你抄我，我抄你，还都是错的，笑死我了。 原地址 idea2018版本导出war包 进入项目的Project Structure界面，进行如下4步操作 有的可能会没有第4步的选项，没关系不影响。 通过上述4步操作后，进入如下界面注：1.修改war包的名称（根据实际情况）；2.如果出现WEB-INF文件夹则删除，否则不做操作；3.创建META-INF文件（必须,下一步会创建）。 选择如下的路径创建META-INF文件，IDEA会自动创建该文件 在操作完上面3大步骤后，进入如下界面，进行如图所示的操作注：这里必须要进行Put into Output Root操作（非常重要，否则相关jar包不能进行发布） 执行完Put into Output Root操作后，war包的目录结构如下注：也可能该界面不会出现META-INF文件夹，但是在webapp目录下一定有该文件夹。 至此，导出war包的准备工作已经完成，下面进行编译，在Build菜单下选择Make Project选项 Make成功后，继续在Build菜单栏下，选择Build Artifacts…选项 在弹出的菜单栏中进行Build操作或根据实际需求进行其他操作 OKOK，到目前为止，web项目已经被导出为war包，并且war包中的目录结构也是正确的（网上的很多操作导出的war包文件目录都有问题），至于war包的具体位置，根据第2步中设置的导出目录为准。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidstudio使用阿里云仓库提高依赖加载速度]]></title>
    <url>%2F2019%2F07%2F30%2FAndroidstudio%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[大概我们在使用一些第三方框架时，需要在项目中添加相应的依赖，默认添加依赖时从jcenter()这个仓库下载东西的速度非常慢，只要我们改用阿里云的仓库就可以大大提高加载速度。 操作只需要在项目的build.gradle(不是app目录下的那个build.gradle，是外面那个)中加入下面的代码123maven &#123; url "http://maven.aliyun.com/nexus/content/groups/public/" &#125; 加入位置如图，然后同步项目即可。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给APP设置一个启动图]]></title>
    <url>%2F2019%2F07%2F29%2FAPP%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[~~ APP的启动图很常见，我们在打开一些app的时候经常先出现一张图(或是广告之类的),过了几秒后才会进入系统相关主页面，这篇就记录一下简单的启动图的处理。 .1.在你的app项目里新建一个Activity，命名为 SplashActivity，相应的创建对应的布局文件 activity_splash.xml. .2.将准备的图片放到mimmap包下，将上面的布局文件背景引用为这张图片12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".SplashActivity" android:background="@mipmap/img_01"&gt; //background属性来设置图片&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; .修改SplashActivity中的代码如下123456789101112131415161718192021public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); Thread myThread=new Thread()&#123;//创建子线程 @Override public void run() &#123; try&#123; sleep(3000);//使程序休眠3秒,即3秒后进入系统页面 Intent it=new Intent(getApplicationContext(),MainActivity.class);//启动MainActivity startActivity(it); finish();//关闭当前活动 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;; myThread.start();//启动线程 &#125;&#125; .修改配置文件AndroidManifest中的代码，将我们创建的 SplashActivity 设置为首个启动活动。很简单，标签中的内容从MainActivity活动中拿到SplashActivity中即可。123456789&lt;activity android:name=".SplashActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MainActivity"&gt; &lt;/activity&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp上传文件至本地指定位置后台用servlet处理]]></title>
    <url>%2F2019%2F07%2F23%2Fandroid%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%90%8E%E5%8F%B0%E7%94%A8servlet%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[大概这里我弄了上传图片当做例子 目录结构 这里这几个jar包自己导入就行，第三个是一个大神写的框架，直接搜就能搜到 Android代码：HttpUtil.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HttpUtil &#123; public static Platform mPlatform=Platform.get(); public static void upLoadSingleFile(File file,String url)&#123; Log.i("filePath",file.getAbsolutePath()); Log.i("fileName",file.getName()); if(file.exists())&#123; OkHttpClient okHttpClient=new OkHttpClient.Builder().connectTimeout(10, TimeUnit.SECONDS).build(); //MediaType为全部类型 final MediaType mediaType=MediaType.parse("application/octet-stream"); //根据文件类型，将File装进RequestBody中 RequestBody fileBody=RequestBody.create(mediaType,file); //将fileBody添加进MultipartBody final RequestBody requestBody=new MultipartBody.Builder() .addFormDataPart("file",file.getName(),fileBody) .build(); //Request请求对象 Request request=new Request.Builder() .post(requestBody) .url(url) .build(); Call call=okHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; mPlatform.execute(new Runnable() &#123; @Override public void run() &#123; Log.i("error","错误 "); &#125; &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; ResponseBody responseBody=null; responseBody=response.body(); final String info = responseBody.string(); mPlatform.execute(new Runnable() &#123; @Override public void run() &#123; Log.i("success",info); &#125; &#125;); &#125; &#125;); &#125;else&#123; Log.i("error","文件不存在！"); &#125; &#125;&#125; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class MainActivity extends AppCompatActivity &#123; private Button button; //选择图片按钮 private Button button2;//上传按钮 String fileurl=""; //声明一个权限数组 String[] permissions = new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE&#125;; List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;(); private static final int PERMISSION_REQUEST = 1; private Platform mPlatform; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initPermission();//获取权限 mPlatform=Platform.get(); init(); &#125; private void init() &#123; //初始化按钮及其点击事件 button=findViewById(R.id.upload_activity_bt_img); button2=findViewById(R.id.btn_select); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.i("button","11111"); uploadTextFile(); &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_PICK); //打开相册选择图片 intent.setType("image/*"); startActivityForResult(intent,1); // 第二个参数是请求码 &#125; &#125;); &#125; //上传 private void uploadTextFile() &#123; Log.i("file",fileurl); //看一下路径是否正确 File file=new File(fileurl); //要请求的地址，testServlet下面会给出 String url="http://10.152.4.162:8080/upload/testServlet"; HttpUtil.upLoadSingleFile(file,url); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case 1: // 请求码 fileurl=parseUri(data); Log.i("file",fileurl); break; default: &#125; &#125; //得到选中图片地址 public String parseUri(Intent data) &#123; Uri uri=data.getData(); String imagePath; // 第二个参数是想要获取的数据 Cursor cursor = getContentResolver().query(uri, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;, null, null, null); if (cursor == null) &#123; imagePath = uri.getPath(); &#125; else &#123; cursor.moveToFirst(); int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); imagePath = cursor.getString(index); cursor.close(); &#125; return imagePath; // 返回图片地址 &#125; //下面是动态申请权限，6.0后读写权限需要动态申请 private void initPermission()&#123; mPermissionList.clear(); /** * 判断哪些权限未授予 */ for (int i = 0; i &lt; permissions.length; i++) &#123; if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; mPermissionList.add(permissions[i]); &#125; &#125; /** * 判断是否为空 */ if (mPermissionList.isEmpty()) &#123; //未授予的权限为空，表示都授予了 &#125; else &#123; //请求权限方法 String[] permissions = mPermissionList.toArray(new String[mPermissionList.size()]);//将List转为数组 ActivityCompat.requestPermissions(MainActivity.this, permissions, PERMISSION_REQUEST); &#125; &#125; /** * 响应授权 * 这里不管用户是否拒绝，都进入首页，不再重复申请权限 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST: break; default: break; &#125; &#125; protected void onDestroy() &#123; super.onDestroy(); Handler handler=new Handler(Looper.getMainLooper()); handler.removeCallbacksAndMessages(null); &#125;&#125; 布局文件(很简单，就两个按钮)12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".activity.MainActivity"&gt; &lt;Button android:id="@+id/btn_select" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="选择文件"/&gt; &lt;Button android:id="@+id/upload_activity_bt_img" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击上传"/&gt;&lt;/LinearLayout&gt; 配置文件(不要忘了添加一下权限)123&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt; 本地服务器端######TestServlet.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@WebServlet(name = "TestServlet",urlPatterns = "/testServlet")public class TestServlet extends HttpServlet &#123; private ServletFileUpload mServletFileUpload; private void initUp() &#123; if (null == mServletFileUpload) &#123; File file = (File) getServletContext().getAttribute("javax.servlet.context.tempdir"); mServletFileUpload = new ServletFileUpload(new DiskFileItemFactory( DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD, file )); mServletFileUpload.setFileSizeMax(1024L * 1024 * 100); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; System.out.println("开始处理请求。。。"); initUp(); response.setHeader("Content-Type", "text/html;charset=utf-8");//指定编码 Map&lt;String, List&lt;FileItem&gt;&gt; fileItemListMap = mServletFileUpload.parseParameterMap(request); for (Map.Entry&lt;String, List&lt;FileItem&gt;&gt; entry : fileItemListMap.entrySet()) &#123; List&lt;FileItem&gt; fileItemList = entry.getValue(); if (!fileItemList.isEmpty()) &#123; for (FileItem fileItem : fileItemList) &#123; if (!fileItem.isFormField()) &#123;//取非表单属性 ，也就是文件 String fileName = FilenameUtils.getName(new String(fileItem.getName().getBytes(), "utf-8")); InputStream inputStream = fileItem.getInputStream(); File file = new File("D:/uploads", fileName); FileOutputStream fileOutputStream = new FileOutputStream(file); byte[] bytes = new byte[1024 * 8]; int len; while ((len = inputStream.read(bytes)) != -1) &#123; fileOutputStream.write(bytes, 0, len); fileOutputStream.flush(); &#125; fileOutputStream.close(); PrintWriter writer = response.getWriter(); writer.print(fileName + " ----&gt; ok!!!!!");//成功 ，返回个响应 writer.flush(); &#125; &#125; &#125; &#125; System.out.println("请求处理结束。"); &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125;&#125; 效果把手机模拟器里的 java路线.jpg 文件发送到服务器，经处理后保存到本地 D:\uploads 目录下]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动态申请权限]]></title>
    <url>%2F2019%2F07%2F23%2Fandroid%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[申请动态权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 //声明一个权限数组private String[] permissions = new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE&#125;;private List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;();//定义一个请求码private static final int PERMISSION_REQUEST = 1;//动态申请权限方法private void initPermission()&#123; mPermissionList.clear(); /** * 判断哪些权限未授予 */ for (int i = 0; i &lt; permissions.length; i++) &#123; if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; mPermissionList.add(permissions[i]); &#125; &#125; /** * 判断是否为空 */ if (mPermissionList.isEmpty()) &#123; //未授予的权限为空，表示都授予了 &#125; else &#123; //请求权限方法 String[] permissions = mPermissionList.toArray(new String[mPermissionList.size()]);//将List转为数组 //调用requestPermissions（）向系统申请权限 //该方法接收3个参数，第一个是activity实例，第二个是一个String数组，第三个是请求码 ActivityCompat.requestPermissions(MainActivity.this, permissions, PERMISSION_REQUEST); &#125; &#125; /** * 响应授权 * 这里不管用户是否拒绝，都进入首页，不再重复申请权限 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case PERMISSION_REQUEST: break; default: break; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5月份的一些零散点]]></title>
    <url>%2F2019%2F06%2F11%2F2019-6-11-5%E6%9C%88%E4%BB%BD%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ai,这个五月份来来回回搞了数据库和软工的项目，这两个都用Javaweb的一些知识写的，就当练手了，中间还参加准备了一个比赛，感觉没写多少东西，就简单的记录一下吧。 jsp 按钮点击跳转到servlet并传递变量值传递常量 id &lt;input type=&quot;submit&quot; name=&quot;Submit1&quot; value=&quot;选座&quot; onclick=&quot;window.location.href=&apos;test1?id=1&apos;&quot;/&gt; 传递变量 id &lt;input type=&quot;submit&quot; name=&quot;Submit2&quot; value=&quot;取消预约&quot; onclick=&quot;window.location.href=&apos;CancelyyServlet?h_id=&lt;%=h_id%&gt;&apos;&quot;/&gt; 在servlet页面 通过正常的 String id=request.getParameter(&quot;id&quot;); 接收即可 传递多个参数 用 &amp; 符号 eg:&lt;input type=&quot;submit&quot; name=&quot;Submit1&quot; value=&quot;预约&quot; onclick=&quot;window.location.href=&apos;ChangeHouseStateServlet?h_id=&lt;%=house.getH_id()%&gt;&amp;seat_id=&lt;%=house.getSeat_id()%&gt;&apos;&quot;/&gt; okttp请求时 response.body.string与toString 的区别1.toString(): This returns your object in string format.（以字符串的格式返回你的对象） 2. .string(): This returns your response。（返回你的response） 3. 正确写法： String responseText=response.body().string(); 网络权限 android.permission.INTERNET 不是危险权限 不需要动态申请阿里云服务器配置很蛋疼的问题配置阿里云服务器 按照步骤来 结果就是远程桌面连接不上 最后将端口号3389 改成了3399 连上了 MySQL修改登录密码先cmd打开命令行窗口，输入 mysql 进入mysql指令状态 ，然后 输入 SET PASSWORD FOR &apos;dbadmin&apos;@&apos;localhost&apos; = &apos;newpasswd2&apos;; 使用SET PASSWORD语句更改dbadmin用户帐户的密码。 推荐一个在线 java 反编译工具将 .class 反编译成 .java java在线反编译工具 jsp中 session简单用法传递time HttpSession session=request.getSession(); session.setAttribute(&quot;time&quot;, time); javaweb项目中文件的路径问题（蛋疼）参照index.jsp 在webContent文件夹下的就是主路径 localhost:8080/yysystem/index.jsp 像访问index.jsp就直接项目名+index.jsp 如果在webContent 下建立了一个 jsp文件夹 里面有home.jsp 那么访问的时候就是 localhost:8080/yysystem/jsp/home.jsp 此时，若想从home.jsp中跳转到 index.jsp ，要注意，这里index.jsp位于目前位置home.jsp的上一级路径，所以写路径时要写 ../ 例如：&lt;input type=&quot;button&quot; value=&quot;退出系统&quot; name=&quot;exit&quot; onclick=&quot;window.location.href=&apos;../index.jsp&apos;&quot;/&gt; 访问包下的servlet也是同理 &lt;form action=&quot;../HouseServlet&quot; method=&quot;post&quot;&gt; filter 过滤&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 这样写就是过滤掉webContent/jsp文件夹下的所有文件 *jsp 这样写是过滤所有以.jsp结尾的 mysql 模糊查询SELECT username FROM post WHERE post_content LIKE &apos;%dnf%&apos; %表示由零个或多个字符组成的字符串 在post表中查询 post_content中含有 dnf 的username]]></content>
      <categories>
        <category>随心</category>
      </categories>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常学习编程中一些 异常和报错 的记录]]></title>
    <url>%2F2019%2F05%2F24%2F%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%BC%82%E5%B8%B8%E5%92%8C%E6%8A%A5%E9%94%99%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[android本区域用来记录一下日常android操作中,出现的异常和报错。 rg.gradle.tooling.BuildException androidstudio生成.apk文件时，报错123456789101112131415161718192021222324Error:Internal error:org.gradle.tooling.BuildException: Could not execute build using Gradle distribution 'https://services.gradle.org/distributions/gradle-4.10.1-all.zip'. ....... org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getSelectedArtifacts(DefaultConfiguration.java:1037) at org.gradle.api.internal.artifacts.configurations.DefaultConfiguration$ConfigurationFileCollection.getFiles(DefaultConfiguration.java:1025) ... 43 moreCaused by: org.gradle.api.GradleException: Cannot find a version of 'com.android.support:support-annotations' that satisfies the version constraints: Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support.test:runner:1.0.2' --&gt; 'com.android.support:support-annotations:27.1.1' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support.test:runner:1.0.2' --&gt; 'com.android.support.test:monitor:1.0.2' --&gt; 'com.android.support:support-annotations:27.1.1' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support.test.espresso:espresso-core:3.0.2' --&gt; 'com.android.support.test:runner:1.0.2' --&gt; 'com.android.support:support-annotations:27.1.1' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-vector-drawable:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-v4:26.1.0' --&gt; 'com.android.support:support-compat:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-v4:26.1.0' --&gt; 'com.android.support:support-media-compat:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-v4:26.1.0' --&gt; 'com.android.support:support-core-utils:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxx:app:unspecified' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-v4:26.1.0' --&gt; 'com.android.support:support-core-ui:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Dependency path 'xxxx:app:unspecified' --&gt; 'xxx:loginmanager:unspecified' --&gt; 'com.yanzhenjie:permission:1.0.7' --&gt; 'com.android.support:appcompat-v7:26.1.0' --&gt; 'com.android.support:support-annotations:26.1.0' Constraint path 'xxx:app:unspecified' --&gt; 'com.android.support:support-annotations' strictly '26.1.0' because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path 'xxx:app:unspecified' --&gt; 'com.android.support:support-annotations' strictly '26.1.0' because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path 'xxx:app:unspecified' --&gt; 'com.android.support:support-annotations' strictly '26.1.0' because of the following reason: debugRuntimeClasspath uses version 26.1.0 Constraint path 'xxx:app:unspecified' --&gt; 'com.android.support:support-annotations' strictly '26.1.0' because of the following reason: debugRuntimeClasspath uses version 26.1.0 at org.gradle.api.internal.artifacts.ivyservice.resolveengine.graph.builder.DependencyGraphBuilder.validateGraph(DependencyGraphBuilder.java:322) ... 59 more 解决方案： 123456从错误信息中我们可以推测出是support-annotations这个包重复了,有27.1.1的依赖和26.1.0的依赖,所以修改其中一个,让其保持一致,或者在app的 build.gradle 中将使用27.1.1的依赖关系去掉,将下面的引用注释掉:androidTestImplementation 'com.android.support.test:runner:1.0.2'androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2']]></content>
      <categories>
        <category>异常和报错整理</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android端获取Tomcat服务器端json数据并通过listview显示]]></title>
    <url>%2F2019%2F05%2F14%2Fandroid%E7%AB%AF%E8%8E%B7%E5%8F%96Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[大体描述：大体意思是用eclipse ee创建一个Javaweb项目,该项目能从MySQL数据库中获取user表的数据，将数据封装成json格式，将此项目发布到本地Tomcat服务器，在android端获取刚才的json数据，并用listview显示。废话不多说下面直接开始。 Tomcat服务器端很简单，建立一个servlet用来处理数据，再建一个数据库工具类，我这里是DatabaseUtil.java，不要忘记servlet在web.xml中需要注册。 项目结构： code:ServletDemo1.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.servlet.demo;import java.io.IOException;import java.sql.ResultSet;import java.sql.SQLException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSON;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import util.DatabaseUtil;public class ServletDemo1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletDemo1() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sql = "select * from user"; JSONArray jsonArray=new JSONArray(); //json数组 try &#123; ResultSet result = DatabaseUtil.query(sql); while (result.next()) &#123; JSONObject jObject=new JSONObject(); //json临时对象 jObject.put("id", result.getInt(1)); jObject.put("username", result.getString(2)); jObject.put("password", result.getString(3)); jsonArray.add(jObject); //将封装好的json对象放入json数组 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; String jsondata=jsonArray.toString(); //将json数组转换成字符串，供下面返回给android端使用 //System.out.println(jsondata); //本地测试用 response.getWriter().append(jsondata).flush(); &#125;&#125; DatabaseUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Statement;public class DatabaseUtil &#123; private static Connection mConnection; private static Connection getConnection() &#123; if (mConnection == null) &#123; String url = "jdbc:mysql://localhost:3306/mybatis"; try &#123; Class.forName("com.mysql.jdbc.Driver"); mConnection = (Connection) DriverManager.getConnection(url, "root", "123"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return mConnection; &#125; //这里只用了查询操作 public static ResultSet query(String querySql) throws SQLException &#123; Statement stateMent = (Statement) getConnection().createStatement(); return stateMent.executeQuery(querySql); &#125; public static void closeConnection() &#123; if (mConnection != null) &#123; try &#123; mConnection.close(); mConnection = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;ConnectTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.demo.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 本地测试结果在浏览器地址栏里输入（端口啥的自己改了的话用自己的，不多说）1http://localhost:8080/ConnectTest/ServletDemo1 测试结果： android端也比较简单，有两个activity，在mainactivity中有个button按钮，点击后跳转到第二个activity,我这里是ListActivity ,在listactivity中显示获取到的json数据。 用到的jar包 类 布局 code工具类 HttpUtil123456789101112package util;import okhttp3.OkHttpClient;import okhttp3.Request;public class HttpUtil &#123; public static void sendOkHttpRequest(String address,okhttp3.Callback callback)&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder().url(address).build(); client.newCall(request).enqueue(callback); &#125;&#125; 实体类 User123456789101112131415161718192021222324package com.ccc.connecttest.activity;public class User &#123; private int id; private String username; private String password; public User(int id,String username, String password)&#123; this.id=id; this.username=username; this.password=password; &#125; public int getId() &#123; return id; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125;&#125; 适配器 UserAdapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ccc.connecttest.activity;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.TextView;import com.ccc.connecttest.R;import java.util.List;public class UserAdapter extends ArrayAdapter&lt;User&gt; &#123; private int resourceId; public UserAdapter(Context context, int resourceId, List&lt;User&gt; objects) &#123; super(context, resourceId,objects); this.resourceId=resourceId; &#125; @Override public View getView(int position, View convertView,ViewGroup parent) &#123; User user=getItem(position); View view; ViewHolder viewHolder; if(convertView==null)&#123; view= LayoutInflater.from(getContext()).inflate(resourceId,parent,false); viewHolder=new ViewHolder(); viewHolder.userid=(TextView)view.findViewById(R.id.tv_id); viewHolder.username=(TextView)view.findViewById(R.id.tv_username); viewHolder.userpassword=(TextView)view.findViewById(R.id.tv_password); view.setTag(viewHolder); //将viewHolder存储在view中 &#125;else&#123; view=convertView; viewHolder=(ViewHolder)view.getTag(); &#125; viewHolder.userid.setText(String.valueOf(user.getId())); viewHolder.username.setText(user.getUsername()); viewHolder.userpassword.setText(user.getPassword()); return view; &#125; static class ViewHolder&#123; TextView userid; TextView username; TextView userpassword; &#125;&#125; 显示的页面 ListActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.ccc.connecttest.activity;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.ListView;import com.ccc.connecttest.R;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import java.util.ArrayList;import java.util.List;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Response;import util.HttpUtil;public class ListActivity extends AppCompatActivity &#123; private List&lt;User&gt; userList=new ArrayList&lt;&gt;(); private ListView listView; private String json_url="http://192.168.2.133:8080/ConnectTest/ServletDemo1";//本地Tomcat刚才测试的地址 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); queryFromServer(json_url); //处理取得数据 listView=findViewById(R.id.lv); UserAdapter adapter = new UserAdapter(ListActivity.this, R.layout.user, userList); listView.setAdapter(adapter); &#125; private void queryFromServer(String json_url) &#123; HttpUtil.sendOkHttpRequest(json_url, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.i("error","出现错误！"); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseText=response.body().string(); try &#123; JSONArray jsonArray=new JSONArray(responseText); for(int i=0;i&lt;jsonArray.length();i++)&#123; JSONObject jsonObject=jsonArray.getJSONObject(i); String id=jsonObject.getString("id"); String username=jsonObject.getString("username"); String password=jsonObject.getString("password"); User user=new User(Integer.parseInt(id),username,password); userList.add(user); Log.i("user","添加了一个User"); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 主页面 MainActivity123456789101112131415161718192021222324252627package com.ccc.connecttest.activity;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import com.ccc.connecttest.R;public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button=findViewById(R.id.btnSign); //点击跳转到显示页面 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, ListActivity.class)); &#125; &#125;); &#125;&#125; 配置 AndroidManifest.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.ccc.connecttest"&gt; &lt;!-- 千万不要忘了申请使用网络权限--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".activity.MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 这个ListActivity不要忘记注册--&gt; &lt;activity android:name=".activity.ListActivity"/&gt; &lt;/application&gt;&lt;/manifest&gt; 布局activity_main.xml: 123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;Button android:layout_marginTop="200dp" android:id="@+id/btnSign" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="获取" /&gt;&lt;/LinearLayout activity_list.xml:123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ListView android:id="@+id/lv" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; listview每一项适配文件： user.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="15dp"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_id" android:text="1111" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="18sp" /&gt; &lt;TextView android:text="2222" android:id="@+id/tv_username" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="14sp" /&gt; &lt;TextView android:text="3333" android:id="@+id/tv_password" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#d97e87" android:textSize="16sp" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 结果图 项目下载点击下载]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Tomcat服务器接收android端上传的数据]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%9C%AC%E5%9C%B0Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6android%E7%AB%AF%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[大体描述android端提交账号和密码，Tomcat服务器端会接收到，eclipse的控制台输出得到的账号和密码。 Tomcat服务器端先建立了一个javaweb项目，我这项目名是ConnectTest,然后在建立了一个包，在这个包下建立了一个servlet文件，我这命名为ServletDemo1。建立完servlet文件后，千万不要忘记在web.xml中注册，下面我将贴一下具体代码实现和项目结构。 项目结构超级简单： ServletDemo1.java12345678910111213141516171819202122232425262728293031package com.servlet.demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletDemo1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public ServletDemo1() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取请求的数据，并向控制台输出 String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println("-----&gt; doPost username:" + username + " password:" + password); &#125;&#125; web.xml也很简单就是对上面的那个servlet进行注册：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;ConnectTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.demo.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletDemo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; android端因为只是一个简单的例子，所以页面很简单，两个输入框，一个输入账号，一个输入密码，点击发送按钮后，账号和密码会提交到Tomcat服务器端，所以eclipse这边的Tomcat服务器控制台会输出账号和密码。 界面 项目结构这里只贴上java代码实现部分的结构，布局部分的默认就行： 可以看到建了两个包，一个client是存放线程类的，另外一个主界面类。 HttpThread.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.client;import android.util.Log;import java.io.IOException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;public class HttpThread extends Thread &#123; private String url; private String username; private String password; public HttpThread(String url, String username, String password)&#123; this.url=url; this.username=username; this.password=password; &#125; public void send() throws IOException &#123; //将username和password传给Tomcat服务器 url=url+"?username="+username+"&amp;password="+password; try &#123; Log.i("测试", "start"); //Log.i我用来测试调试的。 URL httpUrl=new URL(url); //获取网络连接 HttpURLConnection coon=(HttpURLConnection)httpUrl.openConnection(); //设置请求方法为Post coon.setRequestMethod("POST"); //设置访问超时时间 coon.setReadTimeout(5000); //调用getInputStream方法后，服务端才会收到请求，并阻塞式地接收服务端返回的数据 coon.getInputStream(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125; public void run()&#123; super.run(); try &#123; send(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; MainActivity.java:1234567891011121314151617181920212223242526272829303132333435363738package com.example.connecttest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.example.client.HttpThread;public class MainActivity extends AppCompatActivity &#123; private EditText username; private EditText password; private Button signup; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); username=(EditText)findViewById(R.id.account); password=(EditText)findViewById(R.id.password); signup=(Button)findViewById(R.id.btnSign); signup.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("1111", "1111111"); onLogin(); Toast.makeText(MainActivity.this,"success",Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void onLogin() &#123; String url="http://192.168.2.133:8080/ConnectTest/ServletDemo1"; new HttpThread(url,username.getText().toString().trim(),password.getText().toString().trim()).start(); &#125;&#125; AndroidManifest.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.connecttest"&gt; &lt;!-- 申请权限--&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 布局 activity_main.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;EditText android:layout_marginTop="100dp" android:id="@+id/account" android:layout_width="match_parent" android:layout_height="60dp" android:text="请输入账号：" android:background="#FCF2A4"/&gt; &lt;EditText android:layout_marginTop="5dp" android:id="@+id/password" android:layout_width="match_parent" android:layout_height="60dp" android:text="请输入密码：" android:background="#FCF2A4"/&gt; &lt;Button android:layout_marginTop="5dp" android:id="@+id/btnSign" android:layout_width="match_parent" android:layout_height="50dp" android:text="发送" android:background="#67BAFD"/&gt;&lt;/LinearLayout&gt; 效果 eclipse端输出：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis逆向工程]]></title>
    <url>%2F2019%2F05%2F04%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[逆向工程？mybatis的一个主要的特点就是需要程序员自己编写sql，如果表太多的话，会很麻烦，所以mybatis官方提供了一个逆向工程，可以针对单表自动生成mybatis执行所需要的代码（包括mapper.xml、mapper.java、po..）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。 逆向工程的jar包下载点击下载逆向工程 mybatis-generator-core jar包 进去之后 点击那个 Download……就行，就是下图中圈出来的那个。 项目结构这里说一下，这是项目最终的结构了，在最初，只需要在 src 下面建立一个包，再在这个包下建立一个最后我们要运行的java文件即可，我这里是 GeneratorSqlmap.java ，那些com.mybatis.mapper和com.mybatis.po都是我们运行刚才的java文件后自动生成的，下面会说一下。 项目完整配置过程1导入所需jar包，大体就是在学mybatis时的那些jar包，如下图： 划线的是最重要的几个包，像第一个就是我们刚才下载的逆向工程核心包。 2在src下新建一个包，我这里建的是 com.mybatis.generator 包，再在这个包下建立一个用于最后运行的java文件，我这里是 GeneratorSqlmap.java ,具体代码会在下面贴上。 3在src下建立一个文件 log4j.properties ,这个就是我们学mybatis时用过的，直接拿过来用也行，但必须放在 src 下，不然运行项目后，会出现如下警告：123log4j:WARN No appenders could be found for logger (org.mybatis.generator.logging.LogFactory).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 4在项目下建立一个 generatorConfig.xml 文件，用于具体配置 5运行刚才创建的 GeneratorSqlmap.java 文件，就会看到src 下多了两个包，一个是mapper的包，一个是po的包 code:GeneratorSqlmap.java: 1234567891011121314151617181920212223242526272829303132333435363738package com.mybaits.generator;import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定逆向工程配置文件 File configFile = new File("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; log4j.properties： 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n generatorConfig.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone = GMT" userId="root" password="123"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置，重要！！ --&gt; &lt;javaModelGenerator targetPackage="com.mybatis.po" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置，重要！！ --&gt; &lt;sqlMapGenerator targetPackage="com.mybatis.mapper" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mybatis.mapper" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt; &lt;table tableName="user"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 我这里只用了一个表，user 表： 最后完整的项目结构]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis和spring整合]]></title>
    <url>%2F2019%2F05%2F03%2Fmybatis-spring%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[简述Mybatis将一些琐碎的事交给Spring来处理（像数据库链接，配置等），自身更加注重sql语句本身 整合思路 需要spring来管理数据源信息。 需要spring通过单例方式管理SqlSessionFactory。 使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成） 持久层的mapper都需要由spring进行管理，spring和mybatis整合生成mapper代理对象。 集成的对象1.jar包集成(主要导入Mybatis的jar包、spring的jar包、Mybatis-spring整合包、mysql的相关jar包，c3p0数据库连接池相关jar包，如果使用Junit测试的话，还要导入Junit的jar包，我用了)。 2.配置文件集成(两大配置文件，mybatis的全局配置文件SqlMapConfig.xml和spring的核心配置文件applicationContext.xml)。 3.SqlSessionFactory集成。 4.Mapper接口集成。 结构图 编写applicationContext.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;!-- 加载 db.properties 中的参数设置，要引用db.properties中的参数，这句必须要有--&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 将数据库连接的操作交给spring，这里用的是c3p0连接池，需要导入c3p0的相关jar包--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的SqlSessionFactory，需要注入全局配置文件和连接池 --&gt; &lt;bean id="sqlSessionFactoryId" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="configLocation" value="SqlMapConfig.xml"&gt;&lt;/property&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置批量mapper代理开发模式，这里就不能指定id了,而是通过引用具体的 mapper类名来获取mapper对象，进而操作函数--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.qqq.dao"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactoryId"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; dao设计–UserMapper.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qqq.dao.UserMapper"&gt; &lt;!-- 这里只是举例了查询的例子 --&gt; &lt;select id="findUserById" parameterType="int" resultType="com.qqq.domain.User"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id="findUserAll" resultType="com.qqq.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; dao设计–UserMapper.java 接口123456789package com.qqq.dao;import java.util.List;import com.qqq.domain.User;public interface UserMapper &#123; public User findUserById(int id); public List&lt;User&gt; findUserAll();&#125; 在SqlMapconfig.xml中加载UserMapper.xml12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 如果mapper.xml和mapper.java接口在同一个目录，此处也可不用定义mappers --&gt; &lt;mappers&gt; &lt;mapper resource="com/qqq/dao/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 主体类–User.java123456789101112131415161718192021222324252627282930package com.qqq.domain;import javax.swing.Spring;public class User &#123; private int id; private String username; private int userage; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String toString() &#123; return "User [id=" + id + ", username=" + username + ", userage=" + userage + "]"; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getUserage() &#123; return userage; &#125; public void setUserage(int userage) &#123; this.userage = userage; &#125;&#125; db.properties1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMTjdbc.username=rootjdbc.password=123 log4j.properties123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 测试类 Test1.java1234567891011121314151617181920212223package com.qqq.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.qqq.dao.UserMapper;import com.qqq.domain.User;public class Test1 &#123; //这里用了Junit 所以不能忘记加 @Test @Test public void testMultiMapper()&#123; String springxml="applicationContext.xml"; ApplicationContext context=new ClassPathXmlApplicationContext(springxml); UserMapper userMapper=(UserMapper) context.getBean("userMapper"); //查找id号为2的用户信息 User user=userMapper.findUserById(2); System.out.println(user); &#125;&#125; 数据库表 测试结果]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML特殊字符编码对照表]]></title>
    <url>%2F2019%2F04%2F24%2FHTML%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[HTML特殊字符编码对照表]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中限定类名和非限定类名]]></title>
    <url>%2F2019%2F04%2F24%2FJava%E4%B8%AD%E9%99%90%E5%AE%9A%E7%B1%BB%E5%90%8D%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E7%B1%BB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[限定类名，就是类名全称，带包路径的用点隔开，例如: java.lang.String。 非限定(non-qualified)类名也叫短名，就是我们平时说的类名，不带包的，例如：String。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis链接MySQL出现异常，URL报错]]></title>
    <url>%2F2019%2F04%2F24%2FMyBatis%E9%93%BE%E6%8E%A5MySql%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Exception大体类似于下面这种报错 answer原来是这样写：1&lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone = GMT"/&gt; 改成如下形式就对了(即将上面那种写法的 ； 分号 改成 &amp; amp ; )1&lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone = GMT"/&gt; analysis&amp;amp；只是&amp;在xml下的形式 HTML中常用的特殊字符： &lt; 小于 &amp;lt; &amp;#60; &gt; 大于 &amp;gt; &amp;#62; &amp; &amp;符号 &amp;amp; &amp;#38; &quot; 双引号 &amp;quot; &amp;#34; 更多的可以点击链接去查看： HTML特殊字符编码对照表]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MySql</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的存储和遍历]]></title>
    <url>%2F2019%2F04%2F07%2F%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[0.图 = 点 + 边 1.邻接矩阵表示12345678910 #define maxn 100typedef struct &#123; int no; //顶点编号 char data[maxn];//顶点的其他信息&#125;VertexType;typedef struct&#123; int edges[maxn][maxn]; //存放边的数组 int n, e; //顶点数，边数 VertexType vex[maxn][maxn]; //存放顶点数组&#125;MGraph; 2.邻接表表示12345678910111213typedef struct EdgeNode&#123; //边表结点 int adjvex; //该边的终点编号( 如u-&gt;v ，这里指的就是v的编号 ) int weight; //边的权值 struct EdgeNode *next; //指向下一条边的指针&#125;EdgeNode;typedef struct VextexNode&#123; char data; //顶点域，存储顶点信息 EdgeNode *firstedge; //边表头指针，指向连接的第一条边&#125;VextexNode, AdjList[maxn]; //AdjList是邻接表类型typedef struct&#123; AdjList adjList; //邻接表 int n, e; //图中顶点数和边数&#125;GraphAdjList; 附：用邻接表表示创建无向图(这里用的是头插法)：12345678910111213141516171819202122232425262728void CreateALGraph(GraphAdjList *Gp)&#123; int i, j, k; EdgeNode *pe; cout &lt;&lt; "输入顶点数和边数(空格分隔）:" &lt;&lt; endl; cin &gt;&gt; Gp-&gt;numNodes &gt;&gt; Gp-&gt;numEdges; for (i = 0 ; i &lt; Gp-&gt;numNodes; i++) &#123; cout &lt;&lt; "输入顶点信息：" &lt;&lt; endl; cin &gt;&gt; Gp-&gt;adjList[i].data; Gp-&gt;adjList[i].firstedge = NULL;/* 将边表置为空表 */ &#125; for (k = 0; k &lt; Gp-&gt;numEdges; k++)/* 建立边表 */ &#123; cout &lt;&lt; "输入边(u,v)的顶点序号i,j"&lt;&lt; endl; cin &gt;&gt; i &gt;&gt; j; pe = (EdgeNode *)malloc(sizeof(EdgeNode)); pe-&gt;adjvex = j; //边的终点编号为j // 将pe的指针指向当前顶点上指向的结点 pe-&gt;next = Gp-&gt;adjList[i].firstedge; Gp-&gt;adjList[i].firstedge = pe;/* 将当前顶点的指针指向pe */ //因为是无向图，所以下面还要以i作为边的终点 pe = (EdgeNode *)malloc(sizeof(EdgeNode)); pe-&gt;adjvex = i; pe-&gt;next = Gp-&gt;adjList[j].firstedge; Gp-&gt;adjList[j].firstedge = pe; &#125;&#125; 3.深度优先遍历注：INF是无穷，visited[] 是全局数组，用来标记点是否被访问，初始置为0 1.邻接矩阵：12345678910void DFS(MGraph g, int v)&#123; int w; cout &lt;&lt; v; //输出当前访问的结点 visited[v] = 1; //将已访问的置为1 for (w = 0; w &lt; g.n; w++)&#123; //找当前顶点v的所有邻接顶点 if (g.edges[v][w] != 0 &amp;&amp; g.edges[v][w] != INF&amp;&amp;visited[w] == 0)&#123; //找顶点v未访问过的邻接点w DFS(g, w); &#125; &#125;&#125; 2.邻接表：123456789101112void DFS(GraphAdjList *g, int v)&#123; EdgeNode *p; cout &lt;&lt; v; //输出当前访问的点 visited[v] = 1; //已访问的置为1 p = g-&gt;adjList[v].firstedge; //p指向顶点v的第一个边邻接点 while (p != NULL)&#123; if (visited[p-&gt;adjvex] == 0)&#123; DFS(g, p-&gt;adjvex); //若p-&gt;adjvex顶点未访问，递归访问它 &#125; p = p-&gt;next; //p指向顶点v的下一个邻接点 &#125;&#125; 4.广度优先遍历(层次)1.邻接矩阵：12345678910111213141516171819202122void BFS(MGraph g, int v)&#123; queue&lt;int&gt; qu; //定义一个队列 qu int visited[maxn]; //定义一个存放结点打的访问标志的数组 int w, i; memset(visited, 0, sizeof(visited)); //初始化访问标志数组 cout &lt;&lt; v; //输出当前访问的顶点编号 visited[v] = 1; //已访问的置为1 qu.push(v); //v进队 while (!qu.empty())&#123; //队列不空时循环 w = qu.front(); qu.pop(); //出队队首顶点 for (int i = 0; i &lt; g.n; i++)&#123; //若当前相邻顶点i未被访问 if (g.edges[v][i] != 0 &amp;&amp; g.edges[v][i] != INF&amp;&amp;visited[i] == 0)&#123; cout &lt;&lt; i; //访问相邻顶点 visited[i]=1; //已访问的置为1 qu.push(i); //该顶点进队 &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 2.邻接表：12345678910111213141516171819202122232425void BFS(GraphAdjList* g, int v)&#123; EdgeNode *p; queue&lt;int&gt; qu; //定义一个队列 qu int visited[maxn]; //定义一个存放结点打的访问标志的数组 int w, i; memset(visited, 0, sizeof(visited)); //初始化访问标志数组 cout &lt;&lt; v; //输出当前访问的顶点编号 visited[v] = 1; //已访问的置为1 qu.push(v); //v进队 while (!qu.empty())&#123; //队列不空时循环 w = qu.front(); qu.pop(); //出队队首顶点w p = g-&gt;adjList[w].firstedge; //找顶点w的第一个邻接点 while (p != NULL)&#123; //若当前相邻的顶点未被访问 if (visited[p-&gt;adjvex] == 0)&#123; cout &lt;&lt; p-&gt;adjvex; //访问相邻顶点 visited[p-&gt;adjvex] = 1; //已访问的置为1 qu.push(p-&gt;adjvex); //该顶点进队 &#125; p = p-&gt;next; //找顶点w的下一个邻接点 &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列求哈夫曼编码长度]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AD%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[problem：数据结构实验之二叉树六：哈夫曼编码 code:123456789101112131415161718192021222324252627282930313233343536 #include&lt; iostream&gt; #include&lt; queue&gt; #include&lt; functional&gt;using namespace std;int main()&#123; char s[1000]; int t[500]; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; while (cin &gt;&gt; s)&#123; int sum1, sum2 = 0; memset(t, 0, sizeof(t)); int len = strlen(s); sum1 = len * 8; for (int i = 0; i &lt; len; i++)&#123; t[s[i]]++; //将字符串中的字符转化为ASCII码中的编号存入数组中，并且记录个数 &#125; for (int i = 0; i &lt; 500; i++)&#123; if (t[i] != 0)&#123; q.push(t[i]); &#125; &#125; while (!q.empty())&#123; //每次取出最小的两个也就是队列最开始两个，相加产生的新数据存入队列中 int x1 = q.top(); q.pop(); if (!q.empty())&#123; //这里要判断一下，上一步取出x1后队列是不是空了,避免在空的队列中操作 int x2 = q.top(); q.pop(); int x3 = x1 + x2; sum2 += x3; q.push(x3); &#125; &#125; printf("%d %d %.1lf\n", sum1, sum2, 1.0 * sum1 / sum2); &#125; return 0;&#125; 还有一道类似的搬东西的题合并果子之哈夫曼树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树概念平衡二叉树建立在二叉排序树的基础上，目的是使二叉排序树的平均查找长度更小，即让各结点的深度尽可能小，因此，树中每个结点的两棵子树的深度不要偏差太大。平衡二叉树的递归定义：平衡二叉树是一棵二叉树，其可以为空，或满足如下2个性质：①左右子树深度之差的绝对值不大于1。②左右子树都是平衡二叉树。 平衡因子的概念：结点的平衡因子 = 结点的左子树深度 — 结点的右子树深度。若平衡因子的取值为-1、0或1时，该节点是平衡的，否则是不平衡的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt;using namespace std;typedef int ElementType;typedef struct AVLNode&#123; ElementType Data; struct AVLNode* Left; struct AVLNode* Right;&#125;*AVLTree;//计算树高int GetHeight(AVLTree A)&#123; int HL, HR, MaxH; if (A == NULL) return 0; else&#123; HL = GetHeight(A-&gt;Left); HR = GetHeight(A-&gt;Right); MaxH = max(HL, HR); return (MaxH + 1); &#125;&#125;//左单旋（左左型LL：需顺时针转,即插入的结点在不平衡结点的左孩子的左子树上，导致根节点的平衡因子由1变为2）AVLTree SingleLeftRotation(AVLTree A)&#123; AVLTree B = A-&gt;Left; A-&gt;Left = B-&gt;Right; B-&gt;Right = A; return B;&#125;//右单旋（右右型RR：需逆时针转,即插入的结点在不平衡结点的右孩子的右子树上，导致根节点的平衡因子由1变为2）AVLTree SingleRightRotation(AVLTree A)&#123; AVLTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; return B;&#125;//左-右双旋（左右型LR：即插入的结点在不平衡结点的左孩子的右子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleLeftRightRotation(AVLTree A)&#123; A-&gt;Left = SingleRightRotation(A-&gt;Left); return SingleLeftRotation(A);&#125;//右-左双旋（右左型RL：即插入的结点在不平衡结点的右孩子的左子树上，导致根节点的平衡因子由1变为2）//可以这样想：先对不平衡结点的左子树 A-&gt;Left 进行右单璇（即逆时针来转，转完后不平衡结点及其左子树就变成了左左的形式了，只需再对 A 进行前面简单的左单璇即顺时针转即可）AVLTree DoubleRightLeftRotation(AVLTree A)&#123; A-&gt;Right = SingleLeftRotation(A-&gt;Right); return SingleRightRotation(A);&#125;//插入结点AVLTree Insert(AVLTree A, ElementType X)&#123; if (!A)&#123; A = (AVLTree)malloc(sizeof(struct AVLNode)); A-&gt;Data = X; A-&gt;Left = A-&gt;Right = NULL; &#125; else if (X&lt;A-&gt;Data)&#123; A-&gt;Left = Insert(A-&gt;Left, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == 2) if (X&lt;A-&gt;Left-&gt;Data) A = SingleLeftRotation(A);//左左型(LL)需要右旋转 else A = DoubleLeftRightRotation(A);//左右型(LR)需要左右旋转 &#125; else if (X&gt;A-&gt;Data)&#123; A-&gt;Right = Insert(A-&gt;Right, X); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == -2) if (X&gt;A-&gt;Right-&gt;Data) A = SingleRightRotation(A);//右右型(RR)需要左旋转 else A = DoubleRightLeftRotation(A);//右左型(RL)需要右左旋转 &#125; return A;&#125;int main()&#123; AVLTree A = NULL; int n, t; cin &gt;&gt; n; for (int i = 0; i&lt;n; i++)&#123; cin &gt;&gt; t; A = Insert(A, t); &#125; //输出了根节点 cout &lt;&lt; A-&gt;Data &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用maven在eclipse中创建java web项目]]></title>
    <url>%2F2019%2F04%2F02%2Fmaven%E5%88%9B%E5%BB%BAjavaweb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.菜单-&gt;File-&gt;New-&gt;Other-&gt;Maven-&gt;Maven Project 点击next 2. 点击next 3.这个界面，选择 maven-archetype-webapp 。 点击next 4.这个界面，填写自己项目的信息。 5.现在得到的项目会出现红叉，即报错原因有两个： 没有java源代码目录 index.jsp报错 6.创建java源代码目录在上一步的截图中可以发现，没有地方存放java源文件，这个时候就需要按照如下步骤做：右键项目-&gt;属性-&gt;Java Build Path-&gt;Libraries-&gt;Edit-&gt;Workspace defaultJRE(jdk8)-&gt;Finish如图： 会出现下图效果： 7.通过pom.xml添加servlet jar包这个时候，还存在index.jsp会 报错的问题。 这个问题的解决办法是添加servlet.jar包。 双击pom.xml，出现pom专有的编辑页面。点击OverView右边的Dependencies可以看到里面有一个默认存在的junit然后点击Add，弹出选择窗口在中间 Enter GroupId, artifactId or sha1 prefix or pattern(*)…. 这个地方输入servlet，下面就会出来被搜索到的servlet jar包选中它，并点击ok 注: Scope要选择compile，表示编译期间要用到。 如下图：(前两个带星号的自己随便填个东西就行) 8.保存更改，项目报错消除了 9.运行 输出 helloworld！接下来只需像一般的javaweb项目那样，将这个项目添加到Tomcat里运行即可。 在浏览器输入： 1http://localhost:8080/j2ee 关于在pom.xml文件中添加依赖包时搜索不到servlet包的问题1.菜单-&gt;Window-&gt;preferences-&gt;maven 选中Download respository…… 那一项 2.菜单-&gt;Window-&gt;Show View-&gt;Other-&gt;Maven-&gt;Maven Repositories选中 Global Repositories 下的 alimaven 点击右键选择 Full Index Enabled (如果maven仓库已修改为阿里云仓库，就会有alimaven),点击后 eclipse 会自动开始下载所有的 jar 包，下载完成后，再右键 Local Respositories 选择 Rebuild Index 即可。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在eclipse中集成maven]]></title>
    <url>%2F2019%2F04%2F02%2Feclipse%E4%B8%AD%E9%9B%86%E6%88%90maven%2F</url>
    <content type="text"><![CDATA[1.集成mavenEclipse EE版本是已经集成好MAVEN的了，无需额外手动集成可以去官网下一个eclipse ee 2.设置maven路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;Installations-&gt;add-&gt;Directory…选择你的maven安装后的文件夹 把原来的那个低版本maven删除掉，如果有的话 3.设置仓库路径菜单-&gt;Window-&gt;Preferences-&gt;Maven-&gt;User Settings-&gt;Global Settings 和 User Settings都使用我们在上篇文章中自己设置的仓库下的 setting.xml 文件。 点击一下Reindex,确保 local Repository为我们设置的本地仓库位置 1D:\maven-repository]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F04%2F01%2Fmaven%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录一下Maven的下载和环境变量的配置 下载官方下载地址 我下载的时候最新版本如下，去上面的官网点击即可下载。 配置环境变量1.右键我的电脑-属性-高级系统设置-环境变量-系统变量-Path-编辑-新建。 这里填入你下载的 maven 目录下 bin 目录的地址。 2.使用win+r(或右键开始菜单，选择运行), 然后输入cmd 打开命令行，输入 1mvn -v 若出现下图所示的，则配置成功。 maven仓库的相关修改仓库，顾名思义是用来存放项目需要的jar包的，maven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。maven仓库的默认位置是在 C:\Users\你的用户名.m2\repository 因为刚下载和配置好并没有运行过，所以C盘中会看不到这个目录。因为我们需要的各种jar包都是放在这的，所以放在c盘感觉并不好，接下来就更改一下仓库的位置，放到D盘中。 在D盘中新建一个文件夹叫 maven-repository ，在你的maven安装目录下的conf文件夹下找到 setting.xml 文件，参考我的 D:\apache-maven-3.6.0\conf\setting.xml,打开找到下图的内容将 localRepository 这对标签内填上刚才创建的maven-repository文件夹的地址。 然后将这个 setting.xml 文件复制一个，粘贴到刚才的maven-repository文件夹下，以后新建项目maven自动将下载的依赖包放到该文件夹下。 使用阿里云仓库maven 会默认从maven官方提供的服务器下载jar包。而官方服务器在国外，被墙了，下的贼慢。 为了快速下载相关jar包，可以使用国内maven 阿里云的下载地址 打开刚才创建的 maven-repository文件夹下的 setting.xml 文件 找到 mirrors 这对标签，在里面添加如下代码即可。123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 如下图：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树 SDUTOJ 2482]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91SDUTOJ2482%2F</url>
    <content type="text"><![CDATA[problem:点击跳转到题目 understand:学了二叉树，得知先序和中序遍历或者后序和中序遍历都可以唯一确定一颗二叉树，所以这里我们采用求先序序列进行比较的方法。因为二叉排序树的中序遍历一定是递增序列都一样，所以此题只需比较每棵树的先序序列即可。 code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int z[11];int ccount;void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree(int a[])&#123; tree t = NULL; int key; for (int i = 0; i &lt; 9; i++)&#123; Inserttree(t, a[i]); &#125; return t;&#125;//先序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; z[ccount++] = t-&gt;data; traveltree(t-&gt;left); traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; int n; while (cin &gt;&gt; n&amp;&amp;n != 0)&#123; ccount = 0; string s = ""; cin &gt;&gt; s; int b[11],c[11],d[11]; //下面是 输入的第一串字符 构建二叉排序树并先序遍历后 得到的数组 c for (int i = 0; i &lt;s.length();i++)&#123; b[i] = s[i] - '0'; &#125; t=CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; c[i] = z[i]; //前序遍历 &#125; // for (int i = 0; i &lt; n; i++)&#123; t = NULL; ccount = 0; cin &gt;&gt; s; //下面是 输入的要进行比较的字符串 构建二叉排序树并先序遍历后 得到的数组 d for (int i = 0; i &lt;s.length(); i++)&#123; b[i] = s[i] - '0'; &#125; t = CreateTree(b); traveltree(t); for (int i = 0; i &lt; s.length(); i++)&#123; d[i] = z[i]; //前序遍历 &#125; //下面是比较两个树 先序遍历的结果 c和d ，相同则YES ，不同则NO int flag = 0; for (int i = 0; i &lt; s.length(); i++)&#123; if (c[i] != d[i])&#123; cout &lt;&lt; "NO" &lt;&lt; endl; flag = 1; break; &#125; &#125; if (!flag)&#123; cout &lt;&lt; "YES" &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[理解：二叉排序树或者是一颗空树，或者是具有下列性质的二叉树：(1):若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值 (2):若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值 (3):它的左、右子树也分别为二叉排序树 code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;typedef struct node&#123; int data; struct node* left; struct node* right;&#125;*tree;int n; //含有n个结点//插入void Inserttree(tree &amp;t, int key)&#123; tree f, p = t; //寻找待插入的节点的位置，用f记录待插入节点的父结点 while (p)&#123; if (p-&gt;data == key)&#123; return; &#125; else&#123; f = p; if (p-&gt;data &gt; key)&#123; p = p-&gt;left; &#125; else&#123; p = p-&gt;right; &#125; &#125; &#125; //创建新结点，插入 p = (tree)malloc(sizeof(node)); p-&gt;data = key; p-&gt;left = p-&gt;right = NULL; if (t == NULL)&#123; t = p; &#125; else&#123; if (f-&gt;data &gt; key)&#123; f-&gt;left = p; &#125; else&#123; f-&gt;right = p; &#125; &#125;&#125;//创建二叉排序树tree CreateTree()&#123; tree t = NULL; int key; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; key; Inserttree(t, key); &#125; return t;&#125;//中序遍历void traveltree(tree t)&#123; if (t != NULL)&#123; traveltree(t-&gt;left); cout &lt;&lt; t-&gt;data &lt;&lt; " "; traveltree(t-&gt;right); &#125;&#125;int main()&#123; tree t = NULL; cin &gt;&gt; n; t = CreateTree(); traveltree(t); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的同构]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[附上题目链接：二叉树的同构 理解：只要确保每个节点和其左右孩子的结点相等，或者孩子交换之后相等就可以。只要每个结点都符合，那么整棵树自然从上到下就都符合。 code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;iostream&gt; #include&lt;cstdio&gt;using namespace std;const int maxn = 20;struct node&#123; char key; int left, right;&#125;tree1[maxn], tree2[maxn]; //构建一个结构体用来构建两个二叉树int n1, n2;void build_tree(struct node * tree, int n)&#123; int i; char s[2]; for (i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s; tree[i].key = s[0]; cin &gt;&gt; s; if (s[0] == '-')&#123; tree[i].left = 11; //如果输入为 - 则置为一个非0到10的数 &#125; else&#123; tree[i].left = s[0] - '0'; //字符向数字转换 &#125; cin &gt;&gt; s; if (s[0] == '-')&#123; tree[i].right = 11; &#125; else&#123; tree[i].right = s[0] - '0'; &#125; &#125;&#125;bool checkc(int i, int j)&#123; //检测key相同的两个结点的左右孩子是否相同或者交换后是否相同 if (tree1[tree1[i].left].key == tree2[tree2[j].left].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].right].key) &#123; return 1; &#125; if (tree1[tree1[i].left].key == tree2[tree2[j].right].key&amp;&amp;tree1[tree1[i].right].key == tree2[tree2[j].left].key) &#123; return 1; &#125; return 0;&#125;bool check()&#123; int i, j; //找到key相同的结点 for (i = 0; i &lt; n1; i++)&#123; for (j = 0; j &lt; n2; j++)&#123; if (tree1[i].key == tree2[j].key)&#123; if (checkc(i, j))&#123; break; //孩子相同或者交换后相同继续下一个结点 &#125; else&#123; return 0; &#125; &#125; &#125; if (j == n2)&#123; return 0; //没找到 &#125; &#125; return 1; //整棵二叉树都符合条件&#125;int main()&#123; while (cin&gt;&gt;n1)&#123; build_tree(tree1, n1); cin&gt;&gt;n2; build_tree(tree2, n2); if (n2!=n1)&#123; cout &lt;&lt; "No"&lt;&lt;endl; &#125; else if (check())&#123; cout &lt;&lt; "Yes"&lt;&lt;endl; &#125; else&#123; cout &lt;&lt; "No"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求二叉树的深度，递归和非递归]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[递归： 123456789101112131415int high(Tree t)//求二叉树的高度&#123; int n,m; if(t==NULL) return 0; else &#123; n=high(t-&gt;lchild); //对左子树求高度 m=high(t-&gt;rchild); //对右子树求高度 if(n&gt;m) //高度为取两者中大的值+1 return n+1; else return m+1; &#125;&#125; 非递归（队列）：12345678910111213141516171819202122int high(Tree t)//求二叉树的高度&#123; int depth = 0; Tree p=NULL; queue&lt;Tree&gt; q; q.push(t); //根节点入队 while (!q.empty())&#123; depth++; //每到新的一层 高度+1 int width = q.size(); //求出本层的结点数 while (width--)&#123; //本层结点全部出队 p = q.front(); q.pop(); if (p-&gt;left)&#123; q.push(p-&gt;left); &#125; if (p-&gt;right)&#123; q.push(p-&gt;right); &#125; &#125; &#125; return depth;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定先序和中序序列,求后序序列]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%B1%82%E5%90%8E%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[要求：输入二叉树的先序遍历序列和中序遍历序列，输出该二叉树的后序遍历序列。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;//由先序序列s1[0···n-1]和中序序列s2[0···n-1]建立二叉链存储结构的二叉树//s1:先序遍历字符串 s2:中序遍历字符串 n:结点个数Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s1[0]; //根节点的值 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s2[k] == root)&#123; //在s2中查找 根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1 + 1, s2, k); //递归创建左子树 bt-&gt;rchild = creattree(s1 + k + 1, s2 + k + 1, n - k - 1); //递归创建右子树 return bt;&#125;//后序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); cout &lt;&lt; t-&gt;value; &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： ABDCEF BDAECF 输出： DBEFCA 附：已知中序后序求先序代码：12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;iostream&gt; #include&lt;string&gt;using namespace std;int i;char s1[100],s2[100];typedef struct Node&#123; char value; Node *lchild; Node *rchild;&#125;*Tree;Tree creattree(char s1[],char s2[],int n)&#123; int k; if (n &lt;= 0)&#123; return NULL; &#125; char root = s2[n-1]; //这里和上面的不一样 后序遍历的最后一个元素才是 根节点 Tree bt = (Tree)malloc(sizeof(Node)); bt-&gt;value = root; for (k = 0; k &lt; n; k++)&#123; if (s1[k] == root)&#123; //在中序序列中查找根节点 break; &#125; &#125; bt-&gt;lchild = creattree(s1, s2, k); bt-&gt;rchild = creattree(s1 + k + 1, s2 + k, n - k - 1); //注意这里的范围 s2+k 画一画就明白了 return bt;&#125;//先序遍历void traveltree2(Tree t)&#123; if (t != NULL)&#123; cout &lt;&lt; t-&gt;value; traveltree2(t-&gt;lchild); traveltree2(t-&gt;rchild); &#125; &#125;int main()&#123; Tree t = NULL; cin &gt;&gt; s1&gt;&gt;s2; string s = s1; t = creattree(s1, s2, s.size()); traveltree2(t); return 0;&#125; 输入： dbgeafc dgebfca 输出： abdegcf]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(4)]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%80%82%E9%85%8D%E5%99%A8%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下适配器容器1.stack（栈容器）实现头文件：&lt; stack&gt; 概述： 它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。例如，以下语句指定myst栈的底层容器为vector： 1stack&lt;string,vector&lt;string&gt; &gt; myst; //第2个参数指定底层容器为vector 主要成员函数： empty()：判断栈容器是否为空 size()：返回栈容器中实际元素个数 push(elem)：元素elem进栈 top()：返回栈顶元素 pop()：元素出栈 注意：stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 演示代码： #include&lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); printf(&quot;栈顶元素: %d\n&quot;, st.top()); printf(&quot;出栈顺序: &quot;); while (!st.empty()) //栈不空时出栈所有元素 { printf(&quot;%d &quot;, st.top()); st.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 栈顶元素: 3 出栈顺序: 3 2 1 2.queue（队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 主要成员函数： empty()：判断队列容器是否为空。 size()：返回队列容器中实际元素个数。 front()：返回队头元素。 back()：返回队尾元素。 push(elem)：元素elem进队。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { queue&lt;int&gt; qu; qu.push(1); qu.push(2); qu.push(3); printf(&quot;队头元素: %d\n&quot;, qu.front()); printf(&quot;队尾元素: %d\n&quot;, qu.back()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.front()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 1 队尾元素: 3 出队顺序: 1 2 3 3.priority_queue（优先队列容器）实现头文件：&lt; queue&gt; 概述： 它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。比如：对于 int 类型的元素，priority_queue 默认元素值越大越优先。 主要成员函数： empty()：判断优先队列容器是否为空。 size()：返回优先队列容器中实际元素个数。 push(elem)：元素elem进队。 top()：获取队头元素。 pop()：元素出队。 代码演示： #include&lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main() { priority_queue&lt;int&gt; qu; qu.push(3); qu.push(1); qu.push(2); printf(&quot;队头元素: %d\n&quot;, qu.top()); printf(&quot;出队顺序: &quot;); while (!qu.empty()) //出队所有元素 { printf(&quot;%d &quot;, qu.top()); qu.pop(); } printf(&quot;\n&quot;); return 0; } 输出： 队头元素: 3 出队顺序: 3 2 1 (可见是按照值的大小出队) 注： 优先队列默认是自动的从大到小排列，想要让它从小到大排列，可以包含头文件 &lt; functional&gt;,再如下形式声明即可 1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q; //会对入队的元素从小到大排列]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(3)]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下关联容器1.set（集合容器）/ multiset（多重集容器）实现头文件：&lt; set&gt;概述： set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 insert()：插入元素 erase()：从容器删除一个或几个元素 clear()：删除所有元素 count(k)：返回容器中关键字k出现的次数 find(k)：如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值 upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素 lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;int&gt; s; //定义set容器s set&lt;int&gt;::iterator it; //定义set容器迭代器it s.insert(1); s.insert(3); s.insert(2); s.insert(4); s.insert(2); printf(&quot; s: &quot;); for (it = s.begin(); it != s.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); multiset&lt;int&gt; ms; //定义multiset容器ms multiset&lt;int&gt;::iterator mit; //定义multiset容器迭代器mit ms.insert(1); ms.insert(3); ms.insert(2); ms.insert(4); ms.insert(2); printf(&quot;ms: &quot;); for (mit = ms.begin(); mit != ms.end(); mit++) printf(&quot;%d &quot;, *mit); printf(&quot;\n&quot;); return 0; } 输出： s: 1 2 3 4 ms: 1 2 2 3 4 2.map（映射容器）/ multimap（多重映射容器）实现头文件：&lt; set&gt; 概述： map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。在map和multimap 中的key和value是一个pair类结构。pair类结构的声明形如： 1234struct pair&#123; T first; T second;&#125; map/multimap利用pair的&lt;运算符将所有元素即key-value对按key的升序排列，以红黑树的形式存储，可以根据key快速地找到与之对应的value（查找时间为O(log2n)）。map中不允许关键字重复出现，支持[]运算符；而multimap中允许关键字重复出现，但不支持[]运算符。 主要成员函数： empty()：判断容器是否为空 size()：返回容器中实际元素个数 map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap) insert(elem)：插入一个元素elem并返回该元素的位置 clear()：删除所有元素 find()：在容器中查找元素 count()：容器中指定关键字的元素个数（map中只有1或者0） 迭代器函数：begin()、end()、rbegin()、rend() 演示代码： 1.12map&lt;char,int&gt; mymap; //定义map容器mymap，其元素类型为pair&lt;char,int&gt;mymap['a'] = 1; //或者mymap.insert(pair&lt;char，int&gt;('a',1) ); 2. #include&lt;iostream&gt; #include &lt;map&gt; using namespace std; int main() { map&lt;char, int&gt; mymap; //定义map容器mymap mymap.insert(pair&lt;char, int&gt;(&apos;a&apos;, 1)); //插入方式1 mymap.insert(map&lt;char, int&gt;::value_type(&apos;b&apos;, 2)); //插入方式2 mymap[&apos;c&apos;] = 3; //插入方式3 map&lt;char, int&gt;::iterator it; for (it = mymap.begin(); it != mymap.end(); it++) printf(&quot;[%c,%d] &quot;, it-&gt;first, it-&gt;second); printf(&quot;\n&quot;); return 0; } 输出： [a,1] [b,2] [c,3]]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(2)]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A81%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下顺序容器1.vector(向量容器)实现头文件：&lt; vector&gt;定义方式：1234vector&lt;int&gt; v1; //定义元素为int的向量v1vector&lt;int&gt; v2(10); //指定向量v2的初始大小为10个int元素vector&lt;double&gt; v3(10,1.23); //指定v3的10个初始元素的初值为1.23vector&lt;int&gt; v4(a,a+5); //用数组a[0···4]共5个元素初始化v4 主要成员函数： empty(): 判断当前向量是否为空。 size(): 返回当前向量容器中的实际元素个数。 [ ]: 返回指定下标的元素。 reserve(n): 为当前向量容器预分配n个元素的存储空间。 capacity(): 返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 resize(n): 调整当前向量容器的大小，使其能容纳n个元素。 push_back(): 在当前向量容器尾部添加一个元素。 insert(pos,elem): 在pos位置插入元素elem，即将元素elem插入到迭代器指定的元素之前。 front(): 获取当前向量容器的第一个元素。 back(): 获取当前向量容器的最后一个元素。 erase(): 删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 clear(): 删除当前向量容器中的所有元素。 begin(): 该函数的两个版本返回iterator或const_iterator,引用容器的第一个元素。 end(): 该函数的两个版本返回返回iterator或const_iterator,引用容器的最后一个元素后面的一个位置。 rbegin(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的最后一个元素。 rend(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的第一个元素的前面一个位置。 最后两个是反向迭代。 演示代码： #include&lt;iostream&gt; #include&lt; vector&gt; using namespace std; int main(){ vector&lt;int&gt; myv; //定义vector容器myv vector&lt;int&gt;::iterator it;//定义myv的正向迭代器 it myv.push_back(1); //在myv的末尾添加元素 1 it = myv.begin(); //it迭代器指向开头元素 1 myv.insert(it, 2); //在it指向的元素之前插入元素 2 myv.push_back(3); //在myv的末尾添加元素 3 myv.push_back(4); //在myv的末尾添加元素 4 it = myv.end(); //it 迭代器指向元素4的后面 it--; //it 迭代器指向元素 4 myv.erase(it); //删除元素4 for (it = myv.begin(); it != myv.end(); it++){ cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } return 0; } 2.string(字符串容器)实现头文件：&lt; string&gt;定义方式：123456char cstr[]="China! Greate Wall"; //C-字符串string s1(cstr); // s1:China! Greate Wallstring s2(s1); // s2:China! Greate Wallstring s3(cstr，7，11); // s3:Greate Wallstring s4(cstr，6); // s4:China!string s5(5，'A'); // s5:AAAAA 主要成员函数： empty()：判断当前字符串是否为空串 size()：返回当前字符串的实际字符个数。 length()：返回当前字符串的实际字符个数。 [idx]：返回当前字符串位于idx位置的字符，idx从0开始。 at(idx)：返回当前字符串位于idx位置的字符。 compare(const string&amp; str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 append(cstr)：在当前字符串的末尾添加一个字符串str。 insert(size_type idx，const string&amp; str) ：在当前字符串的idx处插入一个字符串str。 find(string &amp;s,size_type pos):从当前字符串中的pos位置开始查找字符串s的第一个位置，，找到后返回其位置，若没有找到返回-1。 replace(size_type idx,size_type len,costring&amp; str):将当前字符串中起始于idx的len个字符用一个字符串str替换。 substr(size_type idx,size_type len):返回当前字符串起始于idx的长度为len的字串。 clear():删除当前字符串中的所有字符。 erase():删除当前字符串中的所有字符。 erase(size_type idx):删除当前字符串从idx开始的所有字符。 erase(size_type idx,size_type len):删除当前字符串从idx开始的len个字符。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include &lt; iostream&gt; #include &lt; string&gt; using namespace std; int main(){ string s1 = &quot;&quot;, s2, s3 = &quot;Bye&quot;; s1.append(&quot;Good morning&quot;); //s1=&quot; Good morning&quot; s2 = s1; //s1=&quot; Good morning&quot; int i = s2.find(&quot;morning&quot;); //i=5 s2.replace(i, s2.length() - i, s3); //相当于s2.replace(5,7,s3) cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; endl; return 0; } 输出：s1：Good morning s2:Good Bye 3.deque(双端队列)实现头文件：&lt; deque&gt;定义方式：123456deque&lt;int&gt; dq1; //定义元素为int的双端队列dq1deque&lt;int&gt; dq2(10); //指定dq2的初始大小为10个int元素deque&lt;double&gt; dq3(10，1.23); //指定dq3的10个初始元素的初值为1.23deque&lt;int&gt; dq4(dq2.begin()，dq2.end()); //用dq2的所有元素初始化dq4 主要成员函数： empty()：判断双端队列容器是否为空队。 size()：返回双端队列容器中元素个数。 push_front(elem)：在队头插入元素elem。 push_back(elem)：在队尾插入元素elem。 pop_front()：删除队头一个元素。 pop_back()：删除队尾一个元素。 erase()：从双端队列容器中删除一个或几个元素。 clear()：删除双端队列容器中所有元素。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;deque&gt; using namespace std; void disp(deque&lt;int&gt; &amp;dq) //输出dq的所有元素 { deque&lt;int&gt;::iterator iter; //定义迭代器iter for (iter=dq.begin();iter!=dq.end();iter++) printf(&quot;%d &quot;,*iter); printf(&quot;\n&quot;); } int main() { deque&lt;int&gt; dq; //建立一个双端队列dq dq.push_front(1); //队头插入1 dq.push_back(2); //队尾插入2 dq.push_front(3); //队头插入3 dq.push_back(4); //队尾插入4 printf(&quot;dq: &quot;); disp(dq); dq.pop_front(); //删除队头元素 dq.pop_back(); //删除队尾元素 printf(&quot;dq: &quot;); disp(dq); return 0; } 输出： dq:3 1 2 4 dq:1 2 4.list(链表容器)实现头文件：&lt; list&gt;定义方式：1234list&lt;int&gt; l1; //定义元素为int的链表l1list&lt;int&gt; l2 (10); //指定链表l2的初始大小为10个int元素list&lt;double&gt; l3 (10，1.23); //指定l3的10个初始元素的初值为1.23list&lt;int&gt; l4(a，a+5); //用数组a[0..4]共5个元素初始化l4 主要成员函数： empty()：判断链表容器是否为空。 size()：返回链表容器中实际元素个数。 push_back()：在链表尾部插入元素。 pop_back()：删除链表容器的最后一个元素。 remove ()：删除链表容器中所有指定值的元素。 remove_if(cmp)：删除链表容器中满足条件的元素。 erase()：从链表容器中删除一个或几个元素。 unique()：删除链表容器中相邻的重复元素。 clear()：删除链表容器中所有的元素。 insert(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，n，elem)：在pos位置插入n个元素elem。 insert(pos，pos1，pos2)：在迭代器pos处插入[pos1，pos2)的元素。 reverse()：反转链表。 sort()：对链表容器中的元素排序。 迭代器函数：begin()、end()、rbegin()、rend()。 演示代码： #include&lt;iostream&gt; #include &lt;list&gt; using namespace std; void disp(list&lt;int&gt; &amp;lst) //输出lst的所有元素 { list&lt;int&gt;::iterator it; for (it = lst.begin(); it != lst.end(); it++) printf(&quot;%d &quot;, *it); printf(&quot;\n&quot;); } int main() { list&lt;int&gt; lst; //定义list容器lst list&lt;int&gt;::iterator it, start, end; lst.push_back(5); //添加5个整数5,2,4,1,3 lst.push_back(2); lst.push_back(4); lst.push_back(1); lst.push_back(3); printf(&quot;初始lst: &quot;); disp(lst); it = lst.begin(); //it指向首元素5 start = ++lst.begin(); //start指向第2个元素2 end = --lst.end(); //end指向尾元素3 lst.insert(it, start, end); printf(&quot;执行lst.insert(it,start,end)\n&quot;); printf(&quot;插入后lst: &quot;); disp(lst); return 0; } 输出： 初始lst: 5 2 4 1 3 执行lst.insert(it,start,end) 插入后lst: 2 4 1 5 2 4 1 3]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(1)]]></title>
    <url>%2F2019%2F03%2F23%2Fc%2B%2BSTL%2F</url>
    <content type="text"><![CDATA[这篇大体介绍一下STL相关内容STL简介C++中已经实现了数据结构中的很多容器和算法，它们构成标准C++库的子集，即标准模板类库 (Standard Template Library).STL是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。 STL概述STL主要由container(容器)、algorithm(算法)和iterator(迭代器)三大部分构成，容器用于存放数据对象(元素)，算法用于操作容器中的数据对象，算法和容器之间的中介就是迭代器。 container(容器):简单的说一个stl容器就是一种数据结构，例如链表、栈和队列等，STL中都已经实现好了，在算法设计中可以直接使用它们。这篇下面会详细讲各个容器，另外一些哈希表容器hash_set,hash_map等，它们属于非标准STL容器，其功能可以用set,map代替。 algorithm(算法):stl的算法部分主要由头文件、和组成。stl提供了大约100个实现算法的模板函数。 iterator(迭代器):stl迭代器用于访问容器中的数据对象。每个容器都有自己的迭代器，只有容器自己知道如何访问自己的元素。迭代器像c/c++中的指针，算法通过迭代器来定位和操作容器中的元素。 常用STL容器STL容器很多，每一个容器就是一个类模板，大致分为顺序容器、适配器容器和关联容器3种类型。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找的分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找折半查找又称二分查找，它是一种效率较高的查找方法。但是折半查找要求查找序列中的元素是有序的，为了简单，假设序列是递增有序的。折半查找的基本思路：设 a[low···high] 是当前的查找区间，首先确定该区间的中点位置mid=(low+high)/2 (取下界);然后将待查的 k值 与 a[mid].key 比较： （1）若k==a[mid].key,则查找成功并返回该元素的物理下标 （2）若k&lt;a[mid],则由表的有序性可知 a[mid···high] 均大于k，因此表中若存在值 等于k的元素，则该元素必定位于 左子表 a[low···mid-1] 中，故新的查找区间 是左子表a[low···mid-1]。 （3）若k&gt;a[mid],则要查找的元素必定位于 右子表 a[mid+1···high] 中，故新的查找区间 是右子表a[mid+1···high]。 下一次查找是针对新的查找区间进行的。 因此可以从最初的查找区间a[0···n-1]开始，每经过一次与当前查找区间中点位置上的关键字比较就可以确定查找是否成功，不成功则当前的查找区间缩小一半。重复这一过程，直到找到关键字为K的元素，或者直到当前的查找区间为空（即查找失败）时为止。 代码实现12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;using namespace std;//折半查找int BinSearch(int a[], int low, int high, int k)&#123; int mid; if (low &lt;= high)&#123; //当前区间存在元素时 mid = (low + high) / 2; //求查找区间的中间位置 if (a[mid] == k)&#123; //找到了，直接返回其物理下标 mid return mid; &#125; if (a[mid] &gt; k)&#123; //当a[mid]&gt;k 时在a[low···mid-1]中递归查找 return BinSearch(a, low, mid - 1, k); &#125; else&#123; //当a[mid]&lt;k 时在a[mid+1···high]中递归查找 return BinSearch(a, mid + 1, high, k); &#125; &#125; else&#123; return -1; //找不到，错误处理 &#125;&#125;int main()&#123; int n = 10, i; int k = 6; //要找的值 int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; i = BinSearch(a, 0, n - 1, k); if (i &gt;= 0)&#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个元素值为k"; &#125; return 0;&#125; 附：(非递归实现)12345678910111213141516int BinSearch(int a[], int n, int k)&#123; //在含有n个元素的数组a中查找 是否有值为K的元素 int low = 0, high = n - 1, mid; while (low &lt;= high)&#123; mid = (low + high) / 2; if (a[mid] == k)&#123; return mid; &#125; if (a[mid] &gt; k)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序的基本思想是首先将 a[0···n-1] 看成n个长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到n/k^2个长度为k^2的有序子表，如此反复进行下去，最后得到一个长度为n的有序表。若k=2，即归并是在相邻的两个有序子表中进行的，称为二路归并排序。若k&gt;2，即归并操作在相邻的多个有序子表中进行，则叫多路归并排序。我们仅讨论二路归并排序。分解—&gt;子问题求解—&gt;合并 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 #include&lt;iostream&gt;using namespace std;void display(int a[],int n)&#123; //输出数组元素 for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125;&#125;//合并void Merge(int a[], int left, int mid, int right)&#123; int *temp = new int[right - left + 1]; //定义并初始化临时数组 int i = left; //左边序列指针 int j = mid + 1; //右边序列指针 int t = 0; //临时数组指针 while (i &lt;= mid&amp;&amp;j &lt;= right)&#123; //第一个子表（左）和第二个子表（右）均没有扫描完时循环，左边子表和右边子表均从自己的第1个元素开始向右扫描 if (a[i] &lt;= a[j])&#123; temp[t++] = a[i++]; //如果第一个子表的当前元素值小，放入temp中 &#125; else&#123; temp[t++] = a[j++]; //如果第二个子表的当前元素值小，放入temp中 &#125; &#125; while (i &lt;= mid)&#123; //如果第一个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[i++]; &#125; while (j &lt;= right)&#123; //如果第二个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[j++]; &#125; t = 0; while (left &lt;= right)&#123; //将temp中的元素全部复制到原数组中 a[left++] = temp[t++]; &#125; delete[]temp; //释放临时空间&#125;//归并排序void MergeSort(int a[],int left,int right)&#123; if (left &lt; right)&#123; //子序列有两个或两个以上元素 int mid = (left + right) / 2; MergeSort(a, left, mid); //左边归并排序，使得左子序列有序 MergeSort(a, mid + 1, right); //右边归并排序，使得右子序列有序 Merge(a, left, mid, right); //将两个有序子序列合并 &#125;&#125;int main()&#123; int a[9] = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; cout &lt;&lt; "排序前： "; display(a,9); cout &lt;&lt; endl; cout &lt;&lt;"排序后： "; MergeSort(a,0,8); display(a, 9);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序的基本思想是在待排序的n个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分，然后对子序列分别重复上述过程，直到每个子序列内只有一个元素或为空为止。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;//输出a中所有元素void display(int a[],int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;//划分int Partition(int a[], int s, int t)&#123; int i = s, j = t; int tem = a[s]; //用序列的第1个记录作为基准 while (i != j)&#123; //从序列两端交替向中间扫描，直到 i=j 为止 while (j&gt;i&amp;&amp;a[j] &gt;= tem)&#123; j--; //从右向左扫描，找到第一个关键字小于tem的a[j] &#125; a[i] = a[j]; //将a[j]前移到a[i]的位置 while (i &lt; j&amp;&amp;a[i] &lt;= tem)&#123; i++; //从左向右扫描，找到第一个关键字大于tem的a[i] &#125; a[j] = a[i]; //将a[i]后移到a[j]的位置 &#125; a[i] = tem; //将基准插到中间 return i;&#125;void QuickSort(int a[], int s, int t)&#123; //对 a[s···t]元素序列进行递增排序 if (s &lt; t)&#123; int i = Partition(a, s, t); //基准的位置 QuickSort(a, s, i - 1); //对基准左边的序列递归排序 QuickSort(a, i+1, t); //对基准右边的序列递归排序 &#125;&#125;int main()&#123; int n = 10; int a[] = &#123; 2, 5, 1, 7, 10, 6, 9, 4, 3, 8 &#125;; cout &lt;&lt; &quot;排序前：&quot;; display(a,n); cout &lt;&lt; endl; cout &lt;&lt; &quot;排序后：&quot;; QuickSort(a, 0, n - 1); display(a, n);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(3)]]></title>
    <url>%2F2019%2F03%2F22%2Fbaidulbs3%2F</url>
    <content type="text"><![CDATA[说一下百度LBS的SDk版本肯定以后会更新，或许更新后刚才的小例子就gg了，不能跑了，所以官方的才是最新的，最好的 官网学习Android地图SDK指南]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(2)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs2%2F</url>
    <content type="text"><![CDATA[这篇搞一下codeAndroidManifest.xml 文件下面要用到的 API_KEY,去（1）中创建的应用中查看，就是下图中访问应用对应的，复制就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.example.qqqq"&gt; &lt;!-- 此权限用于网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;!-- 此权限用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;!-- 此权限可以获取使用Wi-Fi等WLAN无线网络--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;!-- 改变WLAN状态的开关，如果打开或关闭Wi-Fi必需加入这个声明--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取手机当前状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;!-- 可以向存储卡写入数据，写入离线定位数据要用到--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;!-- 此权限用于访问网络--&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!-- SD卡读取权限，用户写入离线数据--&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" tools:ignore="ProtectedPermissions" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- 这里的meta标签和service是必须要添加的两个标签，meta标签中name属性是固定的，value属性就是你 刚才在百度那创建的应用后得到的 API_KEY 的值，service中的也是固定的，写上就行--&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="jtBn5iCn3B5CEolmfwCPlSchXnQXFmTd"/&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true"&gt; &lt;/service&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; activity_main.xml 文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这里的TextView 是用来测试的，看一下经纬度，地址啥的有没有错误，后面设置为不可见了--&gt; &lt;TextView android:id="@+id/show_data" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" android:visibility="gone"/&gt; &lt;!-- 添加这个百度提供的 View，固定格式，id可以自己改--&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/show_bdmap" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true"&gt; &lt;/com.baidu.mapapi.map.MapView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class MainActivity extends AppCompatActivity &#123; private TextView showData; private LocationClient mLocationListener; private boolean isFirstLocate=true; private BaiduMap baiduMap; private MapView showBdmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //进行初始化操作，这一步必须在 setContentView(R.layout.activity_main) 之前，否则会报错 SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); //申请权限和处理权限 List&lt;String&gt; permissionlist=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)!= PackageManager.PERMISSION_GRANTED)&#123; permissionlist.add(Manifest.permission.ACCESS_COARSE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_NETWORK_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CHANGE_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.CHANGE_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.INTERNET); &#125; if(!permissionlist.isEmpty())&#123; String[] permissions=permissionlist.toArray(new String[permissionlist.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; initData(); &#125; &#125; //申请权限和处理权限 public void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(MainActivity.this, "必须同意才能用!", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; initData(); &#125;else&#123; Toast.makeText(MainActivity.this,"发生未知错误!",Toast.LENGTH_SHORT); finish(); &#125; break; &#125; &#125; private void initData()&#123; //初始化对象 showData=findViewById(R.id.show_data); showBdmap=findViewById(R.id.show_bdmap); baiduMap=showBdmap.getMap(); //BaiduMap是地图总控制器，这里获取一个BaiduMap的实例 baiduMap.setMyLocationEnabled(true); //百度地图是否显示我的位置，这个必须要写，否则设备的位置将无法在地图上显示 //设置位置客户端选项 LocationClientOption option=new LocationClientOption(); //设置定位模式为高精度模式 option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy); //设置间隔扫描的时间,每隔5秒会更新一次定位信息 option.setScanSpan(5000); //设置是否需要地址（需要联网，百度提供的位置信息） option.setIsNeedAddress(true); //实例化 LocationClient 传入的context应该是全局的 mLocationListener=new LocationClient(getApplicationContext()); //将选项设置进去 mLocationListener.setLocOption(option); //设置监听器 mLocationListener.registerLocationListener(new BDAbstractLocationListener() &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentPosition=new StringBuilder(); //获取经纬度 currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("经线：").append(bdLocation.getLongitude()).append("\n"); //获取详细地址信息 currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道：").append(bdLocation.getStreet()).append("\n"); //获取定位方式 currentPosition.append("定位方式："); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS定位"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络定位"); &#125; //更新地图位置 if(bdLocation.getLocType()==BDLocation.TypeGpsLocation||bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; //这个就是测试一下，显示的信息是否合理 showData.setText(currentPosition); &#125; &#125;); //开始定位 mLocationListener.start(); &#125; //更新位置 private void navigateTo(BDLocation bdLocation) &#123; //只让它更新一次 if(isFirstLocate)&#123; //获得经纬度 装进Latlng LatLng ll=new LatLng(bdLocation.getLatitude(),bdLocation.getLongitude()); //设置地图更新位置到 MapStatusUpdate 里面 MapStatusUpdate update= MapStatusUpdateFactory.newLatLng(ll); //地图更新 baiduMap.animateMapStatus(update); //设置缩放比例 update=MapStatusUpdateFactory.zoomTo(16f); //地图更新，完成缩放 baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; //构建我的位置，MyLocationData.Builder这个类是用来封装当前设备所在位置的，只需将经纬度传入到这个类的相应方法中即可 MyLocationData.Builder builder=new MyLocationData.Builder(); //获取经纬度 builder.latitude(bdLocation.getLatitude()); builder.longitude(bdLocation.getLongitude()); //构建 MyLocationData 实例，只需调用MyLocationData.Builder这个类的 build()方法 MyLocationData locationData=builder.build(); //将设备当前位置显示在地图上 baiduMap.setMyLocationData(locationData); &#125; //处理生命周期，这里必须要处理，像 mLocationListener.stop();如果不停止的话，会在后台不停地定位，消耗电量 protected void onResume()&#123; super.onResume(); showBdmap.onResume(); &#125; protected void onPause()&#123; super.onPause(); showBdmap.onPause(); &#125; protected void onDestroy()&#123; super.onDestroy(); mLocationListener.stop(); showBdmap.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(1)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs%2F</url>
    <content type="text"><![CDATA[这篇主要搞一下写代码前的一些准备LBS是啥？？？ 基于位置的服务，简称LBS(Location Based Service)，这个技术在近几年比较火，主要原理是利用无线电通讯网络或GPS等定位方式来确定出当前移动设备所在的位置。我们用的许多软件都有基本的定位服务，像天气，地图等等。 定位方式？？？通常有两种，一种是通过GPS定位，主要原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种方式精确度非常高，但是缺点是只能在室外使用，室内基本无法接收到卫星的信号。另外一种是网络定位，主要原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，精确度一般，但优点是在室内外都可用。 百度LBS上面的两种定位方式android都提供了相应的API支持，但Google被墙，网络定位的API失效，GPS定位室内不能用，比较蛋疼。相比之下，国内的也有非常好用的LBS–百度LBS服务。 正片开始1.百度地图开放平台 先进这个网址，有账号的登录，没有的注册一个，很简单，把一些基本信息填完整即可。 2.创建应用 再点开这个网址，点击创建应用，如下图 其中SHA1和包名，在androidstudio项目中如图： 双击signingReport 在你的androidstudio下方就会出现 包名可以在AndroidManifest.xml中查看 3.下载百度地图SDK 百度地图SDK 点击开发包下载–&gt;自定义下载–&gt;选择自己需要的服务–&gt;开发包下载 4.将下载的文件解压，并导入下图位置 解压后如图： 观察你的项目结构，app模块下有一个libs目录，这里是存放jar包的，所以把解压后的那个jar包 BaiduLBS_Android.jar 复制到这里 接下来展开 scr/main目录，在main上点击右键 new–&gt;Directory 新建一个名为 jniLibs 的目录，将压缩包里的其他目录直接全部复制到这里 最后点击androidstudio顶部工具栏中的 Sync 按钮，这样项目就可以引用我们导入的jar包了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java文件读写操作的一个简单例子]]></title>
    <url>%2F2019%2F03%2F20%2Fjava-io%2F</url>
    <content type="text"><![CDATA[java文件读写操作的一个简单事例一些简单的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class coin extends JFrame implements ActionListener &#123; // 代码中涉及的异常处理自己看情况添加即可 包名更换成自己的 创建的 ceshi.txt 在自己的java项目中的scr文件夹，点击刷新即可看见 private JTextArea jTextArea = new JTextArea(15, 15); private JButton jButton = new JButton("读取"); private JButton jButton2 = new JButton("写入"); public coin() &#123; JFrame jFrame = new JFrame("文件读写"); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); jFrame.setLayout(new FlowLayout()); jFrame.setSize(300, 200); jButton.addActionListener(this); jButton2.addActionListener(this); jFrame.add(jTextArea); jFrame.add(jButton); jFrame.add(jButton2); jFrame.setVisible(true); &#125; // 读取文件 public void readfile() throws IOException &#123; File file = new File("ceshi.txt");// 创建文件 try &#123; InputStream is = new FileInputStream(file);// 创建输入流 byte[] buffer = new byte[200]; while (is.read(buffer) != -1) &#123; String string = new String(buffer); jTextArea.setText(string); &#125; is.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; // 写入文件 public void writefile() throws IOException &#123; File file = new File("ceshi.txt"); try &#123; OutputStream os = new FileOutputStream(file, true);// true是追加写入 默认不追加 String string = jTextArea.getText().toString(); byte[] buffer = string.getBytes();// 将字符串 转换成byte数组 os.write(buffer); os.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // &#125; // 按钮点击事件实现 public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource() == jButton) &#123; try &#123; readfile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; else if (e.getSource() == jButton2) &#123; try &#123; writefile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴矢量图标库]]></title>
    <url>%2F2019%2F03%2F19%2Ftubiao%2F</url>
    <content type="text"><![CDATA[分享一个很棒的图标网站点击下面的链接即可查看 Iconfont–阿里巴巴矢量图标库]]></content>
      <categories>
        <category>随心</category>
      </categories>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个布局的简单注意点]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_layout%2F</url>
    <content type="text"><![CDATA[1.LinearLayout(线性布局)注意两个点：1.orientation 属性：布局中组件的排列方式，有horizontal(水平)，vertical(竖直，默认)两种方式。2.weight 属性：权重属性在屏幕适配时用的比较多(有几种用法可以去百度一下，用一种当 layout_width和layout_height都为match_parent时，可能难理解) 2.RelativeLayout(相对布局)直接看图，也没啥，还有margin和padding写个简单的梅花布局练练就应该都理解了. 3.TableLayout(表格布局)这个基本不常用，一般线性+相对布局就可以了，只需要了解一下。 1.如果我们想一行上有多个组件的话,就要添加一个TableRow的容器,把组件都丢到里面. 2.tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定. 3.tablerow的layout_width属性,默认是fill_parent的,我们自己设置成其他的值也不会生效， 但是layout_height默认是wrapten——content的,我们却可以自己设置大小. 4.整个表格布局的宽度取决于父容器的宽度(占满父容器本身) 5. 123android:collapseColumns:设置需要被隐藏的列的序号android:shrinkColumns:设置允许被收缩的列的列序号android:stretchColumns:设置运行被拉伸的列的列序号 以上这三个属性的列号都是从0开始算的,比如shrinkColunmns = “2”,对应的是第三列！ 可以设置多个,用逗号隔开比如”0,2”,如果是所有列都生效,则用”*”号即可 除了这三个常用属性,还有两个属性,分别就是跳格子以及合并单元格,这和HTML中的Table类似: android:layout_column=”2”:表示的就是跳过第二个,直接显示到第三个格子处,从1开始算的! android:layout_span=”4”:表示合并4个单元格,也就说这个组件占4个单元格 eg:123456789101112&lt;TableRow&gt; &lt;TextView /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="退出"/&gt; &lt;TextView /&gt;&lt;/TableRow&gt; 4.FrameLayout(帧布局)常用属性：12android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 当我们往帧布局里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式,所以它应用的场景并不多;帧布局的大小由控件中最大的子控件决定,如果控件的大小一样大的话,那么同一时刻就只能看到最上面的那个组件!后续添加的控件会覆盖前一个! eg:1234567891011121314151617181920&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:foreground="@drawable/logo" android:foregroundGravity="right|bottom"&gt; &lt;TextView android:layout_width="200dp" android:layout_height="200dp" android:background="#FF6143" /&gt; &lt;TextView android:layout_width="150dp" android:layout_height="150dp" android:background="#7BFE00" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="100dp" android:background="#FFFF00" /&gt; &lt;/FrameLayout&gt; 5.GridLayout(网格布局) 用法： step 1:先定义组件的对其方式 android:orientation 水平或者竖直,设置多少行与多少列 step 2:设置组件所在的行或者列,记得是从0开始算的,不设置默认每个组件占一行一列 step 3:设置组件横跨几行或者几列;设置完毕后,需要在设置一个填充:android:layout_gravity = “fill” eg:计算器的清除键占2格1234&lt;Button android:layout_columnSpan="2" android:layout_gravity="fill" android:text="清空" /&gt; 6.AbsoluteLayout(绝对布局)这个没啥好说的，基本不用，学java swing时就强调过了 控制大小:12android:layout_width:组件宽度android:layout_height:组件高度 控制位置:12android:layout_x:设置组件的X坐标 android:layout_y:设置组件的Y坐标]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (2)--JComboBox]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing02%2F</url>
    <content type="text"><![CDATA[JComboBox Integer Month[]= {1,2,3,4,5,6,7,8,9,10,11,12}; JComboBox jComboBox1=new JComboBox(Month); jComboBox1.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent event) { switch (event.getStateChange()) { case ItemEvent.SELECTED: System.out.println(&quot;选中&quot; + event.getItem()); break; case ItemEvent.DESELECTED: System.out.println(&quot;取消选中&quot;+event.getItem()); break; } } }); JComboBox的监听事件，通过 event.getStateChange() 方法来获取是否处于选中某一项的状态，若处于选中状态,则再通过 event。getItem()即可获取选中项。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (1)--JButton]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing01%2F</url>
    <content type="text"><![CDATA[JButton 12345JButton btn=new JButton("按钮");btn.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; //此处添加要执行的操作 &#125;&#125;); 一般按钮个数比较少的情况下，直接使用匿名内部类的方式更为方便。 当有多个按钮的时候，需要让类继承 ActionListener 接口 123456789101112131415161718192021JButton jButton1=new JButton("btn1");JButton jButton2=new JButton("btn2");jButton1.addActionListener(this);jButton2.addActionListener(this);//下面需要实现 ActionListener 接口的actionPerformed（）方法 1.public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jButton1) &#123; System.out.println("111111"); &#125;else if(e.getSource()==jButton2)&#123; System.out.println("222222"); &#125;&#125;2.public void actionPerformed(ActionEvent e) &#123; if(e.getActionCommand().equals("btn1")) &#123; System.out.println("111111"); &#125;else if(e.getActionCommand().equals("btn2"))&#123; System.out.println("222222"); &#125;&#125; 这里会有两种方式，都可以 1.是利用 e.getSource()来直接获取点击的对象名（注意是对象名，jButton1,jButton2） 2.是利用 e.getActionCommand().equals()来直接获取点击按钮的名称，即字符串（btn1.btn2）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (3)--JList]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-20-java-swing03%2F</url>
    <content type="text"><![CDATA[JList 1234567String province[]= &#123;"省份","北京","天津","上海","重庆"&#125;;JList&lt;String&gt; jList=new JList&lt;&gt;(province);jList.addListSelectionListener(new ListSelectionListener() &#123; public void valueChanged(ListSelectionEvent e) &#123; System.out.println(jList.getSelectedValue().toString()); &#125;&#125;); JList 通过 getSelectedValue() 方法即可获取选中项当然 用 getSelectedIndex() 方法可以获取到点击的项的下标 如此示例中 北京项 下标为1，天津项 下标为2.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter 异常]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-19-javasql01%2F</url>
    <content type="text"><![CDATA[Java 9 及以上 eclipse 链接 SQL数据库 抛出 java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter 异常 方法需要导入 javax.xml.bind.jar 去下载一个即可 网址： http://www.java2s.com/Code/Jar/j/Downloadjavaxxmlbindjar.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (4)--JRadioButton及简单用法]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-24-java-swing04%2F</url>
    <content type="text"><![CDATA[多个JRadioButton必须放到 ButtonGroup 中能起到单选的作用，这里需要注意 ButtonGroup 并不是组件，所以只需把每一个单选按钮添加到 容器内 即可，不需要把 ButtonGroup 添加到容器内，下面演示一下 代码123456789101112131415161718192021222324252627282930313233343536373839package Number;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.ButtonGroup;import javax.swing.JFrame;import javax.swing.JRadioButton;public class coin extends JFrame implements ActionListener&#123; private ButtonGroup buttonGroup=new ButtonGroup(); private JRadioButton jRadioButton=new JRadioButton("男"); private JRadioButton jRadioButton2=new JRadioButton("女"); public coin() &#123; JFrame jFrame=new JFrame("单选按钮"); jFrame.setSize(200, 150); jFrame.setLayout(new FlowLayout()); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); //将单选按钮添加到按钮组中 buttonGroup.add(jRadioButton); buttonGroup.add(jRadioButton2); //设置单选按钮的点击事件 jRadioButton.addActionListener(this); jRadioButton2.addActionListener(this); //只需将单选按钮添加进入容器 jFrame.add(jRadioButton); jFrame.add(jRadioButton2); jFrame.setVisible(true); &#125; //点击事件实现方法，同前面的 JButton 的方式，具体可以去看前面的JButton的用法 public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jRadioButton) &#123; System.out.println("boy"); &#125;else if(e.getSource()==jRadioButton2) &#123; System.out.println("girl"); &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android工程解析]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_project%2F</url>
    <content type="text"><![CDATA[先看图，这张图再熟悉不过了 下面进行一些解释1.java：我们写Java代码的地方，业务功能都在这里实现 2.res：存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件 3.drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 4.mipmap-hdpi：高分辨率，一般我们把图片丢这里mipmap-mdpi：中等分辨率mipmap-xhdpi：超高分辨率mipmap-xxhdpi：超超高分辨率 5.layout：该目录下存放的就是我们的布局文件 6.values：该目录下存放的是一些定义的字符串资源、样式资源、颜色资源、数组资源等等 在res目录下，所有的资源文件都会在 R.java 文件下生成对应的资源 id,我们可以通过id访问到对应的资源。例如在java代码中使用相关资源：布局引用：setContentView(R.layout.main);图片引用：imgIcon.setBackgroundDrawableResource(R.drawable.icon); 在xml文件中使用相关资源：(通过 @XXX 即可引用)文本引用：android:text=”@string/hello_world”图片引用：android:background = “@drawable/img_back” 分析几个文件1.布局文件 2.MainActivity.java文件 3.AndroidManifest.xml配置文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
