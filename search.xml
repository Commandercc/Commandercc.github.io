<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(1)]]></title>
    <url>%2F2019%2F03%2F23%2Fc%2B%2BSTL%2F</url>
    <content type="text"><![CDATA[这篇大题介绍一下STL相关内容STL简介C++中已经实现了数据结构中的很多容器和算法，它们构成标准C++库的子集，即标准模板类库 (Standard Template Library).STL是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。 STL概述STL主要由container(容器)、algorithm(算法)和iterator(迭代器)三大部分构成，容器用于存放数据对象(元素)，算法用于操作容器中的数据对象，算法和容器之间的中介就是迭代器。 container(容器):简单的说一个stl容器就是一种数据结构，例如链表、栈和队列等，STL中都已经实现好了，在算法设计中可以直接使用它们。这篇下面会详细讲各个容器，另外一些哈希表容器hash_set,hash_map等，它们属于非标准STL容器，其功能可以用set,map代替。 algorithm(算法):stl的算法部分主要由头文件、和组成。stl提供了大约100个实现算法的模板函数。 iterator(迭代器):stl迭代器用于访问容器中的数据对象。每个容器都有自己的迭代器，只有容器自己知道如何访问自己的元素。迭代器像c/c++中的指针，算法通过迭代器来定位和操作容器中的元素。 常用STL容器STL容器很多，每一个容器就是一个类模板，大致分为顺序容器、适配器容器和关联容器3种类型。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL常用容器归纳总结(2)]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A81%2F</url>
    <content type="text"><![CDATA[这篇主要讲一下顺序容器1.vector(向量容器)实现头文件：&lt; vector&gt;定义方式：1234vector&lt;int&gt; v1; //定义元素为int的向量v1vector&lt;int&gt; v2(10); //指定向量v2的初始大小为10个int元素vector&lt;double&gt; v3(10,1.23); //指定v3的10个初始元素的初值为1.23vector&lt;int&gt; v4(a,a+5); //用数组a[0···4]共5个元素初始化v4 主要成员函数： empty(): 判断当前向量是否为空。 size(): 返回当前向量容器中的实际元素个数。 : 返回指定下标的元素。 reserve(n): 为当前向量容器预分配n个元素的存储空间。 capacity(): 返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 resize(n): 调整当前向量容器的大小，使其能容纳n个元素。 push_back(): 在当前向量容器尾部添加一个元素。 insert(pos,elem): 在pos位置插入元素elem，即将元素elem插入到迭代器指定的元素之前。 front(): 获取当前向量容器的第一个元素。 back(): 获取当前向量容器的最后一个元素。 erase(): 删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 clear(): 删除当前向量容器中的所有元素。 begin(): 该函数的两个版本返回iterator或const_iterator,引用容器的第一个元素。 end(): 该函数的两个版本返回返回iterator或const_iterator,引用容器的最后一个元素后面的一个位置。 rbegin(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的最后一个元素。 rend(): 该函数的两个版本返回reverse_iterator或const_reverse_iterator,引用容器的第一个元素的前面一个位置。 最后两个是反向迭代。 演示代码： #include&lt;iostream&gt; #include&lt; vector&gt; using namespace std; int main(){ vector&lt;int&gt; myv; //定义vector容器myv vector&lt;int&gt;::iterator it;//定义myv的正向迭代器 it myv.push_back(1); //在myv的末尾添加元素 1 it = myv.begin(); //it迭代器指向开头元素 1 myv.insert(it, 2); //在it指向的元素之前插入元素 2 myv.push_back(3); //在myv的末尾添加元素 3 myv.push_back(4); //在myv的末尾添加元素 4 it = myv.end(); //it 迭代器指向元素4的后面 it--; //it 迭代器指向元素 4 myv.erase(it); //删除元素4 for (it = myv.begin(); it != myv.end(); it++){ cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } return 0; }]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找的分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[折半查找折半查找又称二分查找，它是一种效率较高的查找方法。但是折半查找要求查找序列中的元素是有序的，为了简单，假设序列是递增有序的。折半查找的基本思路：设 a[low···high] 是当前的查找区间，首先确定该区间的中点位置mid=(low+high)/2 (取下界);然后将待查的 k值 与 a[mid].key 比较： （1）若k==a[mid].key,则查找成功并返回该元素的物理下标 （2）若k&lt;a[mid],则由表的有序性可知 a[mid···high] 均大于k，因此表中若存在值 等于k的元素，则该元素必定位于 左子表 a[low···mid-1] 中，故新的查找区间 是左子表a[low···mid-1]。 （3）若k&gt;a[mid],则要查找的元素必定位于 右子表 a[mid+1···high] 中，故新的查找区间 是右子表a[mid+1···high]。 下一次查找是针对新的查找区间进行的。 因此可以从最初的查找区间a[0···n-1]开始，每经过一次与当前查找区间中点位置上的关键字比较就可以确定查找是否成功，不成功则当前的查找区间缩小一半。重复这一过程，直到找到关键字为K的元素，或者直到当前的查找区间为空（即查找失败）时为止。 代码实现12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;using namespace std;//折半查找int BinSearch(int a[], int low, int high, int k)&#123; int mid; if (low &lt;= high)&#123; //当前区间存在元素时 mid = (low + high) / 2; //求查找区间的中间位置 if (a[mid] == k)&#123; //找到了，直接返回其物理下标 mid return mid; &#125; if (a[mid] &gt; k)&#123; //当a[mid]&gt;k 时在a[low···mid-1]中递归查找 return BinSearch(a, low, mid - 1, k); &#125; else&#123; //当a[mid]&lt;k 时在a[mid+1···high]中递归查找 return BinSearch(a, mid + 1, high, k); &#125; &#125; else&#123; return -1; //找不到，错误处理 &#125;&#125;int main()&#123; int n = 10, i; int k = 6; //要找的值 int a[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; i = BinSearch(a, 0, n - 1, k); if (i &gt;= 0)&#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个元素值为k"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序的基本思想是首先将 a[0···n-1] 看成n个长度为1的有序表，将相邻的k(k&gt;=2)个有序子表成对归并，得到n/k个长度为k的有序子表；然后再将这些有序子表继续归并，得到n/k^2个长度为k^2的有序子表，如此反复进行下去，最后得到一个长度为n的有序表。若k=2，即归并是在相邻的两个有序子表中进行的，称为二路归并排序。若k&gt;2，即归并操作在相邻的多个有序子表中进行，则叫多路归并排序。我们仅讨论二路归并排序。分解—&gt;子问题求解—&gt;合并 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 #include&lt;iostream&gt;using namespace std;void display(int a[],int n)&#123; //输出数组元素 for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125;&#125;//合并void Merge(int a[], int left, int mid, int right)&#123; int *temp = new int[right - left + 1]; //定义并初始化临时数组 int i = left; //左边序列指针 int j = mid + 1; //右边序列指针 int t = 0; //临时数组指针 while (i &lt;= mid&amp;&amp;j &lt;= right)&#123; //第一个子表（左）和第二个子表（右）均没有扫描完时循环，左边子表和右边子表均从自己的第1个元素开始向右扫描 if (a[i] &lt;= a[j])&#123; temp[t++] = a[i++]; //如果第一个子表的当前元素值小，放入temp中 &#125; else&#123; temp[t++] = a[j++]; //如果第二个子表的当前元素值小，放入temp中 &#125; &#125; while (i &lt;= mid)&#123; //如果第一个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[i++]; &#125; while (j &lt;= right)&#123; //如果第二个子表有剩余元素，则直接将剩余的元素填入temp中 temp[t++] = a[j++]; &#125; t = 0; while (left &lt;= right)&#123; //将temp中的元素全部复制到原数组中 a[left++] = temp[t++]; &#125; delete[]temp; //释放临时空间&#125;//归并排序void MergeSort(int a[],int left,int right)&#123; if (left &lt; right)&#123; //子序列有两个或两个以上元素 int mid = (left + right) / 2; MergeSort(a, left, mid); //左边归并排序，使得左子序列有序 MergeSort(a, mid + 1, right); //右边归并排序，使得右子序列有序 Merge(a, left, mid, right); //将两个有序子序列合并 &#125;&#125;int main()&#123; int a[9] = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; cout &lt;&lt; "排序前： "; display(a,9); cout &lt;&lt; endl; cout &lt;&lt;"排序后： "; MergeSort(a,0,8); display(a, 9);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序分析与实现]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快速排序的基本思想是在待排序的n个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分，然后对子序列分别重复上述过程，直到每个子序列内只有一个元素或为空为止。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;//输出a中所有元素void display(int a[],int n)&#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;//划分int Partition(int a[], int s, int t)&#123; int i = s, j = t; int tem = a[s]; //用序列的第1个记录作为基准 while (i != j)&#123; //从序列两端交替向中间扫描，直到 i=j 为止 while (j&gt;i&amp;&amp;a[j] &gt;= tem)&#123; j--; //从右向左扫描，找到第一个关键字小于tem的a[j] &#125; a[i] = a[j]; //将a[j]前移到a[i]的位置 while (i &lt; j&amp;&amp;a[i] &lt;= tem)&#123; i++; //从左向右扫描，找到第一个关键字大于tem的a[i] &#125; a[j] = a[i]; //将a[i]后移到a[j]的位置 &#125; a[i] = tem; //将基准插到中间 return i;&#125;void QuickSort(int a[], int s, int t)&#123; //对 a[s···t]元素序列进行递增排序 if (s &lt; t)&#123; int i = Partition(a, s, t); //基准的位置 QuickSort(a, s, i - 1); //对基准左边的序列递归排序 QuickSort(a, i+1, t); //对基准右边的序列递归排序 &#125;&#125;int main()&#123; int n = 10; int a[] = &#123; 2, 5, 1, 7, 10, 6, 9, 4, 3, 8 &#125;; cout &lt;&lt; &quot;排序前：&quot;; display(a,n); cout &lt;&lt; endl; cout &lt;&lt; &quot;排序后：&quot;; QuickSort(a, 0, n - 1); display(a, n);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(3)]]></title>
    <url>%2F2019%2F03%2F22%2Fbaidulbs3%2F</url>
    <content type="text"><![CDATA[说一下百度LBS的SDk版本肯定以后会更新，或许更新后刚才的小例子就gg了，不能跑了，所以官方的才是最新的，最好的 官网学习Android地图SDK指南]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(2)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs2%2F</url>
    <content type="text"><![CDATA[这篇搞一下codeAndroidManifest.xml 文件下面要用到的 API_KEY,去（1）中创建的应用中查看，就是下图中访问应用对应的，复制就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.example.qqqq"&gt; &lt;!-- 此权限用于网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;!-- 此权限用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;!-- 此权限可以获取使用Wi-Fi等WLAN无线网络--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;!-- 改变WLAN状态的开关，如果打开或关闭Wi-Fi必需加入这个声明--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;!-- 此权限用于获取手机当前状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;!-- 可以向存储卡写入数据，写入离线定位数据要用到--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;!-- 此权限用于访问网络--&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;!-- SD卡读取权限，用户写入离线数据--&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" tools:ignore="ProtectedPermissions" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- 这里的meta标签和service是必须要添加的两个标签，meta标签中name属性是固定的，value属性就是你 刚才在百度那创建的应用后得到的 API_KEY 的值，service中的也是固定的，写上就行--&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="jtBn5iCn3B5CEolmfwCPlSchXnQXFmTd"/&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true"&gt; &lt;/service&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; activity_main.xml 文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这里的TextView 是用来测试的，看一下经纬度，地址啥的有没有错误，后面设置为不可见了--&gt; &lt;TextView android:id="@+id/show_data" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" android:visibility="gone"/&gt; &lt;!-- 添加这个百度提供的 View，固定格式，id可以自己改--&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/show_bdmap" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true"&gt; &lt;/com.baidu.mapapi.map.MapView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class MainActivity extends AppCompatActivity &#123; private TextView showData; private LocationClient mLocationListener; private boolean isFirstLocate=true; private BaiduMap baiduMap; private MapView showBdmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //进行初始化操作，这一步必须在 setContentView(R.layout.activity_main) 之前，否则会报错 SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); //申请权限和处理权限 List&lt;String&gt; permissionlist=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION)!= PackageManager.PERMISSION_GRANTED)&#123; permissionlist.add(Manifest.permission.ACCESS_COARSE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_NETWORK_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.ACCESS_NETWORK_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CHANGE_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.CHANGE_WIFI_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) &#123; permissionlist.add(Manifest.permission.INTERNET); &#125; if(!permissionlist.isEmpty())&#123; String[] permissions=permissionlist.toArray(new String[permissionlist.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; initData(); &#125; &#125; //申请权限和处理权限 public void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(MainActivity.this, "必须同意才能用!", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; initData(); &#125;else&#123; Toast.makeText(MainActivity.this,"发生未知错误!",Toast.LENGTH_SHORT); finish(); &#125; break; &#125; &#125; private void initData()&#123; //初始化对象 showData=findViewById(R.id.show_data); showBdmap=findViewById(R.id.show_bdmap); baiduMap=showBdmap.getMap(); //BaiduMap是地图总控制器，这里获取一个BaiduMap的实例 baiduMap.setMyLocationEnabled(true); //百度地图是否显示我的位置，这个必须要写，否则设备的位置将无法在地图上显示 //设置位置客户端选项 LocationClientOption option=new LocationClientOption(); //设置定位模式为高精度模式 option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy); //设置间隔扫描的时间,每隔5秒会更新一次定位信息 option.setScanSpan(5000); //设置是否需要地址（需要联网，百度提供的位置信息） option.setIsNeedAddress(true); //实例化 LocationClient 传入的context应该是全局的 mLocationListener=new LocationClient(getApplicationContext()); //将选项设置进去 mLocationListener.setLocOption(option); //设置监听器 mLocationListener.registerLocationListener(new BDAbstractLocationListener() &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; StringBuilder currentPosition=new StringBuilder(); //获取经纬度 currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("经线：").append(bdLocation.getLongitude()).append("\n"); //获取详细地址信息 currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道：").append(bdLocation.getStreet()).append("\n"); //获取定位方式 currentPosition.append("定位方式："); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS定位"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络定位"); &#125; //更新地图位置 if(bdLocation.getLocType()==BDLocation.TypeGpsLocation||bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; //这个就是测试一下，显示的信息是否合理 showData.setText(currentPosition); &#125; &#125;); //开始定位 mLocationListener.start(); &#125; //更新位置 private void navigateTo(BDLocation bdLocation) &#123; //只让它更新一次 if(isFirstLocate)&#123; //获得经纬度 装进Latlng LatLng ll=new LatLng(bdLocation.getLatitude(),bdLocation.getLongitude()); //设置地图更新位置到 MapStatusUpdate 里面 MapStatusUpdate update= MapStatusUpdateFactory.newLatLng(ll); //地图更新 baiduMap.animateMapStatus(update); //设置缩放比例 update=MapStatusUpdateFactory.zoomTo(16f); //地图更新，完成缩放 baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; //构建我的位置，MyLocationData.Builder这个类是用来封装当前设备所在位置的，只需将经纬度传入到这个类的相应方法中即可 MyLocationData.Builder builder=new MyLocationData.Builder(); //获取经纬度 builder.latitude(bdLocation.getLatitude()); builder.longitude(bdLocation.getLongitude()); //构建 MyLocationData 实例，只需调用MyLocationData.Builder这个类的 build()方法 MyLocationData locationData=builder.build(); //将设备当前位置显示在地图上 baiduMap.setMyLocationData(locationData); &#125; //处理生命周期，这里必须要处理，像 mLocationListener.stop();如果不停止的话，会在后台不停地定位，消耗电量 protected void onResume()&#123; super.onResume(); showBdmap.onResume(); &#125; protected void onPause()&#123; super.onPause(); showBdmap.onPause(); &#125; protected void onDestroy()&#123; super.onDestroy(); mLocationListener.stop(); showBdmap.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图定位LBS使用(1)]]></title>
    <url>%2F2019%2F03%2F21%2Fbaidulbs%2F</url>
    <content type="text"><![CDATA[这篇主要搞一下写代码前的一些准备LBS是啥？？？ 基于位置的服务，简称LBS(Location Based Service)，这个技术在近几年比较火，主要原理是利用无线电通讯网络或GPS等定位方式来确定出当前移动设备所在的位置。我们用的许多软件都有基本的定位服务，像天气，地图等等。 定位方式？？？通常有两种，一种是通过GPS定位，主要原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种方式精确度非常高，但是缺点是只能在室外使用，室内基本无法接收到卫星的信号。另外一种是网络定位，主要原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，精确度一般，但优点是在室内外都可用。 百度LBS上面的两种定位方式android都提供了相应的API支持，但Google被墙，网络定位的API失效，GPS定位室内不能用，比较蛋疼。相比之下，国内的也有非常好用的LBS–百度LBS服务。 正片开始1.百度地图开放平台 先进这个网址，有账号的登录，没有的注册一个，很简单，把一些基本信息填完整即可。 2.创建应用 再点开这个网址，点击创建应用，如下图 其中SHA1和包名，在androidstudio项目中如图： 双击signingReport 在你的androidstudio下方就会出现 包名可以在AndroidManifest.xml中查看 3.下载百度地图SDK 百度地图SDK 点击开发包下载–&gt;自定义下载–&gt;选择自己需要的服务–&gt;开发包下载 4.将下载的文件解压，并导入下图位置 解压后如图： 观察你的项目结构，app模块下有一个libs目录，这里是存放jar包的，所以把解压后的那个jar包 BaiduLBS_Android.jar 复制到这里 接下来展开 scr/main目录，在main上点击右键 new–&gt;Directory 新建一个名为 jniLibs 的目录，将压缩包里的其他目录直接全部复制到这里 最后点击androidstudio顶部工具栏中的 Sync 按钮，这样项目就可以引用我们导入的jar包了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>百度LBS</tag>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java文件读写操作的一个简单例子]]></title>
    <url>%2F2019%2F03%2F20%2Fjava-io%2F</url>
    <content type="text"><![CDATA[java文件读写操作的一个简单事例一些简单的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class coin extends JFrame implements ActionListener &#123; // 代码中涉及的异常处理自己看情况添加即可 包名更换成自己的 创建的 ceshi.txt 在自己的java项目中的scr文件夹，点击刷新即可看见 private JTextArea jTextArea = new JTextArea(15, 15); private JButton jButton = new JButton("读取"); private JButton jButton2 = new JButton("写入"); public coin() &#123; JFrame jFrame = new JFrame("文件读写"); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); jFrame.setLayout(new FlowLayout()); jFrame.setSize(300, 200); jButton.addActionListener(this); jButton2.addActionListener(this); jFrame.add(jTextArea); jFrame.add(jButton); jFrame.add(jButton2); jFrame.setVisible(true); &#125; // 读取文件 public void readfile() throws IOException &#123; File file = new File("ceshi.txt");// 创建文件 try &#123; InputStream is = new FileInputStream(file);// 创建输入流 byte[] buffer = new byte[200]; while (is.read(buffer) != -1) &#123; String string = new String(buffer); jTextArea.setText(string); &#125; is.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; // 写入文件 public void writefile() throws IOException &#123; File file = new File("ceshi.txt"); try &#123; OutputStream os = new FileOutputStream(file, true);// true是追加写入 默认不追加 String string = jTextArea.getText().toString(); byte[] buffer = string.getBytes();// 将字符串 转换成byte数组 os.write(buffer); os.close(); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; // &#125; // 按钮点击事件实现 public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource() == jButton) &#123; try &#123; readfile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; else if (e.getSource() == jButton2) &#123; try &#123; writefile(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用]]></title>
    <url>%2F2019%2F03%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[12 34]]></content>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴矢量图标库]]></title>
    <url>%2F2019%2F03%2F19%2Ftubiao%2F</url>
    <content type="text"><![CDATA[分享一个很棒的图标网站点击下面的链接即可查看 Iconfont–阿里巴巴矢量图标库]]></content>
      <tags>
        <tag>随心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个布局的简单注意点]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_layout%2F</url>
    <content type="text"><![CDATA[1.LinearLayout(线性布局)注意两个点：1.orientation 属性：布局中组件的排列方式，有horizontal(水平)，vertical(竖直，默认)两种方式。2.weight 属性：权重属性在屏幕适配时用的比较多(有几种用法可以去百度一下，用一种当 layout_width和layout_height都为match_parent时，可能难理解) 2.RelativeLayout(相对布局)直接看图，也没啥，还有margin和padding写个简单的梅花布局练练就应该都理解了. 3.TableLayout(表格布局)这个基本不常用，一般线性+相对布局就可以了，只需要了解一下。 1.如果我们想一行上有多个组件的话,就要添加一个TableRow的容器,把组件都丢到里面. 2.tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定. 3.tablerow的layout_width属性,默认是fill_parent的,我们自己设置成其他的值也不会生效， 但是layout_height默认是wrapten——content的,我们却可以自己设置大小. 4.整个表格布局的宽度取决于父容器的宽度(占满父容器本身) 5. 123android:collapseColumns:设置需要被隐藏的列的序号android:shrinkColumns:设置允许被收缩的列的列序号android:stretchColumns:设置运行被拉伸的列的列序号 以上这三个属性的列号都是从0开始算的,比如shrinkColunmns = “2”,对应的是第三列！ 可以设置多个,用逗号隔开比如”0,2”,如果是所有列都生效,则用”*”号即可 除了这三个常用属性,还有两个属性,分别就是跳格子以及合并单元格,这和HTML中的Table类似: android:layout_column=”2”:表示的就是跳过第二个,直接显示到第三个格子处,从1开始算的! android:layout_span=”4”:表示合并4个单元格,也就说这个组件占4个单元格 eg:123456789101112&lt;TableRow&gt; &lt;TextView /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="退出"/&gt; &lt;TextView /&gt;&lt;/TableRow&gt; 4.FrameLayout(帧布局)常用属性：12android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 当我们往帧布局里面添加控件的时候,会默认把他们放到这块区域的左上角,而这种布局方式却没有任何的定位方式,所以它应用的场景并不多;帧布局的大小由控件中最大的子控件决定,如果控件的大小一样大的话,那么同一时刻就只能看到最上面的那个组件!后续添加的控件会覆盖前一个! eg:1234567891011121314151617181920&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:foreground="@drawable/logo" android:foregroundGravity="right|bottom"&gt; &lt;TextView android:layout_width="200dp" android:layout_height="200dp" android:background="#FF6143" /&gt; &lt;TextView android:layout_width="150dp" android:layout_height="150dp" android:background="#7BFE00" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="100dp" android:background="#FFFF00" /&gt; &lt;/FrameLayout&gt; 5.GridLayout(网格布局) 用法： step 1:先定义组件的对其方式 android:orientation 水平或者竖直,设置多少行与多少列 step 2:设置组件所在的行或者列,记得是从0开始算的,不设置默认每个组件占一行一列 step 3:设置组件横跨几行或者几列;设置完毕后,需要在设置一个填充:android:layout_gravity = “fill” eg:计算器的清除键占2格1234&lt;Button android:layout_columnSpan="2" android:layout_gravity="fill" android:text="清空" /&gt; 6.AbsoluteLayout(绝对布局)这个没啥好说的，基本不用，学java swing时就强调过了 控制大小:12android:layout_width:组件宽度android:layout_height:组件高度 控制位置:12android:layout_x:设置组件的X坐标 android:layout_y:设置组件的Y坐标]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (2)--JComboBox]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing02%2F</url>
    <content type="text"><![CDATA[JComboBox Integer Month[]= {1,2,3,4,5,6,7,8,9,10,11,12}; JComboBox jComboBox1=new JComboBox(Month); jComboBox1.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent event) { switch (event.getStateChange()) { case ItemEvent.SELECTED: System.out.println(&quot;选中&quot; + event.getItem()); break; case ItemEvent.DESELECTED: System.out.println(&quot;取消选中&quot;+event.getItem()); break; } } }); JComboBox的监听事件，通过 event.getStateChange() 方法来获取是否处于选中某一项的状态，若处于选中状态,则再通过 event。getItem()即可获取选中项。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (1)--JButton]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-21-java-swing01%2F</url>
    <content type="text"><![CDATA[JButton 12345JButton btn=new JButton("按钮");btn.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; //此处添加要执行的操作 &#125;&#125;); 一般按钮个数比较少的情况下，直接使用匿名内部类的方式更为方便。 当有多个按钮的时候，需要让类继承 ActionListener 接口 123456789101112131415161718192021JButton jButton1=new JButton("btn1");JButton jButton2=new JButton("btn2");jButton1.addActionListener(this);jButton2.addActionListener(this);//下面需要实现 ActionListener 接口的actionPerformed（）方法 1.public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jButton1) &#123; System.out.println("111111"); &#125;else if(e.getSource()==jButton2)&#123; System.out.println("222222"); &#125;&#125;2.public void actionPerformed(ActionEvent e) &#123; if(e.getActionCommand().equals("btn1")) &#123; System.out.println("111111"); &#125;else if(e.getActionCommand().equals("btn2"))&#123; System.out.println("222222"); &#125;&#125; 这里会有两种方式，都可以 1.是利用 e.getSource()来直接获取点击的对象名（注意是对象名，jButton1,jButton2） 2.是利用 e.getActionCommand().equals()来直接获取点击按钮的名称，即字符串（btn1.btn2）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (3)--JList]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-20-java-swing03%2F</url>
    <content type="text"><![CDATA[JList 1234567String province[]= &#123;"省份","北京","天津","上海","重庆"&#125;;JList&lt;String&gt; jList=new JList&lt;&gt;(province);jList.addListSelectionListener(new ListSelectionListener() &#123; public void valueChanged(ListSelectionEvent e) &#123; System.out.println(jList.getSelectedValue().toString()); &#125;&#125;); JList 通过 getSelectedValue() 方法即可获取选中项当然 用 getSelectedIndex() 方法可以获取到点击的项的下标 如此示例中 北京项 下标为1，天津项 下标为2.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter 异常]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-19-javasql01%2F</url>
    <content type="text"><![CDATA[Java 9 及以上 eclipse 链接 SQL数据库 抛出 java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter 异常 方法需要导入 javax.xml.bind.jar 去下载一个即可 网址： http://www.java2s.com/Code/Jar/j/Downloadjavaxxmlbindjar.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swing 中一些控件的点击事件 (4)--JRadioButton及简单用法]]></title>
    <url>%2F2019%2F03%2F19%2F2018-12-24-java-swing04%2F</url>
    <content type="text"><![CDATA[多个JRadioButton必须放到 ButtonGroup 中能起到单选的作用，这里需要注意 ButtonGroup 并不是组件，所以只需把每一个单选按钮添加到 容器内 即可，不需要把 ButtonGroup 添加到容器内，下面演示一下 代码123456789101112131415161718192021222324252627282930313233343536373839package Number;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.ButtonGroup;import javax.swing.JFrame;import javax.swing.JRadioButton;public class coin extends JFrame implements ActionListener&#123; private ButtonGroup buttonGroup=new ButtonGroup(); private JRadioButton jRadioButton=new JRadioButton("男"); private JRadioButton jRadioButton2=new JRadioButton("女"); public coin() &#123; JFrame jFrame=new JFrame("单选按钮"); jFrame.setSize(200, 150); jFrame.setLayout(new FlowLayout()); jFrame.setDefaultCloseOperation(EXIT_ON_CLOSE); //将单选按钮添加到按钮组中 buttonGroup.add(jRadioButton); buttonGroup.add(jRadioButton2); //设置单选按钮的点击事件 jRadioButton.addActionListener(this); jRadioButton2.addActionListener(this); //只需将单选按钮添加进入容器 jFrame.add(jRadioButton); jFrame.add(jRadioButton2); jFrame.setVisible(true); &#125; //点击事件实现方法，同前面的 JButton 的方式，具体可以去看前面的JButton的用法 public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==jRadioButton) &#123; System.out.println("boy"); &#125;else if(e.getSource()==jRadioButton2) &#123; System.out.println("girl"); &#125; &#125; public static void main(String args[]) &#123; new coin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android工程解析]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid_project%2F</url>
    <content type="text"><![CDATA[先看图，这张图再熟悉不过了 下面进行一些解释1.java：我们写Java代码的地方，业务功能都在这里实现 2.res：存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件 3.drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 4.mipmap-hdpi：高分辨率，一般我们把图片丢这里mipmap-mdpi：中等分辨率mipmap-xhdpi：超高分辨率mipmap-xxhdpi：超超高分辨率 5.layout：该目录下存放的就是我们的布局文件 6.values：该目录下存放的是一些定义的字符串资源、样式资源、颜色资源、数组资源等等 在res目录下，所有的资源文件都会在 R.java 文件下生成对应的资源 id,我们可以通过id访问到对应的资源。例如在java代码中使用相关资源：布局引用：setContentView(R.layout.main);图片引用：imgIcon.setBackgroundDrawableResource(R.drawable.icon); 在xml文件中使用相关资源：(通过 @XXX 即可引用)文本引用：android:text=”@string/hello_world”图片引用：android:background = “@drawable/img_back” 分析几个文件1.布局文件 2.MainActivity.java文件 3.AndroidManifest.xml配置文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
